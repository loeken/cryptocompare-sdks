#
# CryptoCompare Market, Index, Reference Data, News and Overview Metrcis API for the Cryptocurrency Industry
# 
# CryptoCompare is the world's leading digital asset data company, providing services that cater to corporate, government and retail clients. Our main reference index is widely recognized as a reliable benchmark, and we have been authorized by the Financial Conduct Authority (FCA) in the United Kingdom to operate as a benchmark administrator. In addition to catering to corporate, government, and retail clients, we offer a range of services including comprehensive market data for cryptocurrency exchanges in both the centralized and decentralized finance sectors, as well as individual asset data on custodians, supported platforms, and privacy solutions. Our offerings include price, volume, trade, and orderbook updates, as well as historical OHLCV data.
# The version of the OpenAPI document: 2.1.1
# Contact: data@cryptocompare.com
# Generated by: https://openapi-generator.tech
#

import httpclient
import json
import logging
import marshal
import options
import strformat
import strutils
import tables
import typetraits
import uri

import ../models/model_error
import ../models/model_generic_response

const basepath = "https://data-api.cryptocompare.com"

template constructResult[T](response: Response): untyped =
  if response.code in {Http200, Http201, Http202, Http204, Http206}:
    try:
      when name(stripGenericParams(T.typedesc).typedesc) == name(Table):
        (some(json.to(parseJson(response.body), T.typedesc)), response)
      else:
        (some(marshal.to[T](response.body)), response)
    except JsonParsingError:
      # The server returned a malformed response though the response code is 2XX
      # TODO: need better error handling
      error("JsonParsingError")
      (none(T.typedesc), response)
  else:
    (none(T.typedesc), response)


proc assetV1DataByAddress*(httpClient: HttpClient, address: string, chainSymbol: string, groups: string): (Option[GENERIC_RESPONSE], Response) =
  ## 
  let query_for_api_call = encodeQuery([
    ("address", $address), # 
    ("chain_symbol", $chainSymbol), # 
    ("groups", $groups), # 
  ])

  let response = httpClient.get(basepath & "/asset/v1/data/by/address" & "?" & query_for_api_call)
  constructResult[GENERIC_RESPONSE](response)


proc assetV1DataById*(httpClient: HttpClient, assetId: int, groups: string): (Option[GENERIC_RESPONSE], Response) =
  ## 
  let query_for_api_call = encodeQuery([
    ("asset_id", $assetId), # The asset id you are interested in
    ("groups", $groups), # 
  ])

  let response = httpClient.get(basepath & "/asset/v1/data/by/id" & "?" & query_for_api_call)
  constructResult[GENERIC_RESPONSE](response)


proc assetV1DataBySymbol*(httpClient: HttpClient, assetSymbol: string, groups: string): (Option[GENERIC_RESPONSE], Response) =
  ## 
  let query_for_api_call = encodeQuery([
    ("asset_symbol", $assetSymbol), # The asset symbol you are interested in
    ("groups", $groups), # 
  ])

  let response = httpClient.get(basepath & "/asset/v1/data/by/symbol" & "?" & query_for_api_call)
  constructResult[GENERIC_RESPONSE](response)


proc assetV1TopList*(httpClient: HttpClient, page: int, pageSize: int, assetType: string, sortBy: string, sortDirection: string, groups: string): (Option[GENERIC_RESPONSE], Response) =
  ## 
  let query_for_api_call = encodeQuery([
    ("page", $page), # The page number for the request to get {page_size} coins at the time.
    ("page_size", $pageSize), # The number of items returned per page
    ("asset_type", $assetType), # The asset class/type
    ("sort_by", $sortBy), # Sort by field ( CREATED_ON,UPDATED_ON,SYMBOL )
    ("sort_direction", $sortDirection), # Sort direction ( DESC,ASC )
    ("groups", $groups), # 
  ])

  let response = httpClient.get(basepath & "/asset/v1/top/list" & "?" & query_for_api_call)
  constructResult[GENERIC_RESPONSE](response)

