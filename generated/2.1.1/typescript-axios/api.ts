/* tslint:disable */
/* eslint-disable */
/**
 * CryptoCompare Market, Index, Reference Data, News and Overview Metrcis API for the Cryptocurrency Industry
 * CryptoCompare is the world\'s leading digital asset data company, providing services that cater to corporate, government and retail clients. Our main reference index is widely recognized as a reliable benchmark, and we have been authorized by the Financial Conduct Authority (FCA) in the United Kingdom to operate as a benchmark administrator. In addition to catering to corporate, government, and retail clients, we offer a range of services including comprehensive market data for cryptocurrency exchanges in both the centralized and decentralized finance sectors, as well as individual asset data on custodians, supported platforms, and privacy solutions. Our offerings include price, volume, trade, and orderbook updates, as well as historical OHLCV data.
 *
 * The version of the OpenAPI document: 2.1.1
 * Contact: data@cryptocompare.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ErrorErr
 */
export interface ErrorErr {
    /**
     * A message describing the error
     * @type {string}
     * @memberof ErrorErr
     */
    'message'?: string;
    /**
     * 
     * @type {ErrorErrOtherInfo}
     * @memberof ErrorErr
     */
    'other_info'?: ErrorErrOtherInfo;
    /**
     * A public facing error type. If you want to treat a specific error use the type.
     * @type {number}
     * @memberof ErrorErr
     */
    'type'?: number;
}
/**
 * 
 * @export
 * @interface ErrorErrOtherInfo
 */
export interface ErrorErrOtherInfo {
    /**
     * The parameter that is resposible for the error
     * @type {string}
     * @memberof ErrorErrOtherInfo
     */
    'param'?: string;
    /**
     * The values resposible for the error
     * @type {Array<string>}
     * @memberof ErrorErrOtherInfo
     */
    'values'?: Array<string>;
}
/**
 * 
 * @export
 * @interface GENERICRESPONSE
 */
export interface GENERICRESPONSE {
    /**
     * 
     * @type {GENERICRESPONSEData}
     * @memberof GENERICRESPONSE
     */
    'Data'?: GENERICRESPONSEData;
    /**
     * 
     * @type {object}
     * @memberof GENERICRESPONSE
     */
    'Err'?: object;
}
/**
 * 
 * @export
 * @interface GENERICRESPONSEData
 */
export interface GENERICRESPONSEData {
    /**
     * The endpoint does not have a reponse defined
     * @type {string}
     * @memberof GENERICRESPONSEData
     */
    'NO_DATA'?: string;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {object}
     * @memberof ModelError
     */
    'Data'?: object;
    /**
     * 
     * @type {ErrorErr}
     * @memberof ModelError
     */
    'Err'?: ErrorErr;
}
/**
 * 
 * @export
 * @interface SPOTINSTRUMENTHISTODATA
 */
export interface SPOTINSTRUMENTHISTODATA {
    /**
     * The mapped from asset (base / symbol/ coin) (e.g. BTC). Only available on instruments that have mapping.
     * @type {string}
     * @memberof SPOTINSTRUMENTHISTODATA
     */
    'BASE'?: string;
    /**
     * The price of the last trade in this time period. If there were no trades in the time period, the open price will be given.
     * @type {number}
     * @memberof SPOTINSTRUMENTHISTODATA
     */
    'CLOSE'?: number;
    /**
     * The price of the first trade in the time period. This is only available when there is at least one trade in the time period.
     * @type {number}
     * @memberof SPOTINSTRUMENTHISTODATA
     */
    'FIRST_TRADE_PRICE'?: number;
    /**
     * The timestamp, in seconds, of the first trade in this time perio. This is only available when there is at least one trade in the time period.
     * @type {number}
     * @memberof SPOTINSTRUMENTHISTODATA
     */
    'FIRST_TRADE_TIMESTAMP'?: number;
    /**
     * The highest trade price in the time period. If there were no trades in the time period, the open price will be given.
     * @type {number}
     * @memberof SPOTINSTRUMENTHISTODATA
     */
    'HIGH'?: number;
    /**
     * The highest value of the trades in the time period. This is only available when there is at least one trade in the time period.
     * @type {number}
     * @memberof SPOTINSTRUMENTHISTODATA
     */
    'HIGH_TRADE_PRICE'?: number;
    /**
     * The timestamp, in seconds, of the highest trade in the time period. This is only available when there is at least one trade in the time period.
     * @type {number}
     * @memberof SPOTINSTRUMENTHISTODATA
     */
    'HIGH_TRADE_TIMESTAMP'?: number;
    /**
     * The unmapped instrument ID
     * @type {string}
     * @memberof SPOTINSTRUMENTHISTODATA
     */
    'INSTRUMENT'?: string;
    /**
     * The last trade price in the time period. This is only available when there is at least one trade in the time period.
     * @type {number}
     * @memberof SPOTINSTRUMENTHISTODATA
     */
    'LAST_TRADE_PRICE'?: number;
    /**
     * The timestamp, in seconds, of the last trade in this time period. This is only available when there is at least one trade in the time period.
     * @type {number}
     * @memberof SPOTINSTRUMENTHISTODATA
     */
    'LAST_TRADE_TIMESTAMP'?: number;
    /**
     * The lowest trade price in the time period. If there were no trades in the time period, the open price will be given.
     * @type {number}
     * @memberof SPOTINSTRUMENTHISTODATA
     */
    'LOW'?: number;
    /**
     * The lowest value of the trades in the time period. This is only available when there is at least one trade in the time period.
     * @type {number}
     * @memberof SPOTINSTRUMENTHISTODATA
     */
    'LOW_TRADE_PRICE'?: number;
    /**
     * The timestamp, in seconds, of the lowest trade in the time period. This is only available when there is at least one trade in the time period.
     * @type {number}
     * @memberof SPOTINSTRUMENTHISTODATA
     */
    'LOW_TRADE_TIMESTAMP'?: number;
    /**
     * The instrument ID, as derived from our mapping rules. This takes the form \"BASE-QUOTE\" (e.g. BTC-USD). Only available on instruments that have been mapped.
     * @type {string}
     * @memberof SPOTINSTRUMENTHISTODATA
     */
    'MAPPED_INSTRUMENT'?: string;
    /**
     * The market / exchange under consideration (e.g. gemini, kraken, coinbase, etc).
     * @type {string}
     * @memberof SPOTINSTRUMENTHISTODATA
     */
    'MARKET'?: string;
    /**
     * The open price for the historical period, this is based on the closest trade before the period start.
     * @type {number}
     * @memberof SPOTINSTRUMENTHISTODATA
     */
    'OPEN'?: number;
    /**
     * The mapped to asset (quote / counter symbol / coin) (e.g. USD). Only available on instruments that have mapping.
     * @type {string}
     * @memberof SPOTINSTRUMENTHISTODATA
     */
    'QUOTE'?: string;
    /**
     * The sum of all the trade volumes in the To asset (quote/counter symbol/coin) for the time period. If there were no trades in the time period, 0 will be returned.
     * @type {number}
     * @memberof SPOTINSTRUMENTHISTODATA
     */
    'QUOTE_VOLUME'?: number;
    /**
     * The sum of all the BUY trade volumes in the to asset (quote/counter symbol/coin) for the time period.
     * @type {number}
     * @memberof SPOTINSTRUMENTHISTODATA
     */
    'QUOTE_VOLUME_BUY'?: number;
    /**
     * The sum of all the SELL trade volumes in the To asset (quote/counter symbol/coin) for the time period.
     * @type {number}
     * @memberof SPOTINSTRUMENTHISTODATA
     */
    'QUOTE_VOLUME_SELL'?: number;
    /**
     * The sum of all the UNKNOWN trade volumes in the To asset (quote/counter symbol/coin) for the time period.
     * @type {number}
     * @memberof SPOTINSTRUMENTHISTODATA
     */
    'QUOTE_VOLUME_UNKNOWN'?: number;
    /**
     * The timestamp in seconds of the beginning of the histo period. For minute it would be every minute at the beginning of the minute, for hour it would be the start of the hour and for daily it is 00:00 GMT.
     * @type {number}
     * @memberof SPOTINSTRUMENTHISTODATA
     */
    'TIMESTAMP'?: number;
    /**
     * The total number of trades seen in this time period. If there were no trades in the time period, 0 will be returned.
     * @type {number}
     * @memberof SPOTINSTRUMENTHISTODATA
     */
    'TOTAL_TRADES'?: number;
    /**
     * The total number of BUY trades seen in this time period. If there were no trades in the time period, 0 will be returned.
     * @type {number}
     * @memberof SPOTINSTRUMENTHISTODATA
     */
    'TOTAL_TRADES_BUY'?: number;
    /**
     * The total number of SELL trades seen in this time period. If there were no trades in the time period, 0 will be returned.
     * @type {number}
     * @memberof SPOTINSTRUMENTHISTODATA
     */
    'TOTAL_TRADES_SELL'?: number;
    /**
     * The total number of UNKNOWN trades seen in this time period. If there were no trades in the time period, 0 will be returned.
     * @type {number}
     * @memberof SPOTINSTRUMENTHISTODATA
     */
    'TOTAL_TRADES_UNKNOWN'?: number;
    /**
     * The type of the message.
     * @type {string}
     * @memberof SPOTINSTRUMENTHISTODATA
     */
    'TYPE'?: string;
    /**
     * The unit of the historical period update: MINUTE for minute, HOUR for hour and DAY for day.
     * @type {string}
     * @memberof SPOTINSTRUMENTHISTODATA
     */
    'UNIT'?: string;
    /**
     * The sum of all the trade volumes in the from asset (base symbol / coin) for the time period. If there were no trades in the time period, 0 will be returned.
     * @type {number}
     * @memberof SPOTINSTRUMENTHISTODATA
     */
    'VOLUME'?: number;
    /**
     * The sum of all the BUY trade volumes in the from asset (base symbol / coin) for the time period.
     * @type {number}
     * @memberof SPOTINSTRUMENTHISTODATA
     */
    'VOLUME_BUY'?: number;
    /**
     * The sum of all the SELL trade volumes in the from asset (base symbol / coin) for the time period.
     * @type {number}
     * @memberof SPOTINSTRUMENTHISTODATA
     */
    'VOLUME_SELL'?: number;
    /**
     * The sum of all the UNKNOWN trade volumes in the from asset (base symbol / coin) for the time period.
     * @type {number}
     * @memberof SPOTINSTRUMENTHISTODATA
     */
    'VOLUME_UNKNOWN'?: number;
}
/**
 * 
 * @export
 * @interface SPOTINSTRUMENTHISTODATARESPONSE
 */
export interface SPOTINSTRUMENTHISTODATARESPONSE {
    /**
     * 
     * @type {Array<SPOTINSTRUMENTHISTODATA>}
     * @memberof SPOTINSTRUMENTHISTODATARESPONSE
     */
    'Data'?: Array<SPOTINSTRUMENTHISTODATA>;
    /**
     * 
     * @type {object}
     * @memberof SPOTINSTRUMENTHISTODATARESPONSE
     */
    'Err'?: object;
}
/**
 * 
 * @export
 * @interface SPOTINSTRUMENTMARKETDATA
 */
export interface SPOTINSTRUMENTMARKETDATA {
    /**
     * The mapped from asset (base / symbol/ coin), e.g. BTC. Only available on instruments that have been mapped.
     * @type {string}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'BASE'?: string;
    /**
     * Our internal sequence number for this tick update. This is unique per market / exchange and trading pair / instrument. It will always be increasing by 1 for each new tick update we send.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CCSEQ'?: number;
    /**
     * The highest trade price of the current day (00:00:00 GMT/UTC). If there were no updates in the time period, the open price will be given. Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_DAY_HIGH'?: number;
    /**
     * The lowest trade price of the current day (00:00:00 GMT/UTC). If there were no updates in the time period, the open price will be given. Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_DAY_LOW'?: number;
    /**
     * The open price for the current day, this is based on the closest trade occurring before the start of the current day (00:00:00 GMT/UTC). Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_DAY_OPEN'?: number;
    /**
     * The sum of all trade quote quantities from the start of the current day (00:00:00 GMT/UTC) until now. Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_DAY_QUOTE_VOLUME'?: number;
    /**
     * The sum of all buy trade quote quantities from the start of the current day (00:00:00 GMT/UTC) until now. Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_DAY_QUOTE_VOLUME_BUY'?: number;
    /**
     * The sum of all sell trade quote quantities from the start of the current day (00:00:00 GMT/UTC) until now. Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_DAY_QUOTE_VOLUME_SELL'?: number;
    /**
     * The sum of all unknown trade quote quantities from the start of the current day (00:00:00 GMT/UTC) until now. Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_DAY_QUOTE_VOLUME_UNKNOWN'?: number;
    /**
     * The total number of trades that have occurred since the start of the current day (00:00:00 GMT/UTC).
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_DAY_TOTAL_TRADES'?: number;
    /**
     * The total number of buy trades since the start of the current day (00:00:00 GMT/UTC).
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_DAY_TOTAL_TRADES_BUY'?: number;
    /**
     * The total number of sell trades since the start of the current day (00:00:00 GMT/UTC).
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_DAY_TOTAL_TRADES_SELL'?: number;
    /**
     * The total number of unknown trades since the start of the current day (00:00:00 GMT/UTC).
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_DAY_TOTAL_TRADES_UNKNOWN'?: number;
    /**
     * The sum of all trade quantities from the start of the current day (00:00:00 GMT/UTC) until now. Given in the base asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_DAY_VOLUME'?: number;
    /**
     * The sum of all buy trade quantities from the start of the current day (00:00:00 GMT/UTC) until now. Given in the base asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_DAY_VOLUME_BUY'?: number;
    /**
     * The sum of all sell trade quantities from the start of the current day (00:00:00 GMT/UTC) until now. Given in the base asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_DAY_VOLUME_SELL'?: number;
    /**
     * The sum of all unknown trade quantities from the start of the current day (00:00:00 GMT/UTC) until now. Given in the base asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_DAY_VOLUME_UNKNOWN'?: number;
    /**
     * The highest trade price of the current hour. If there were no updates in the time period, the open price will be given. Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_HOUR_HIGH'?: number;
    /**
     * The lowest trade price of the current hour. If there were no updates in the time period, the open price will be given. Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_HOUR_LOW'?: number;
    /**
     * The open price for the current hour, this is based on the closest trade occurring before the start of the current hour. Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_HOUR_OPEN'?: number;
    /**
     * The sum of all trade quote quantities from the start of the current hour until now. Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_HOUR_QUOTE_VOLUME'?: number;
    /**
     * The sum of all buy trade quote quantities from the start of the current hour until now. Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_HOUR_QUOTE_VOLUME_BUY'?: number;
    /**
     * The sum of all sell trade quote quantities from the start of the current hour until now. Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_HOUR_QUOTE_VOLUME_SELL'?: number;
    /**
     * The sum of all unknown trade quote quantities from the start of the current hour until now. Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_HOUR_QUOTE_VOLUME_UNKNOWN'?: number;
    /**
     * The total number of trades that have occurred since the start of the current hour.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_HOUR_TOTAL_TRADES'?: number;
    /**
     * The total number of buy trades since the start of the current hour.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_HOUR_TOTAL_TRADES_BUY'?: number;
    /**
     * The total number of sell trades since the start of the current hour.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_HOUR_TOTAL_TRADES_SELL'?: number;
    /**
     * The total number of unknown trades since the start of the current hour.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_HOUR_TOTAL_TRADES_UNKNOWN'?: number;
    /**
     * The sum of all trade quantities from the start of the current hour until now. Given in the base asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_HOUR_VOLUME'?: number;
    /**
     * The sum of all buy trade quantities from the start of the current hour until now. Given in the base asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_HOUR_VOLUME_BUY'?: number;
    /**
     * The sum of all sell trade quantities from the start of the current hour until now. Given in the base asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_HOUR_VOLUME_SELL'?: number;
    /**
     * The sum of all trade quote quantities from the start of the current hour until now. Given in the base asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_HOUR_VOLUME_UNKNOWN'?: number;
    /**
     * The highest traded price of the month excluding the current day. The period will run from the 1st of the month - 00:00:00 GMT/UTC to the beginning - 00:00:00 GMT/UTC of the current day of the month. If today is the 1st of the month, this value will be CURRENT_MONTH_OPEN. Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_MONTH_HIGH'?: number;
    /**
     * The lowest traded price of the month excluding the current day. The period will run from the 1st of the month - 00:00:00 GMT/UTC to the beginning - 00:00:00 GMT/UTC of the current day of the month. If today is the 1st of the month, this value will be CURRENT_MONTH_OPEN. Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_MONTH_LOW'?: number;
    /**
     * The price of the closest trade to the 1st day (00:00:00 GMT/UTC) of this month. In a highly liquid market, this would be the last trade that happened on the previous month at (23:59:59 999 GMT/UTC). This will always be supplied and there is no need to do any calculation to get the full monthly value. Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_MONTH_OPEN'?: number;
    /**
     * The sum of all trade quote quantities from the 1st of the month (xxxx:xx:01 00:00:00 GMT/UTC) to the beginning (00:00:00 GMT/UTC) of the current day of the month. If today is the first of the month, this value will be 0. Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_MONTH_QUOTE_VOLUME'?: number;
    /**
     * The sum of all buy trade quote quantities from the 1st of the month (xxxx:xx:01 00:00:00 GMT/UTC) to the beginning (00:00:00 GMT/UTC) of the current day of the month. If today is the first of the month, this value will be 0. Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_MONTH_QUOTE_VOLUME_BUY'?: number;
    /**
     * The sum of all sell trade quote quantities from the 1st of the month (xxxx:xx:01 00:00:00 GMT/UTC) to the beginning (00:00:00 GMT/UTC) of the current day of the month. If today is the first of the month, this value will be 0. Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_MONTH_QUOTE_VOLUME_SELL'?: number;
    /**
     * The sum of all unknown trade quote quantities from the 1st of the month (xxxx:xx:01 00:00:00 GMT/UTC) to the beginning (00:00:00 GMT/UTC) of the current day of the month. If today is the first of the month, this value will be 0. Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_MONTH_QUOTE_VOLUME_UNKNOWN'?: number;
    /**
     * The total number of trades between the 1st of the month (xxxx:xx:01 00:00:00 GMT/UTC) and the beginning (00:00:00 GMT/UTC) of the current day of the month. If today is the 1st of the month, this value will be 0.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_MONTH_TOTAL_TRADES'?: number;
    /**
     * The total number of buy trades between the 1st of the month (xxxx:xx:01 00:00:00 GMT/UTC) and the beginning (00:00:00 GMT/UTC) of the current day of the month. If today is the 1st of the month, this value will be 0.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_MONTH_TOTAL_TRADES_BUY'?: number;
    /**
     * The total number of sell trades between the 1st of the month (xxxx:xx:01 00:00:00 GMT/UTC) and the beginning (00:00:00 GMT/UTC) of the current day of the month. If today is the 1st of the month, this value will be 0.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_MONTH_TOTAL_TRADES_SELL'?: number;
    /**
     * The total number of unknown trades between the 1st of the month (xxxx:xx:01 00:00:00 GMT/UTC) and the beginning (00:00:00 GMT/UTC) of the current day of the month. If today is the 1st of the month, this value will be 0.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_MONTH_TOTAL_TRADES_UNKNOWN'?: number;
    /**
     * The sum of all trade quantities from the 1st of the month (xxxx:xx:01 00:00:00 GMT/UTC) to the beginning (00:00:00 GMT/UTC) of the current day of the month. If today is the first of the month, this value will be 0. Given in the base asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_MONTH_VOLUME'?: number;
    /**
     * The sum of all buy trade quantities from the 1st of the month (xxxx:xx:01 00:00:00 GMT/UTC) to the beginning (00:00:00 GMT/UTC) of the current day of the month. If today is the first of the month, this value will be 0. Given in the base asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_MONTH_VOLUME_BUY'?: number;
    /**
     * The sum of all sell trade quantities from the 1st of the month (xxxx:xx:01 00:00:00 GMT/UTC) to the beginning (00:00:00 GMT/UTC) of the current day of the month. If today is the first of the month, this value will be 0. Given in the base asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_MONTH_VOLUME_SELL'?: number;
    /**
     * The sum of all unknown trade quantities from the 1st of the month (xxxx:xx:01 00:00:00 GMT/UTC) to the beginning (00:00:00 GMT/UTC) of the current day of the month. If today is the first of the month, this value will be 0. Given in the base asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_MONTH_VOLUME_UNKNOWN'?: number;
    /**
     * The highest traded price of the week excluding the current day. The period will run from Monday - 00:00:00 GMT/UTC to the beginning - 00:00:00 GMT/UTC of the current day of the week. If today is Monday, this value will be the same as CURRENT_WEEK_OPEN. Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_WEEK_HIGH'?: number;
    /**
     * The lowest traded price of the week excluding the current day. The period will run from Monday - 00:00:00 GMT/UTC to the beginning - 00:00:00 GMT/UTC of the current day of the week. If today is Monday, this value will be CURRENT_WEEK_LOW. Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_WEEK_LOW'?: number;
    /**
     * The price of the closest trade to Monday (00:00:00 GMT/UTC) of this week. In a highly liquid market, this would be the last trade that happened on the previous Sunday at (23:59:59 999 GMT/UTC). This will always be supplied and there is no need to do any calculation to get the full weekly value. Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_WEEK_OPEN'?: number;
    /**
     * The sum of all trade quote quantities from Monday (00:00:00 GMT/UTC) to the beginning (00:00:00 GMT/UTC) of the current day of the week. If today is Monday, this value will be 0. Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_WEEK_QUOTE_VOLUME'?: number;
    /**
     * The sum of all buy trade quote quantities from Monday (00:00:00 GMT/UTC) to the beginning (00:00:00 GMT/UTC) of the current day of the week. If today is Monday, this value will be 0. Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_WEEK_QUOTE_VOLUME_BUY'?: number;
    /**
     * The sum of all sell trade quote quantities from Monday (00:00:00 GMT/UTC) to the beginning (00:00:00 GMT/UTC) of the current day of the week. If today is Monday, this value will be 0. Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_WEEK_QUOTE_VOLUME_SELL'?: number;
    /**
     * The sum of all unknown trade quote quantities from Monday (00:00:00 GMT/UTC) to the beginning (00:00:00 GMT/UTC) of the current day of the week. If today is Monday, this value will be 0. Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_WEEK_QUOTE_VOLUME_UNKNOWN'?: number;
    /**
     * The total number of trades between Monday (00:00:00 GMT/UTC) and the beginning (00:00:00 GMT/UTC) of the current day of the week. If today is Monday, this value will be 0.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_WEEK_TOTAL_TRADES'?: number;
    /**
     * The total number of buy trades between Monday (00:00:00 GMT/UTC) and the beginning (00:00:00 GMT/UTC) of the current day of the week. If today is Monday, this value will be 0.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_WEEK_TOTAL_TRADES_BUY'?: number;
    /**
     * The total number of sell trades between Monday (00:00:00 GMT/UTC) and the beginning (00:00:00 GMT/UTC) of the current day of the week. If today is Monday, this value will be 0.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_WEEK_TOTAL_TRADES_SELL'?: number;
    /**
     * The total number of unknown trades between Monday (00:00:00 GMT/UTC) and the beginning (00:00:00 GMT/UTC) of the current day of the week. If today is Monday, this value will be 0.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_WEEK_TOTAL_TRADES_UNKNOWN'?: number;
    /**
     * The sum of all trade quantities from Monday (00:00:00 GMT/UTC) to the beginning (00:00:00 GMT/UTC) of the current day of the week. If today is Monday, this value will be 0. Given in the base asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_WEEK_VOLUME'?: number;
    /**
     * The sum of all buy trade quantities from Monday (00:00:00 GMT/UTC) to the beginning (00:00:00 GMT/UTC) of the current day of the week. If today is Monday, this value will be 0. Given in the base asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_WEEK_VOLUME_BUY'?: number;
    /**
     * The sum of all sell trade quantities from Monday (00:00:00 GMT/UTC) to the beginning (00:00:00 GMT/UTC) of the current day of the week. If today is Monday, this value will be 0. Given in the base asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_WEEK_VOLUME_SELL'?: number;
    /**
     * The sum of all unknown trade quantities from Monday (00:00:00 GMT/UTC) to the beginning (00:00:00 GMT/UTC) of the current day of the week. If today is Monday, this value will be 0. Given in the base asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_WEEK_VOLUME_UNKNOWN'?: number;
    /**
     * The highest traded price of the year excluding the current day. The period runs from the 1st of January - 00:00:00 GMT/UTC to the beginning - 00:00:00 GMT/UTC of the current day of the year. If today is the 1st of January, this value will be CURRENT_YEAR_OPEN. Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_YEAR_HIGH'?: number;
    /**
     * The lowest traded price of the year excluding the current day. The period runs from the 1st of January - 00:00:00 GMT/UTC to the beginning - 00:00:00 GMT/UTC of the current day of the year. If today is the 1st of January, this value will be CURRENT_YEAR_OPEN. Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_YEAR_LOW'?: number;
    /**
     * The price of the closest trade to the 1st of January (00:00:00 GMT/UTC) of this year. In a highly liquid market, this would be the last trade that happened on on the 31st of December of the previous year (23:59:59 999 GMT/UTC). This will always be supplied and there is no need to do any calculation to get the full yearly value. Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_YEAR_OPEN'?: number;
    /**
     * The sum of all trade quote quantities from the 1st of January (xxxx:01:01 00:00:00 GMT/UTC) to the beginning (00:00:00 GMT/UTC) of the current day of the year. If today is the 1st of January, this value will be 0. Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_YEAR_QUOTE_VOLUME'?: number;
    /**
     * The sum of all buy trade quote quantities from the 1st of January (xxxx:01:01 00:00:00 GMT/UTC) to the beginning (00:00:00 GMT/UTC) of the current day of the year. If today is the 1st of January, this value will be 0. Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_YEAR_QUOTE_VOLUME_BUY'?: number;
    /**
     * The sum of all sell trade quote quantities from the 1st of January (xxxx:01:01 00:00:00 GMT/UTC) to the beginning (00:00:00 GMT/UTC) of the current day of the year. If today is the 1st of January, this value will be 0. Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_YEAR_QUOTE_VOLUME_SELL'?: number;
    /**
     * The sum of all unknown trade quote quantities from the 1st of January (xxxx:01:01 00:00:00 GMT/UTC) to the beginning (00:00:00 GMT/UTC) of the current day of the year. If today is the 1st of January, this value will be 0. Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_YEAR_QUOTE_VOLUME_UNKNOWN'?: number;
    /**
     * The total number of trades between the 1st of January (xxxx:01:01 00:00:00 GMT/UTC) and the beginning (00:00:00 GMT/UTC) of the current day of the year. If today is the 1st of January, this value will be 0.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_YEAR_TOTAL_TRADES'?: number;
    /**
     * The total number of buy trades between the 1st of January (xxxx:01:01 00:00:00 GMT/UTC) and the beginning (00:00:00 GMT/UTC) of the current day of the year. If today is the 1st of January, this value will be 0.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_YEAR_TOTAL_TRADES_BUY'?: number;
    /**
     * The total number of sell trades between the 1st of January (xxxx:01:01 00:00:00 GMT/UTC) and the beginning (00:00:00 GMT/UTC) of the current day of the year. If today is the 1st of January, this value will be 0.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_YEAR_TOTAL_TRADES_SELL'?: number;
    /**
     * The total number of unknown trades between the 1st of January (xxxx:01:01 00:00:00 GMT/UTC) and the beginning (00:00:00 GMT/UTC) of the current day of the year. If today is the 1st of January, this value will be 0.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_YEAR_TOTAL_TRADES_UNKNOWN'?: number;
    /**
     * The sum of all trade quantities from the 1st of January (xxxx:01:01 00:00:00 GMT/UTC) to the beginning (00:00:00 GMT/UTC) of the current day of the year. If today is the 1st of January, this value will be 0. Given in the base asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_YEAR_VOLUME'?: number;
    /**
     * The sum of all buy trade quantities from the 1st of January (xxxx:01:01 00:00:00 GMT/UTC) to the beginning (00:00:00 GMT/UTC) of the current day of the year. If today is the 1st of January, this value will be 0. Given in the base asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_YEAR_VOLUME_BUY'?: number;
    /**
     * The sum of all sell trade quantities from the 1st of January (xxxx:01:01 00:00:00 GMT/UTC) to the beginning (00:00:00 GMT/UTC) of the current day of the year. If today is the 1st of January, this value will be 0. Given in the base asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_YEAR_VOLUME_SELL'?: number;
    /**
     * The sum of all unknown trade quantities from the 1st of January (xxxx:01:01 00:00:00 GMT/UTC) to the beginning (00:00:00 GMT/UTC) of the current day of the year. If today is the 1st of January, this value will be 0. Given in the base asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'CURRENT_YEAR_VOLUME_UNKNOWN'?: number;
    /**
     * The unmapped instrument ID
     * @type {string}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'INSTRUMENT'?: string;
    /**
     * The CCSEQ of the latest trade.
     * @type {string}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'LAST_PROCESSED_TRADE_CCSEQ'?: string;
    /**
     * The price in the quote asset of the last trade processed, as reported by the market / exchange.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'LAST_PROCESSED_TRADE_PRICE'?: number;
    /**
     * The quantity of the last processed trade in the from symbol (base / coin).
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'LAST_PROCESSED_TRADE_QUANTITY'?: number;
    /**
     * The  volume of the last processed trade in the to asset / quote.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'LAST_PROCESSED_TRADE_QUOTE_QUANTITY'?: number;
    /**
     * The side of the last processed trade.
     * @type {string}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'LAST_PROCESSED_TRADE_SIDE'?: string;
    /**
     * The timestamp in seconds that the last trade was processed, as reported by the market / exchange. If the market / exchange does not provide this information, the timestamp that the trade was received will be returned.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'LAST_PROCESSED_TRADE_TS'?: number;
    /**
     * The CCSEQ of the latest trade.
     * @type {string}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'LAST_TRADE_CCSEQ'?: string;
    /**
     * The ID of the latest trade.
     * @type {string}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'LAST_TRADE_ID'?: string;
    /**
     * The quantity of the latest trade in the from symbol (base / coin).
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'LAST_TRADE_QUANTITY'?: number;
    /**
     * The volume of the latest trade in the to asset / quote.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'LAST_TRADE_QUOTE_QUANTITY'?: number;
    /**
     * The side of the latest trade.
     * @type {string}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'LAST_TRADE_SIDE'?: string;
    /**
     * The timestamp of the first trade ever recorded for the instrument
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'LIFETIME_FIRST_TRADE_TS'?: number;
    /**
     * The price of the highest trade ever executed for this instrument. Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'LIFETIME_HIGH'?: number;
    /**
     * The the timestamp of the highest trade ever executed for this instrument. Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'LIFETIME_HIGH_TS'?: number;
    /**
     * The price of the lowest trade ever executed for this instrument. Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'LIFETIME_LOW'?: number;
    /**
     * The timestamp of the lowest trade ever executed for this instrument. Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'LIFETIME_LOW_TS'?: number;
    /**
     * The price of the first trade of the instrument. Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'LIFETIME_OPEN'?: number;
    /**
     * The sum of all trade quote quantities of all the trades of this instrument. Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'LIFETIME_QUOTE_VOLUME'?: number;
    /**
     * The sum of all buy trade quote quantities of all the trades of this instrument. Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'LIFETIME_QUOTE_VOLUME_BUY'?: number;
    /**
     * The sum of all sell trade quote quantities of all the trades of this instrument. Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'LIFETIME_QUOTE_VOLUME_SELL'?: number;
    /**
     * The sum of all unknown trade quote quantities of all the trades of this instrument. Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'LIFETIME_QUOTE_VOLUME_UNKNOWN'?: number;
    /**
     * The total number of all trades that have ever been executed for this instrument.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'LIFETIME_TOTAL_TRADES'?: number;
    /**
     * The total number of all buy trades that have ever been executed for this instrument.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'LIFETIME_TOTAL_TRADES_BUY'?: number;
    /**
     * The total number of all sell trades that have ever been executed for this instrument.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'LIFETIME_TOTAL_TRADES_SELL'?: number;
    /**
     * The total number of all unknown trades that have ever been executed for this instrument.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'LIFETIME_TOTAL_TRADES_UNKNOWN'?: number;
    /**
     * The sum of all trade quantities of all the trades of this instrument. Given in the base asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'LIFETIME_VOLUME'?: number;
    /**
     * The sum of all buy trade quantities of all the trades of this instrument. Given in the base asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'LIFETIME_VOLUME_BUY'?: number;
    /**
     * The sum of all sell trade quantities of all the trades of this instrument. Given in the base asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'LIFETIME_VOLUME_SELL'?: number;
    /**
     * The sum of all unknown trade quantities of all the trades of this instrument. Given in the base asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'LIFETIME_VOLUME_UNKNOWN'?: number;
    /**
     * The mapped instrument ID, derived from our mapping rules. This takes the form: \"BASE-QUOTE\" (e.g. BTC-USD). Only available on instruments that have been mapped.
     * @type {string}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MAPPED_INSTRUMENT'?: string;
    /**
     * The market / exchange under consideration (e.g. coinbase, kraken, etc).
     * @type {string}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MARKET'?: string;
    /**
     * The  highest traded price of the period. Here, the period runs from 180 days ago up to the beginning of the current day (179 days in total). Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_180_DAY_HIGH'?: number;
    /**
     * The lowest traded price of the period. Here, the period runs from 180 days ago up to the beginning of the current day (179 days in total). Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_180_DAY_LOW'?: number;
    /**
     * The price of the closest trade to the period start date (179 days + current day - 00:00:00 GMT/UTC to now). This will always be supplied and there is no need to do any calculation to get the full 180 day value. Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_180_DAY_OPEN'?: number;
    /**
     * The sum of all trade quote quantities from 180 days ago up to the beginning of the current day (179 days in total). Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_180_DAY_QUOTE_VOLUME'?: number;
    /**
     * The sum of all buy trade quote quantities from 180 days ago up to the beginning of the current day (179 days in total). Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_180_DAY_QUOTE_VOLUME_BUY'?: number;
    /**
     * The sum of all sell trade quote quantities from 180 days ago up to the beginning of the current day (179 days in total). Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_180_DAY_QUOTE_VOLUME_SELL'?: number;
    /**
     * The sum of all unknown trade quote quantities from 180 days ago up to the beginning of the current day (179 days in total). Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_180_DAY_QUOTE_VOLUME_UNKNOWN'?: number;
    /**
     * The total number of trades that have occurred in the period from 180 days ago to the beginning (00:00:00 GMT/UTC) of the current day (179 days in total).
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_180_DAY_TOTAL_TRADES'?: number;
    /**
     * The total number of buy trades that have occurred in the period from 180 days ago to the beginning (00:00:00 GMT/UTC) of the current day (179 days in total).
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_180_DAY_TOTAL_TRADES_BUY'?: number;
    /**
     * The total number of sell trades that have occurred in the period from 180 days ago to the beginning (00:00:00 GMT/UTC) of the current day (179 days in total).
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_180_DAY_TOTAL_TRADES_SELL'?: number;
    /**
     * The total number of unknown trades that have occurred in the period from 180 days ago to the beginning (00:00:00 GMT/UTC) of the current day (179 days in total).
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_180_DAY_TOTAL_TRADES_UNKNOWN'?: number;
    /**
     * The sum of all trade quantities from 180 days ago up to the beginning of the current day (179 days in total). Given in the base asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_180_DAY_VOLUME'?: number;
    /**
     * The sum of all trade quantities from 180 days ago up to the beginning of the current day (179 days in total). Given in the base asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_180_DAY_VOLUME_BUY'?: number;
    /**
     * The sum of all sell trade quantities from 180 days ago up to the beginning of the current day (179 days in total). Given in the base asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_180_DAY_VOLUME_SELL'?: number;
    /**
     * The sum of all unknown trade quantities from 180 days ago up to the beginning of the current day (179 days in total). Given in the base asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_180_DAY_VOLUME_UNKNOWN'?: number;
    /**
     * The highest traded price of the period. Here, the period runs from 24 hours ago up to the beginning of the current hour (23 hours in total). Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_24_HOUR_HIGH'?: number;
    /**
     * The lowest traded price of the period. Here, the period runs from 24 hours ago up to the beginning of the current hour (23 hours in total). Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_24_HOUR_LOW'?: number;
    /**
     * The price of the closest trade to the period start date (23 hours + current hour ago). This will always be supplied and there is no need to do any calculation to get the full 24 hour value. Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_24_HOUR_OPEN'?: number;
    /**
     * The sum of all trade quote quantities from 24 hours ago up to the beginning of the current hour (23 hours in total). Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_24_HOUR_QUOTE_VOLUME'?: number;
    /**
     * The sum of all buy trade quote quantities from 24 hours ago up to the beginning of the current hour (23 hours in total). Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_24_HOUR_QUOTE_VOLUME_BUY'?: number;
    /**
     * The sum of all sell trade quote quantities from 24 hours ago up to the beginning of the current hour (23 hours in total). Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_24_HOUR_QUOTE_VOLUME_SELL'?: number;
    /**
     * The sum of all unknown trade quote quantities from 24 hours ago up to the beginning of the current hour (23 hours in total). Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_24_HOUR_QUOTE_VOLUME_UNKNOWN'?: number;
    /**
     * The total number of trades that have occurred in the period running from 24 hours ago to the beginning (xx:00:00) of the current hour (23 hours in total).
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_24_HOUR_TOTAL_TRADES'?: number;
    /**
     * The total number of buy trades that have occurred in the period running from 24 hours ago to the beginning (xx:00:00) of the current hour (23 hours in total).
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_24_HOUR_TOTAL_TRADES_BUY'?: number;
    /**
     * The total number of sell trades that have occurred in the period running from 24 hours ago to the beginning (xx:00:00) of the current hour (23 hours in total).
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_24_HOUR_TOTAL_TRADES_SELL'?: number;
    /**
     * The total number of unknown trades that have occurred in the period running from 24 hours ago to the beginning (xx:00:00) of the current hour (23 hours in total).
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_24_HOUR_TOTAL_TRADES_UNKNOWN'?: number;
    /**
     * The sum of all trade quantities from 24 hours ago up to the beginning of the current hour (23 hours in total). Given in the base asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_24_HOUR_VOLUME'?: number;
    /**
     * The sum of all buy trade quantities from 24 hours ago up to the beginning of the current hour (23 hours in total). Given in the base asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_24_HOUR_VOLUME_BUY'?: number;
    /**
     * The sum of all sell trade quantities from 24 hours ago up to the beginning of the current hour (23 hours in total). Given in the base asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_24_HOUR_VOLUME_SELL'?: number;
    /**
     * The sum of all unknown trade quantities from 24 hours ago up to the beginning of the current hour (23 hours in total). Given in the base asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_24_HOUR_VOLUME_UNKNOWN'?: number;
    /**
     * The highest traded price of the period. Here, the period runs from 30 days ago up to the beginning of the current day (29 days in total). Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_30_DAY_HIGH'?: number;
    /**
     * The lowest traded price of the period. Here, the period runs from 30 days ago up to the beginning of the current day (29 days in total). Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_30_DAY_LOW'?: number;
    /**
     * The price of the closest trade to the period start date (29 days + current day - 00:00:00 GMT/UTC to now).  This will always be supplied and there is no need to do any calculation to get the full 30 day value. Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_30_DAY_OPEN'?: number;
    /**
     * The sum of all trade quote quantities from 30 days ago up to the beginning of the current day (29 days in total). Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_30_DAY_QUOTE_VOLUME'?: number;
    /**
     * The sum of all buy trade quote quantities from 30 days ago up to the beginning of the current day (29 days in total). Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_30_DAY_QUOTE_VOLUME_BUY'?: number;
    /**
     * The sum of all sell trade quote quantities from 30 days ago up to the beginning of the current day (29 days in total). Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_30_DAY_QUOTE_VOLUME_SELL'?: number;
    /**
     * The sum of all unknown trade quote quantities from 30 days ago up to the beginning of the current day (29 days in total). Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_30_DAY_QUOTE_VOLUME_UNKNOWN'?: number;
    /**
     * The total number of trades that have occurred in the period running from 30 days ago to the beginning (00:00:00 GMT/UTC) of the current day (29 days in total).
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_30_DAY_TOTAL_TRADES'?: number;
    /**
     * The total number of buy trades that have occurred in the period running from 30 days ago to the beginning (00:00:00 GMT/UTC) of the current day (29 days in total).
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_30_DAY_TOTAL_TRADES_BUY'?: number;
    /**
     * The total number of sell trades that have occurred in the period running from 30 days ago to the beginning (00:00:00 GMT/UTC) of the current day (29 days in total).
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_30_DAY_TOTAL_TRADES_SELL'?: number;
    /**
     * The total number of unknown trades that have occurred in the period running from 30 days ago to the beginning (00:00:00 GMT/UTC) of the current day (29 days in total).
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_30_DAY_TOTAL_TRADES_UNKNOWN'?: number;
    /**
     * The sum of all trade quantities from 30 days ago up to the beginning of the current day (29 days in total). Given in the base asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_30_DAY_VOLUME'?: number;
    /**
     * The sum of all buy trade quantities from 30 days ago up to the beginning of the current day (29 days in total). Given in the base asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_30_DAY_VOLUME_BUY'?: number;
    /**
     * The sum of all sell trade quantities from 30 days ago up to the beginning of the current day (29 days in total). Given in the base asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_30_DAY_VOLUME_SELL'?: number;
    /**
     * The sum of all unknown trade quantities from 30 days ago up to the beginning of the current day (29 days in total). Given in the base asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_30_DAY_VOLUME_UNKNOWN'?: number;
    /**
     * The highest price of the period. Here, the period runs from 365 days ago up to the beginning of the current day (364 days in total). Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_365_DAY_HIGH'?: number;
    /**
     * The lowest traded price of the period. Here, the period runs from 365 days ago up to the beginning of the current day (364 days in total). Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_365_DAY_LOW'?: number;
    /**
     * The price of the closest trade to the period start date (364 days + current day - 00:00:00 GMT/UTC to now).  This will always be supplied and there is no need to do any calculation to get the full 365 day value. Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_365_DAY_OPEN'?: number;
    /**
     * The sum of all trade quote quantities from 365 days ago up to the beginning of the current day (364 days in total). Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_365_DAY_QUOTE_VOLUME'?: number;
    /**
     * The sum of all buy trade quote quantities from 365 days ago up to the beginning of the current day (364 days in total). Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_365_DAY_QUOTE_VOLUME_BUY'?: number;
    /**
     * The sum of all sell trade quote quantities from 365 days ago up to the beginning of the current day (364 days in total). Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_365_DAY_QUOTE_VOLUME_SELL'?: number;
    /**
     * The sum of all unknown trade quote quantities from 365 days ago up to the beginning of the current day (364 days in total). Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_365_DAY_QUOTE_VOLUME_UNKNOWN'?: number;
    /**
     * The total number of trades that have occurred during the period running from 365 days ago to the beginning (00:00:00 GMT/UTC) of the current day (364 days in total).
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_365_DAY_TOTAL_TRADES'?: number;
    /**
     * The total number of buy trades that have occurred during the period running from 365 days ago to the beginning (00:00:00 GMT/UTC) of the current day (364 days in total).
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_365_DAY_TOTAL_TRADES_BUY'?: number;
    /**
     * The total number of sell trades that have occurred during the period running from 365 days ago to the beginning (00:00:00 GMT/UTC) of the current day (364 days in total).
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_365_DAY_TOTAL_TRADES_SELL'?: number;
    /**
     * The total number of unknown trades that have occurred during the period running from 365 days ago to the beginning (00:00:00 GMT/UTC) of the current day (364 days in total).
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_365_DAY_TOTAL_TRADES_UNKNOWN'?: number;
    /**
     * The sum of all trade quantities from 365 days ago up to the beginning of the current day (364 days in total). Given in the base asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_365_DAY_VOLUME'?: number;
    /**
     * The sum of all trade quantities from 365 days ago up to the beginning of the current day (364 days in total). Given in the base asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_365_DAY_VOLUME_BUY'?: number;
    /**
     * The sum of all sell trade quantities from 365 days ago up to the beginning of the current day (364 days in total). Given in the base asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_365_DAY_VOLUME_SELL'?: number;
    /**
     * The sum of all unknown trade quantities from 365 days ago up to the beginning of the current day (364 days in total). Given in the base asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_365_DAY_VOLUME_UNKNOWN'?: number;
    /**
     * The highest traded price of the period. Here, the period runs from 7 days ago up to the beginning of the current day (6 days in total). Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_7_DAY_HIGH'?: number;
    /**
     * The lowest traded price of the period. Here, the period runs from 7 days ago up to the beginning of the current day (6 days in total). Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_7_DAY_LOW'?: number;
    /**
     * The price of the closest trade to the period start date (6 days + current day - 00:00:00 GMT/UTC to now). This will always be supplied and there is no need to do any calculation to get the full 7 day value. Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_7_DAY_OPEN'?: number;
    /**
     * The sum of all trade quote quantities from 7 days ago up to the beginning of the current day (6 days in total). Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_7_DAY_QUOTE_VOLUME'?: number;
    /**
     * The sum of all buy trade quote quantities from 7 days ago up to the beginning of the current day (6 days in total). Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_7_DAY_QUOTE_VOLUME_BUY'?: number;
    /**
     * The sum of all sell trade quote quantities from 7 days ago up to the beginning of the current day (6 days in total). Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_7_DAY_QUOTE_VOLUME_SELL'?: number;
    /**
     * The sum of all unknown trade quote quantities from 7 days ago up to the beginning of the current day (6 days in total). Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_7_DAY_QUOTE_VOLUME_UNKNOWN'?: number;
    /**
     * The total number of trades that have occurred in the period running from 7 days ago to the beginning (00:00:00 GMT/UTC) of the current day (6 days in total).
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_7_DAY_TOTAL_TRADES'?: number;
    /**
     * The total number of buy trades that have occurred in the period running from 7 days ago to the beginning (00:00:00 GMT/UTC) of the current day (6 days in total).
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_7_DAY_TOTAL_TRADES_BUY'?: number;
    /**
     * The total number of sell trades that have occurred in the period running from 7 days ago to the beginning (00:00:00 GMT/UTC) of the current day (6 days in total).
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_7_DAY_TOTAL_TRADES_SELL'?: number;
    /**
     * The total number of unknown trades that have occurred in the period running from 7 days ago to the beginning (00:00:00 GMT/UTC) of the current day (6 days in total).
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_7_DAY_TOTAL_TRADES_UNKNOWN'?: number;
    /**
     * The sum of all trade quantities from 7 days ago up to the beginning of the current day (6 days in total). Given in the base asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_7_DAY_VOLUME'?: number;
    /**
     * The sum of all buy trade quantities from 7 days ago up to the beginning of the current day (6 days in total). Given in the base asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_7_DAY_VOLUME_BUY'?: number;
    /**
     * The sum of all sell trade quantities from 7 days ago up to the beginning of the current day (6 days in total). Given in the base asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_7_DAY_VOLUME_SELL'?: number;
    /**
     * The sum of all unknown trade quantities from 7 days ago up to the beginning of the current day (6 days in total). Given in the base asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_7_DAY_VOLUME_UNKNOWN'?: number;
    /**
     * The highest value between the MOVING_90_DAY_OPEN and the highest traded price of the period. Here, the period runs from 90 days ago up to the beginning of the current day (89 days in total). Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_90_DAY_HIGH'?: number;
    /**
     * The lowest traded price of the period. Here, the period runs from 90 days ago up to the beginning of the current day (89 days in total). Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_90_DAY_LOW'?: number;
    /**
     * The price of the closest trade to the period start date (89 days + current day - 00:00:00 GMT/UTC to now).  This will always be supplied and there is no need to do any calculation to get the full 90 day value. Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_90_DAY_OPEN'?: number;
    /**
     * The sum of all trade quote quantities from 90 days ago up to the beginning of the current day (89 days in total). Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_90_DAY_QUOTE_VOLUME'?: number;
    /**
     * The sum of all buy trade quote quantities from 90 days ago up to the beginning of the current day (89 days in total). Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_90_DAY_QUOTE_VOLUME_BUY'?: number;
    /**
     * The sum of all sell trade quote quantities from 90 days ago up to the beginning of the current day (89 days in total). Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_90_DAY_QUOTE_VOLUME_SELL'?: number;
    /**
     * The sum of all unknown trade quote quantities from 90 days ago up to the beginning of the current day (89 days in total). Given in the quote asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_90_DAY_QUOTE_VOLUME_UNKNOWN'?: number;
    /**
     * The total number of trades that have occurred in the period running from 90 days ago to the beginning (00:00:00 GMT/UTC) of the current day (89 days in total).
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_90_DAY_TOTAL_TRADES'?: number;
    /**
     * The total number of buy trades that have occurred in the period running from 90 days ago to the beginning (00:00:00 GMT/UTC) of the current day (89 days in total).
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_90_DAY_TOTAL_TRADES_BUY'?: number;
    /**
     * The total number of sell trades that have occurred in the period running from 90 days ago to the beginning (00:00:00 GMT/UTC) of the current day (89 days in total).
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_90_DAY_TOTAL_TRADES_SELL'?: number;
    /**
     * The total number of unknown trades that have occurred in the period running from 90 days ago to the beginning (00:00:00 GMT/UTC) of the current day (89 days in total).
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_90_DAY_TOTAL_TRADES_UNKNOWN'?: number;
    /**
     * The sum of all trade quantities from 90 days ago up to the beginning of the current day (89 days in total). Given in the base asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_90_DAY_VOLUME'?: number;
    /**
     * The sum of all trade quantities from 90 days ago up to the beginning of the current day (89 days in total). Given in the base asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_90_DAY_VOLUME_BUY'?: number;
    /**
     * The sum of all sell trade quantities from 90 days ago up to the beginning of the current day (89 days in total). Given in the base asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_90_DAY_VOLUME_SELL'?: number;
    /**
     * The sum of all unknown trade quantities from 90 days ago up to the beginning of the current day (89 days in total). Given in the base asset.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'MOVING_90_DAY_VOLUME_UNKNOWN'?: number;
    /**
     * The price in the to asset (quote / number symbol / coin) of the latest trade. I.e. for a BTC-USD trade, how much was paid for one BTC in USD).
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'PRICE'?: number;
    /**
     * The flag indicating whether the price has increased, decreased, or not changed
     * @type {string}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'PRICE_FLAG'?: string;
    /**
     * The timestamp in seconds as reported by the market / exchange. If the market /exchange does not provide this information, the received timestamp will be returned.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'PRICE_LAST_UPDATE_TS'?: number;
    /**
     * The mapped to asset (quote / counter symbol / coin), e.g. USD. Only available on instruments that have been mapped.
     * @type {string}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'QUOTE'?: string;
    /**
     * The timestamp in seconds of the last time the top ask was updated, as reported by the market / exchange. If the market / exchange does not provide this information, the received timestamp will be returned.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'TOP_ASK_LAST_UPDATE_TS'?: number;
    /**
     * The price of the top ask in the to asset (quote / numberer symbol / coin). For a BTC-USD order book, this will be the best price someone is willing to sell some BTC in USD, as quoted for 1 full BTC.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'TOP_ASK_PRICE'?: number;
    /**
     * The quantity of the top ask in the from asset (base / coin). For a BTC-USD order book, this will be the amount of BTC a person is willing to sell at the best price.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'TOP_ASK_QUANTITY'?: number;
    /**
     * The timestamp in seconds of the last time the top bid was updated, as reported by the market / exchange. If the market / exchange does not provide this information, the received timestamp will be returned.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'TOP_BID_LAST_UPDATE_TS'?: number;
    /**
     * The price of the top bid in the to asset (quote / numberer symbol / coin). For a BTC-USD order book, this will be the highest price a person is willing to pay for some BTC in USD, as quoted for 1 full BTC.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'TOP_BID_PRICE'?: number;
    /**
     * The quantity of the top bid in the from asset (base / coin). For a BTC-USD order book , this will be the amount of BTC someone is willing to buy at the best price.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'TOP_BID_QUANTITY'?: number;
    /**
     * The type of the message.
     * @type {string}
     * @memberof SPOTINSTRUMENTMARKETDATA
     */
    'TYPE'?: string;
}
/**
 * 
 * @export
 * @interface SPOTINSTRUMENTMARKETDATARESPONSE
 */
export interface SPOTINSTRUMENTMARKETDATARESPONSE {
    /**
     * 
     * @type {{ [key: string]: SPOTINSTRUMENTMARKETDATA; }}
     * @memberof SPOTINSTRUMENTMARKETDATARESPONSE
     */
    'Data'?: { [key: string]: SPOTINSTRUMENTMARKETDATA; };
    /**
     * 
     * @type {SPOTINSTRUMENTMARKETDATARESPONSEErr}
     * @memberof SPOTINSTRUMENTMARKETDATARESPONSE
     */
    'Err'?: SPOTINSTRUMENTMARKETDATARESPONSEErr;
}
/**
 * 
 * @export
 * @interface SPOTINSTRUMENTMARKETDATARESPONSEErr
 */
export interface SPOTINSTRUMENTMARKETDATARESPONSEErr {
    /**
     * A message describing the error
     * @type {string}
     * @memberof SPOTINSTRUMENTMARKETDATARESPONSEErr
     */
    'message'?: string;
    /**
     * 
     * @type {SPOTINSTRUMENTMARKETDATARESPONSEErrOtherInfo}
     * @memberof SPOTINSTRUMENTMARKETDATARESPONSEErr
     */
    'other_info'?: SPOTINSTRUMENTMARKETDATARESPONSEErrOtherInfo;
    /**
     * A public facing error type. If you want to treat a specific error use the type.
     * @type {number}
     * @memberof SPOTINSTRUMENTMARKETDATARESPONSEErr
     */
    'type'?: number;
}
/**
 * 
 * @export
 * @interface SPOTINSTRUMENTMARKETDATARESPONSEErrOtherInfo
 */
export interface SPOTINSTRUMENTMARKETDATARESPONSEErrOtherInfo {
    /**
     * The parameter that is resposible for the error
     * @type {string}
     * @memberof SPOTINSTRUMENTMARKETDATARESPONSEErrOtherInfo
     */
    'param'?: string;
    /**
     * The values resposible for the error
     * @type {Array<string>}
     * @memberof SPOTINSTRUMENTMARKETDATARESPONSEErrOtherInfo
     */
    'values'?: Array<string>;
}
/**
 * 
 * @export
 * @interface SPOTINSTRUMENTMETADATA
 */
export interface SPOTINSTRUMENTMETADATA {
    /**
     * This is the first time instrument was seen on instrumentListSourceType BLOB.
     * @type {number}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'FIRST_SEEN_ON_BLOB_TS'?: number;
    /**
     * This is the first time instrument was seen on instrumentListSourceType FIX.
     * @type {number}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'FIRST_SEEN_ON_FIX_TS'?: number;
    /**
     * This is the first time instrument was seen on instrumentListSourceType HARDCODED.
     * @type {number}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'FIRST_SEEN_ON_HARDCODED_TS'?: number;
    /**
     * This is the first time instrument was seen on instrumentListSourceType INDEX_COMPOSITION.
     * @type {number}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'FIRST_SEEN_ON_INDEX_COMPOSITION_TS'?: number;
    /**
     * This is the first time instrument was seen on instrumentListSourceType NSQ.
     * @type {number}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'FIRST_SEEN_ON_NSQ_TS'?: number;
    /**
     * This is the first time instrument was seen on instrumentListSourceType POLLING.
     * @type {number}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'FIRST_SEEN_ON_POLLING_TS'?: number;
    /**
     * This is the first time instrument was seen on instrumentListSourceType STREAMING.
     * @type {number}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'FIRST_SEEN_ON_STREAMING_TS'?: number;
    /**
     * This is the first TRADE_SPOT that we have seen on the specific source type in internal format.
     * @type {object}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'FIRST_TRADE_SPOT_FROM_BACKFILL'?: object;
    /**
     * This is the first TRADE_SPOT that we have seen on the specific source type in external format.
     * @type {object}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'FIRST_TRADE_SPOT_FROM_BACKFILL_EXTERNAL'?: object;
    /**
     * This is the first TRADE_SPOT that we have seen on the specific source type in internal format.
     * @type {object}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'FIRST_TRADE_SPOT_FROM_BLOB'?: object;
    /**
     * This is the first TRADE_SPOT that we have seen on the specific source type in external format.
     * @type {object}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'FIRST_TRADE_SPOT_FROM_BLOB_EXTERNAL'?: object;
    /**
     * This is the first TRADE_SPOT that we have seen on the specific source type in internal format.
     * @type {object}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'FIRST_TRADE_SPOT_FROM_CALCULATED'?: object;
    /**
     * This is the first TRADE_SPOT that we have seen on the specific source type in external format.
     * @type {object}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'FIRST_TRADE_SPOT_FROM_CALCULATED_EXTERNAL'?: object;
    /**
     * This is the first TRADE_SPOT that we have seen on the specific source type in internal format.
     * @type {object}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'FIRST_TRADE_SPOT_FROM_FIX'?: object;
    /**
     * This is the first TRADE_SPOT that we have seen on the specific source type in external format.
     * @type {object}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'FIRST_TRADE_SPOT_FROM_FIX_EXTERNAL'?: object;
    /**
     * This is the first TRADE_SPOT that we have seen on the specific source type in internal format.
     * @type {object}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'FIRST_TRADE_SPOT_FROM_GO'?: object;
    /**
     * This is the first TRADE_SPOT that we have seen on the specific source type in external format.
     * @type {object}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'FIRST_TRADE_SPOT_FROM_GO_EXTERNAL'?: object;
    /**
     * This is the first TRADE_SPOT that we have seen on the specific source type in internal format.
     * @type {object}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'FIRST_TRADE_SPOT_FROM_POLLING'?: object;
    /**
     * This is the first TRADE_SPOT that we have seen on the specific source type in external format.
     * @type {object}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'FIRST_TRADE_SPOT_FROM_POLLING_EXTERNAL'?: object;
    /**
     * This is the first TRADE_SPOT that we have seen on the specific source type in internal format.
     * @type {object}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'FIRST_TRADE_SPOT_FROM_STREAMING'?: object;
    /**
     * This is the first TRADE_SPOT that we have seen on the specific source type in external format.
     * @type {object}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'FIRST_TRADE_SPOT_FROM_STREAMING_EXTERNAL'?: object;
    /**
     * The migration destination vm hostname.
     * @type {string}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'HOST_MIGRATION_DESTINATION'?: string;
    /**
     * The migration source vm hostname.
     * @type {string}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'HOST_MIGRATION_SOURCE'?: string;
    /**
     * The migration status of the symbol, we only poll / stream / connect empty or SETTLED
     * @type {string}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'HOST_MIGRATION_STATUS'?: string;
    /**
     * The instrument ID as it is on the exchange with small modifications - we do not allow the following characters inside isntrument ids: ,/&?
     * @type {string}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'INSTRUMENT'?: string;
    /**
     * The full data we get from the polling endpoint for this specific instrument. This is a JSON stringified object with different properties per exchange.
     * @type {string}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'INSTRUMENT_EXTERNAL_DATA'?: string;
    /**
     * The current mapping information for this instrument
     * @type {object}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'INSTRUMENT_MAPPING'?: object;
    /**
     * Historical mapping information for this instrument
     * @type {Array<string>}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'INSTRUMENT_MAPPING_HISTORY'?: Array<string>;
    /**
     * Where do we get the instrument id / INSTRUMENT_{messageName}_REST_URI / INSTRUMENT_{messageName}_STREAMING_SUBSCRIPTION etc from.
     * @type {string}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'INSTRUMENT_SOURCE_BACKFILL'?: string;
    /**
     * Where do we get the instrument id / INSTRUMENT_{messageName}_REST_URI / INSTRUMENT_{messageName}_STREAMING_SUBSCRIPTION etc from.
     * @type {string}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'INSTRUMENT_SOURCE_BLOB'?: string;
    /**
     * Where do we get the instrument id / INSTRUMENT_{messageName}_REST_URI / INSTRUMENT_{messageName}_STREAMING_SUBSCRIPTION etc from.
     * @type {string}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'INSTRUMENT_SOURCE_CALCULATED'?: string;
    /**
     * Where do we get the instrument id / INSTRUMENT_{messageName}_REST_URI / INSTRUMENT_{messageName}_STREAMING_SUBSCRIPTION etc from.
     * @type {string}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'INSTRUMENT_SOURCE_FIX'?: string;
    /**
     * Where do we get the instrument id / INSTRUMENT_{messageName}_REST_URI / INSTRUMENT_{messageName}_STREAMING_SUBSCRIPTION etc from.
     * @type {string}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'INSTRUMENT_SOURCE_GO'?: string;
    /**
     * Where do we get the instrument id / INSTRUMENT_{messageName}_REST_URI / INSTRUMENT_{messageName}_STREAMING_SUBSCRIPTION etc from.
     * @type {string}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'INSTRUMENT_SOURCE_POLLING'?: string;
    /**
     * Where do we get the instrument id / INSTRUMENT_{messageName}_REST_URI / INSTRUMENT_{messageName}_STREAMING_SUBSCRIPTION etc from.
     * @type {string}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'INSTRUMENT_SOURCE_STREAMING'?: string;
    /**
     * The status of the symbol, we only poll / stream / connect to the ACTIVE ones, for the RETIRED / IGNORED / EXPIRED  one we no longer query for data.
     * @type {string}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'INSTRUMENT_STATUS'?: string;
    /**
     * The last proxied REST request we sent to the proxy swarm to get TRADE_SPOT for the instrument.
     * @type {object}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'INSTRUMENT_TRADE_SPOT_FROM_BACKFILL_LAST_PROXIED_REST_REQUEST'?: object;
    /**
     * The last time we sent a request to the proxy swarm to get TRADE_SPOT for the instrument.
     * @type {number}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'INSTRUMENT_TRADE_SPOT_FROM_BACKFILL_REST_URI_LAST_REQUEST_TS'?: number;
    /**
     * The last time we received a request from the proxy swarm with TRADE_SPOT for this instrument.
     * @type {number}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'INSTRUMENT_TRADE_SPOT_FROM_BACKFILL_REST_URI_LAST_RESPONSE_TS'?: number;
    /**
     * The next time we expect to make a request for TRADE_SPOT on this instrument.
     * @type {number}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'INSTRUMENT_TRADE_SPOT_FROM_BACKFILL_REST_URI_NEXT_REQUEST_TS'?: number;
    /**
     * The last proxied REST request we sent to the proxy swarm to get TRADE_SPOT for the instrument.
     * @type {object}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'INSTRUMENT_TRADE_SPOT_FROM_BLOB_LAST_PROXIED_REST_REQUEST'?: object;
    /**
     * The last time we sent a request to the proxy swarm to get TRADE_SPOT for the instrument.
     * @type {number}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'INSTRUMENT_TRADE_SPOT_FROM_BLOB_REST_URI_LAST_REQUEST_TS'?: number;
    /**
     * The last time we received a request from the proxy swarm with TRADE_SPOT for this instrument.
     * @type {number}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'INSTRUMENT_TRADE_SPOT_FROM_BLOB_REST_URI_LAST_RESPONSE_TS'?: number;
    /**
     * The next time we expect to make a request for TRADE_SPOT on this instrument.
     * @type {number}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'INSTRUMENT_TRADE_SPOT_FROM_BLOB_REST_URI_NEXT_REQUEST_TS'?: number;
    /**
     * The last proxied REST request we sent to the proxy swarm to get TRADE_SPOT for the instrument.
     * @type {object}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'INSTRUMENT_TRADE_SPOT_FROM_CALCULATED_LAST_PROXIED_REST_REQUEST'?: object;
    /**
     * The last time we sent a request to the proxy swarm to get TRADE_SPOT for the instrument.
     * @type {number}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'INSTRUMENT_TRADE_SPOT_FROM_CALCULATED_REST_URI_LAST_REQUEST_TS'?: number;
    /**
     * The last time we received a request from the proxy swarm with TRADE_SPOT for this instrument.
     * @type {number}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'INSTRUMENT_TRADE_SPOT_FROM_CALCULATED_REST_URI_LAST_RESPONSE_TS'?: number;
    /**
     * The next time we expect to make a request for TRADE_SPOT on this instrument.
     * @type {number}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'INSTRUMENT_TRADE_SPOT_FROM_CALCULATED_REST_URI_NEXT_REQUEST_TS'?: number;
    /**
     * The last proxied REST request we sent to the proxy swarm to get TRADE_SPOT for the instrument.
     * @type {object}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'INSTRUMENT_TRADE_SPOT_FROM_FIX_LAST_PROXIED_REST_REQUEST'?: object;
    /**
     * The last time we sent a request to the proxy swarm to get TRADE_SPOT for the instrument.
     * @type {number}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'INSTRUMENT_TRADE_SPOT_FROM_FIX_REST_URI_LAST_REQUEST_TS'?: number;
    /**
     * The last time we received a request from the proxy swarm with TRADE_SPOT for this instrument.
     * @type {number}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'INSTRUMENT_TRADE_SPOT_FROM_FIX_REST_URI_LAST_RESPONSE_TS'?: number;
    /**
     * The next time we expect to make a request for TRADE_SPOT on this instrument.
     * @type {number}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'INSTRUMENT_TRADE_SPOT_FROM_FIX_REST_URI_NEXT_REQUEST_TS'?: number;
    /**
     * The last proxied REST request we sent to the proxy swarm to get TRADE_SPOT for the instrument.
     * @type {object}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'INSTRUMENT_TRADE_SPOT_FROM_GO_LAST_PROXIED_REST_REQUEST'?: object;
    /**
     * The last time we sent a request to the proxy swarm to get TRADE_SPOT for the instrument.
     * @type {number}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'INSTRUMENT_TRADE_SPOT_FROM_GO_REST_URI_LAST_REQUEST_TS'?: number;
    /**
     * The last time we received a request from the proxy swarm with TRADE_SPOT for this instrument.
     * @type {number}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'INSTRUMENT_TRADE_SPOT_FROM_GO_REST_URI_LAST_RESPONSE_TS'?: number;
    /**
     * The next time we expect to make a request for TRADE_SPOT on this instrument.
     * @type {number}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'INSTRUMENT_TRADE_SPOT_FROM_GO_REST_URI_NEXT_REQUEST_TS'?: number;
    /**
     * The last proxied REST request we sent to the proxy swarm to get TRADE_SPOT for the instrument.
     * @type {object}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'INSTRUMENT_TRADE_SPOT_FROM_POLLING_LAST_PROXIED_REST_REQUEST'?: object;
    /**
     * The last time we sent a request to the proxy swarm to get TRADE_SPOT for the instrument.
     * @type {number}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'INSTRUMENT_TRADE_SPOT_FROM_POLLING_REST_URI_LAST_REQUEST_TS'?: number;
    /**
     * The last time we received a request from the proxy swarm with TRADE_SPOT for this instrument.
     * @type {number}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'INSTRUMENT_TRADE_SPOT_FROM_POLLING_REST_URI_LAST_RESPONSE_TS'?: number;
    /**
     * The next time we expect to make a request for TRADE_SPOT on this instrument.
     * @type {number}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'INSTRUMENT_TRADE_SPOT_FROM_POLLING_REST_URI_NEXT_REQUEST_TS'?: number;
    /**
     * The last proxied REST request we sent to the proxy swarm to get TRADE_SPOT for the instrument.
     * @type {object}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'INSTRUMENT_TRADE_SPOT_FROM_STREAMING_LAST_PROXIED_REST_REQUEST'?: object;
    /**
     * The last time we sent a request to the proxy swarm to get TRADE_SPOT for the instrument.
     * @type {number}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'INSTRUMENT_TRADE_SPOT_FROM_STREAMING_REST_URI_LAST_REQUEST_TS'?: number;
    /**
     * The last time we received a request from the proxy swarm with TRADE_SPOT for this instrument.
     * @type {number}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'INSTRUMENT_TRADE_SPOT_FROM_STREAMING_REST_URI_LAST_RESPONSE_TS'?: number;
    /**
     * The next time we expect to make a request for TRADE_SPOT on this instrument.
     * @type {number}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'INSTRUMENT_TRADE_SPOT_FROM_STREAMING_REST_URI_NEXT_REQUEST_TS'?: number;
    /**
     * This flags the exchange instrument as in ready to consume TRADE_SPOT via a streaming integration.
     * @type {boolean}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'INSTRUMENT_TRADE_SPOT_IS_READY_FOR_STREAMING_INTEGRATION'?: boolean;
    /**
     * This is used to build up the request in some cases, this is where we put the id we use when querying for TRADE_SPOT.
     * @type {string}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'INSTRUMENT_TRADE_SPOT_REST_URI'?: string;
    /**
     * The URL we send to the proxy swarm to get TRADE_SPOT for the instrument.
     * @type {string}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'INSTRUMENT_TRADE_SPOT_REST_URL'?: string;
    /**
     * This is used to build up the subscription in some cases, this is where we put the id we use when subscribing for TRADE_SPOT on this instrument.
     * @type {string}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'INSTRUMENT_TRADE_SPOT_STREAMING_SUBSCRIPTION'?: string;
    /**
     * The timestamp last encountered where the batch of trades from TRADES_SPOT all occured at the same time. This is an issue when making the next request that requires polling by timestamp as a start/from parameter
     * @type {number}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'LAST_CONCURRENT_BATCH_OF_TRADES_SPOT_MS'?: number;
    /**
     * This is the last time instrument was seen on instrumentListSourceType BLOB.
     * @type {number}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'LAST_SEEN_ON_BLOB_TS'?: number;
    /**
     * This is the last time instrument was seen on instrumentListSourceType FIX.
     * @type {number}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'LAST_SEEN_ON_FIX_TS'?: number;
    /**
     * This is the last time instrument was seen on instrumentListSourceType HARDCODED.
     * @type {number}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'LAST_SEEN_ON_HARDCODED_TS'?: number;
    /**
     * This is the last time instrument was seen on instrumentListSourceType INDEX_COMPOSITION.
     * @type {number}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'LAST_SEEN_ON_INDEX_COMPOSITION_TS'?: number;
    /**
     * This is the last time instrument was seen on instrumentListSourceType NSQ.
     * @type {number}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'LAST_SEEN_ON_NSQ_TS'?: number;
    /**
     * This is the last time instrument was seen on instrumentListSourceType POLLING.
     * @type {number}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'LAST_SEEN_ON_POLLING_TS'?: number;
    /**
     * This is the last time instrument was seen on instrumentListSourceType STREAMING.
     * @type {number}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'LAST_SEEN_ON_STREAMING_TS'?: number;
    /**
     * This is the last TRADE_SPOT that we have seen on the specific source type in internal format.
     * @type {object}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'LAST_TRADE_SPOT_FROM_BACKFILL'?: object;
    /**
     * This is the last TRADE_SPOT that we have seen on the specific trade source in external format.
     * @type {object}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'LAST_TRADE_SPOT_FROM_BACKFILL_EXTERNAL'?: object;
    /**
     * This is the last TRADE_SPOT that we have seen on the specific source type in internal format.
     * @type {object}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'LAST_TRADE_SPOT_FROM_BLOB'?: object;
    /**
     * This is the last TRADE_SPOT that we have seen on the specific trade source in external format.
     * @type {object}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'LAST_TRADE_SPOT_FROM_BLOB_EXTERNAL'?: object;
    /**
     * This is the last TRADE_SPOT that we have seen on the specific source type in internal format.
     * @type {object}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'LAST_TRADE_SPOT_FROM_CALCULATED'?: object;
    /**
     * This is the last TRADE_SPOT that we have seen on the specific trade source in external format.
     * @type {object}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'LAST_TRADE_SPOT_FROM_CALCULATED_EXTERNAL'?: object;
    /**
     * This is the last TRADE_SPOT that we have seen on the specific source type in internal format.
     * @type {object}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'LAST_TRADE_SPOT_FROM_FIX'?: object;
    /**
     * This is the last TRADE_SPOT that we have seen on the specific trade source in external format.
     * @type {object}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'LAST_TRADE_SPOT_FROM_FIX_EXTERNAL'?: object;
    /**
     * This is the last TRADE_SPOT that we have seen on the specific source type in internal format.
     * @type {object}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'LAST_TRADE_SPOT_FROM_GO'?: object;
    /**
     * This is the last TRADE_SPOT that we have seen on the specific trade source in external format.
     * @type {object}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'LAST_TRADE_SPOT_FROM_GO_EXTERNAL'?: object;
    /**
     * This is the last TRADE_SPOT that we have seen on the specific source type in internal format.
     * @type {object}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'LAST_TRADE_SPOT_FROM_POLLING'?: object;
    /**
     * This is the last TRADE_SPOT that we have seen on the specific trade source in external format.
     * @type {object}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'LAST_TRADE_SPOT_FROM_POLLING_EXTERNAL'?: object;
    /**
     * This is the last TRADE_SPOT that we have seen on the specific source type in internal format.
     * @type {object}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'LAST_TRADE_SPOT_FROM_STREAMING'?: object;
    /**
     * This is the last TRADE_SPOT that we have seen on the specific trade source in external format.
     * @type {object}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'LAST_TRADE_SPOT_FROM_STREAMING_EXTERNAL'?: object;
    /**
     * The version of metadata, used for version conversions/migrates.
     * @type {number}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'METADATA_VERSION'?: number;
    /**
     * This states the status of blob migration for this intrument on this exchange.
     * @type {string}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'PROCESSING_TRADES_FROM_BLOB_STATUS'?: string;
    /**
     * This is both the CCSEQ and the total TRADES_SPOT we have processed on this instrument
     * @type {number}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'TOTAL_TRADES_SPOT'?: number;
    /**
     * This is any extra helper TRADE_SPOT data that we would need for creating polling requests or subscribing with non standard information and anything that is very specific to one exchange API/Integration and it does not fit any of the other existing fields and is definitly only updated or written in only one service.
     * @type {object}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'UNSTRUCTURED_TRADE_SPOT_FROM_BACKFILL_INTERNAL_DATA'?: object;
    /**
     * This is any extra helper TRADE_SPOT data that we would need for creating polling requests or subscribing with non standard information and anything that is very specific to one exchange API/Integration and it does not fit any of the other existing fields and is definitly only updated or written in only one service.
     * @type {object}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'UNSTRUCTURED_TRADE_SPOT_FROM_BLOB_INTERNAL_DATA'?: object;
    /**
     * This is any extra helper TRADE_SPOT data that we would need for creating polling requests or subscribing with non standard information and anything that is very specific to one exchange API/Integration and it does not fit any of the other existing fields and is definitly only updated or written in only one service.
     * @type {object}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'UNSTRUCTURED_TRADE_SPOT_FROM_CALCULATED_INTERNAL_DATA'?: object;
    /**
     * This is any extra helper TRADE_SPOT data that we would need for creating polling requests or subscribing with non standard information and anything that is very specific to one exchange API/Integration and it does not fit any of the other existing fields and is definitly only updated or written in only one service.
     * @type {object}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'UNSTRUCTURED_TRADE_SPOT_FROM_FIX_INTERNAL_DATA'?: object;
    /**
     * This is any extra helper TRADE_SPOT data that we would need for creating polling requests or subscribing with non standard information and anything that is very specific to one exchange API/Integration and it does not fit any of the other existing fields and is definitly only updated or written in only one service.
     * @type {object}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'UNSTRUCTURED_TRADE_SPOT_FROM_GO_INTERNAL_DATA'?: object;
    /**
     * This is any extra helper TRADE_SPOT data that we would need for creating polling requests or subscribing with non standard information and anything that is very specific to one exchange API/Integration and it does not fit any of the other existing fields and is definitly only updated or written in only one service.
     * @type {object}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'UNSTRUCTURED_TRADE_SPOT_FROM_POLLING_INTERNAL_DATA'?: object;
    /**
     * This is any extra helper TRADE_SPOT data that we would need for creating polling requests or subscribing with non standard information and anything that is very specific to one exchange API/Integration and it does not fit any of the other existing fields and is definitly only updated or written in only one service.
     * @type {object}
     * @memberof SPOTINSTRUMENTMETADATA
     */
    'UNSTRUCTURED_TRADE_SPOT_FROM_STREAMING_INTERNAL_DATA'?: object;
}
/**
 * 
 * @export
 * @interface SPOTINSTRUMENTMETADATARESPONSE
 */
export interface SPOTINSTRUMENTMETADATARESPONSE {
    /**
     * 
     * @type {{ [key: string]: SPOTINSTRUMENTMETADATA; }}
     * @memberof SPOTINSTRUMENTMETADATARESPONSE
     */
    'Data'?: { [key: string]: SPOTINSTRUMENTMETADATA; };
    /**
     * 
     * @type {SPOTINSTRUMENTMARKETDATARESPONSEErr}
     * @memberof SPOTINSTRUMENTMETADATARESPONSE
     */
    'Err'?: SPOTINSTRUMENTMARKETDATARESPONSEErr;
}
/**
 * 
 * @export
 * @interface SPOTINSTRUMENTTRADE
 */
export interface SPOTINSTRUMENTTRADE {
    /**
     * The mapped from asset (base / symbol/ coin). Only available on instruments that have been mapped (e.g. BTC).
     * @type {string}
     * @memberof SPOTINSTRUMENTTRADE
     */
    'BASE'?: string;
    /**
     * Our internal sequence number for this trade, this is unique per market / exchange and trading pair. Should always be increasing by 1 for each new trade we discover, not in chronological order.
     * @type {number}
     * @memberof SPOTINSTRUMENTTRADE
     */
    'CCSEQ'?: number;
    /**
     * The trade ID as reported by the market / exchange. If the exchange does not provide a trade ID, this will be the timestamp of the trade + a number from 0 - 999. This preserves uniqueness, assuming there would never be more than 999 trades in any given second.
     * @type {string}
     * @memberof SPOTINSTRUMENTTRADE
     */
    'ID'?: string;
    /**
     * The unmapped instrument ID as given by the exchange (e.g. BTCUSD, BTC_USD, XBT-ZUSD, BTC-USD).
     * @type {string}
     * @memberof SPOTINSTRUMENTTRADE
     */
    'INSTRUMENT'?: string;
    /**
     * The mapped instrument ID, as derived from our mapping rules. This takes the form: \"BASE-QUOTE\". Only available on instruments that have been mapped (e.g. BTC-USD).
     * @type {string}
     * @memberof SPOTINSTRUMENTTRADE
     */
    'MAPPED_INSTRUMENT'?: string;
    /**
     * The market / exchange under consideration (e.g. Coinbase, Kraken, etc.).
     * @type {string}
     * @memberof SPOTINSTRUMENTTRADE
     */
    'MARKET'?: string;
    /**
     * The price in the to instrument (quote / counter symbol / coin) of the trade. For a BTC-USD trade, this is how much was paid for one BTC in USD. For futures, this will be the price of the contract.
     * @type {number}
     * @memberof SPOTINSTRUMENTTRADE
     */
    'PRICE'?: number;
    /**
     * The volume of the trade, given in the from instrument (base symbol / coin/ contract). For a spot BTC-USD trade, this is how much BTC was traded at the trade price. For a futures BTCUSDPERP, this is the BTC equivalent for the contracts traded.
     * @type {number}
     * @memberof SPOTINSTRUMENTTRADE
     */
    'QUANTITY'?: number;
    /**
     * The mapped to asset (quote / counter symbol / coin). Only available on instruments that have been mapped (e.g. USD).
     * @type {string}
     * @memberof SPOTINSTRUMENTTRADE
     */
    'QUOTE'?: string;
    /**
     * The volume of the trade, given in the to instrument (quote / counter symbol / coin). This is equivalent to QUANTITY * PRICE. E.g. for a BTC-USD trade, this is how much USD was paid in total for the volume of BTC traded. For futures this is the quote currency equivalent for the contracts traded.
     * @type {number}
     * @memberof SPOTINSTRUMENTTRADE
     */
    'QUOTE_QUANTITY'?: number;
    /**
     * The timestamp in seconds that the trade was received. This varies from the trade taking place on the market by a few millisconds to a few seconds depending on the market / exchange API options / rate limits.
     * @type {number}
     * @memberof SPOTINSTRUMENTTRADE
     */
    'RECEIVED_TIMESTAMP'?: number;
    /**
     * The nanosecond part of the received timestamp.
     * @type {number}
     * @memberof SPOTINSTRUMENTTRADE
     */
    'RECEIVED_TIMESTAMP_NS'?: number;
    /**
     * The side of the trade: SELL, BUY or UNKNOWN. If the exchange / api does not provide a side, \"UNKNOWN\" will be returned.
     * @type {string}
     * @memberof SPOTINSTRUMENTTRADE
     */
    'SIDE'?: string;
    /**
     * The source of the trade update: POLLING, STREAMING, GO, BLOB etc.
     * @type {string}
     * @memberof SPOTINSTRUMENTTRADE
     */
    'SOURCE'?: string;
    /**
     * The timestamp in seconds as reported by the market / exchange or the received timestamp if the market / exchange does not provide one.
     * @type {number}
     * @memberof SPOTINSTRUMENTTRADE
     */
    'TIMESTAMP'?: number;
    /**
     * The nanosecond part of the reported timestamp.
     * @type {number}
     * @memberof SPOTINSTRUMENTTRADE
     */
    'TIMESTAMP_NS'?: number;
    /**
     * The type of the message.
     * @type {string}
     * @memberof SPOTINSTRUMENTTRADE
     */
    'TYPE'?: string;
}
/**
 * 
 * @export
 * @interface SPOTINSTRUMENTTRADERESPONSE
 */
export interface SPOTINSTRUMENTTRADERESPONSE {
    /**
     * 
     * @type {Array<SPOTINSTRUMENTTRADE>}
     * @memberof SPOTINSTRUMENTTRADERESPONSE
     */
    'Data'?: Array<SPOTINSTRUMENTTRADE>;
    /**
     * 
     * @type {object}
     * @memberof SPOTINSTRUMENTTRADERESPONSE
     */
    'Err'?: object;
}

/**
 * AssetApi - axios parameter creator
 * @export
 */
export const AssetApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} address 
         * @param {string} chainSymbol 
         * @param {string} [groups] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetV1DataByAddress: async (address: string, chainSymbol: string, groups?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('assetV1DataByAddress', 'address', address)
            // verify required parameter 'chainSymbol' is not null or undefined
            assertParamExists('assetV1DataByAddress', 'chainSymbol', chainSymbol)
            const localVarPath = `/asset/v1/data/by/address`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (chainSymbol !== undefined) {
                localVarQueryParameter['chain_symbol'] = chainSymbol;
            }

            if (groups !== undefined) {
                localVarQueryParameter['groups'] = groups;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} assetId The asset id you are interested in
         * @param {string} [groups] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetV1DataById: async (assetId: number, groups?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('assetV1DataById', 'assetId', assetId)
            const localVarPath = `/asset/v1/data/by/id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (assetId !== undefined) {
                localVarQueryParameter['asset_id'] = assetId;
            }

            if (groups !== undefined) {
                localVarQueryParameter['groups'] = groups;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} assetSymbol The asset symbol you are interested in
         * @param {string} [groups] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetV1DataBySymbol: async (assetSymbol: string, groups?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetSymbol' is not null or undefined
            assertParamExists('assetV1DataBySymbol', 'assetSymbol', assetSymbol)
            const localVarPath = `/asset/v1/data/by/symbol`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (assetSymbol !== undefined) {
                localVarQueryParameter['asset_symbol'] = assetSymbol;
            }

            if (groups !== undefined) {
                localVarQueryParameter['groups'] = groups;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] The page number for the request to get {page_size} coins at the time.
         * @param {number} [pageSize] The number of items returned per page
         * @param {string} [assetType] The asset class/type
         * @param {'CREATED_ON' | 'UPDATED_ON' | 'SYMBOL'} [sortBy] Sort by field ( CREATED_ON,UPDATED_ON,SYMBOL )
         * @param {'DESC' | 'ASC'} [sortDirection] Sort direction ( DESC,ASC )
         * @param {string} [groups] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetV1TopList: async (page?: number, pageSize?: number, assetType?: string, sortBy?: 'CREATED_ON' | 'UPDATED_ON' | 'SYMBOL', sortDirection?: 'DESC' | 'ASC', groups?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/asset/v1/top/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (assetType !== undefined) {
                localVarQueryParameter['asset_type'] = assetType;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }

            if (groups !== undefined) {
                localVarQueryParameter['groups'] = groups;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssetApi - functional programming interface
 * @export
 */
export const AssetApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AssetApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} address 
         * @param {string} chainSymbol 
         * @param {string} [groups] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assetV1DataByAddress(address: string, chainSymbol: string, groups?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assetV1DataByAddress(address, chainSymbol, groups, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} assetId The asset id you are interested in
         * @param {string} [groups] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assetV1DataById(assetId: number, groups?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assetV1DataById(assetId, groups, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} assetSymbol The asset symbol you are interested in
         * @param {string} [groups] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assetV1DataBySymbol(assetSymbol: string, groups?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assetV1DataBySymbol(assetSymbol, groups, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] The page number for the request to get {page_size} coins at the time.
         * @param {number} [pageSize] The number of items returned per page
         * @param {string} [assetType] The asset class/type
         * @param {'CREATED_ON' | 'UPDATED_ON' | 'SYMBOL'} [sortBy] Sort by field ( CREATED_ON,UPDATED_ON,SYMBOL )
         * @param {'DESC' | 'ASC'} [sortDirection] Sort direction ( DESC,ASC )
         * @param {string} [groups] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assetV1TopList(page?: number, pageSize?: number, assetType?: string, sortBy?: 'CREATED_ON' | 'UPDATED_ON' | 'SYMBOL', sortDirection?: 'DESC' | 'ASC', groups?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assetV1TopList(page, pageSize, assetType, sortBy, sortDirection, groups, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AssetApi - factory interface
 * @export
 */
export const AssetApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AssetApiFp(configuration)
    return {
        /**
         * 
         * @param {string} address 
         * @param {string} chainSymbol 
         * @param {string} [groups] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetV1DataByAddress(address: string, chainSymbol: string, groups?: string, options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.assetV1DataByAddress(address, chainSymbol, groups, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} assetId The asset id you are interested in
         * @param {string} [groups] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetV1DataById(assetId: number, groups?: string, options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.assetV1DataById(assetId, groups, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} assetSymbol The asset symbol you are interested in
         * @param {string} [groups] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetV1DataBySymbol(assetSymbol: string, groups?: string, options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.assetV1DataBySymbol(assetSymbol, groups, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] The page number for the request to get {page_size} coins at the time.
         * @param {number} [pageSize] The number of items returned per page
         * @param {string} [assetType] The asset class/type
         * @param {'CREATED_ON' | 'UPDATED_ON' | 'SYMBOL'} [sortBy] Sort by field ( CREATED_ON,UPDATED_ON,SYMBOL )
         * @param {'DESC' | 'ASC'} [sortDirection] Sort direction ( DESC,ASC )
         * @param {string} [groups] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetV1TopList(page?: number, pageSize?: number, assetType?: string, sortBy?: 'CREATED_ON' | 'UPDATED_ON' | 'SYMBOL', sortDirection?: 'DESC' | 'ASC', groups?: string, options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.assetV1TopList(page, pageSize, assetType, sortBy, sortDirection, groups, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AssetApi - object-oriented interface
 * @export
 * @class AssetApi
 * @extends {BaseAPI}
 */
export class AssetApi extends BaseAPI {
    /**
     * 
     * @param {string} address 
     * @param {string} chainSymbol 
     * @param {string} [groups] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public assetV1DataByAddress(address: string, chainSymbol: string, groups?: string, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).assetV1DataByAddress(address, chainSymbol, groups, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} assetId The asset id you are interested in
     * @param {string} [groups] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public assetV1DataById(assetId: number, groups?: string, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).assetV1DataById(assetId, groups, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} assetSymbol The asset symbol you are interested in
     * @param {string} [groups] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public assetV1DataBySymbol(assetSymbol: string, groups?: string, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).assetV1DataBySymbol(assetSymbol, groups, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] The page number for the request to get {page_size} coins at the time.
     * @param {number} [pageSize] The number of items returned per page
     * @param {string} [assetType] The asset class/type
     * @param {'CREATED_ON' | 'UPDATED_ON' | 'SYMBOL'} [sortBy] Sort by field ( CREATED_ON,UPDATED_ON,SYMBOL )
     * @param {'DESC' | 'ASC'} [sortDirection] Sort direction ( DESC,ASC )
     * @param {string} [groups] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public assetV1TopList(page?: number, pageSize?: number, assetType?: string, sortBy?: 'CREATED_ON' | 'UPDATED_ON' | 'SYMBOL', sortDirection?: 'DESC' | 'ASC', groups?: string, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).assetV1TopList(page, pageSize, assetType, sortBy, sortDirection, groups, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FuturesApi - axios parameter creator
 * @export
 */
export const FuturesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,OHLC,OHLC_TRADE,TRADE,VOLUME
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        futuresV1HistoricalDays: async (market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'market' is not null or undefined
            assertParamExists('futuresV1HistoricalDays', 'market', market)
            // verify required parameter 'instrument' is not null or undefined
            assertParamExists('futuresV1HistoricalDays', 'instrument', instrument)
            const localVarPath = `/futures/v1/historical/days`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (market !== undefined) {
                localVarQueryParameter['market'] = market;
            }

            if (instrument !== undefined) {
                localVarQueryParameter['instrument'] = instrument;
            }

            if (groups) {
                localVarQueryParameter['groups'] = groups.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (toTs !== undefined) {
                localVarQueryParameter['to_ts'] = toTs;
            }

            if (aggregate !== undefined) {
                localVarQueryParameter['aggregate'] = aggregate;
            }

            if (fill !== undefined) {
                localVarQueryParameter['fill'] = fill;
            }

            if (mappingPriority !== undefined) {
                localVarQueryParameter['mapping_priority'] = mappingPriority;
            }

            if (responseFormat !== undefined) {
                localVarQueryParameter['response_format'] = responseFormat;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,VALUE,OHLC,OHLC_MESSAGE,MESSAGE
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        futuresV1HistoricalFundingRateDays: async (market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'market' is not null or undefined
            assertParamExists('futuresV1HistoricalFundingRateDays', 'market', market)
            // verify required parameter 'instrument' is not null or undefined
            assertParamExists('futuresV1HistoricalFundingRateDays', 'instrument', instrument)
            const localVarPath = `/futures/v1/historical/funding-rate/days`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (market !== undefined) {
                localVarQueryParameter['market'] = market;
            }

            if (instrument !== undefined) {
                localVarQueryParameter['instrument'] = instrument;
            }

            if (groups) {
                localVarQueryParameter['groups'] = groups.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (toTs !== undefined) {
                localVarQueryParameter['to_ts'] = toTs;
            }

            if (aggregate !== undefined) {
                localVarQueryParameter['aggregate'] = aggregate;
            }

            if (fill !== undefined) {
                localVarQueryParameter['fill'] = fill;
            }

            if (mappingPriority !== undefined) {
                localVarQueryParameter['mapping_priority'] = mappingPriority;
            }

            if (responseFormat !== undefined) {
                localVarQueryParameter['response_format'] = responseFormat;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,VALUE,OHLC,OHLC_MESSAGE,MESSAGE
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        futuresV1HistoricalFundingRateHours: async (market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'market' is not null or undefined
            assertParamExists('futuresV1HistoricalFundingRateHours', 'market', market)
            // verify required parameter 'instrument' is not null or undefined
            assertParamExists('futuresV1HistoricalFundingRateHours', 'instrument', instrument)
            const localVarPath = `/futures/v1/historical/funding-rate/hours`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (market !== undefined) {
                localVarQueryParameter['market'] = market;
            }

            if (instrument !== undefined) {
                localVarQueryParameter['instrument'] = instrument;
            }

            if (groups) {
                localVarQueryParameter['groups'] = groups.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (toTs !== undefined) {
                localVarQueryParameter['to_ts'] = toTs;
            }

            if (aggregate !== undefined) {
                localVarQueryParameter['aggregate'] = aggregate;
            }

            if (fill !== undefined) {
                localVarQueryParameter['fill'] = fill;
            }

            if (mappingPriority !== undefined) {
                localVarQueryParameter['mapping_priority'] = mappingPriority;
            }

            if (responseFormat !== undefined) {
                localVarQueryParameter['response_format'] = responseFormat;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {number} [afterTs] Unix timestamp in seconds of the earliest funding rate message in the response
         * @param {number} [lastCcseq] The CCSEQ of the last message seen in the previous request. Useful for pagination within messages that happened in the same second. It will look though the messages in the same second and discard all messages until it reaches the CCSEQ from the last_ccseq parameter. If the CCSEQ is not part of that second, it will discard all messages in the second and only return messages starting from the next second onwards. When starting an integration with our API, on the first request, you should either not send a value for this paramater (defaults to 0 and does not discard any messages) or send 0. After you get a response use the TIMESTAMP and CCSEQ from the last message in the response. Pass the TIMESTAMP in the after_ts parameter and the CCSEQ in the last_ccseq parameter on your next request.
         * @param {number} [limit] The maximum number of funding rate messages to return
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {boolean} [return404OnEmptyResponse] If set to false (default) then when there are no items to return, you will get a response status code of 200 and an empty JSON array or a CSV file with just the header. If set to true then when there are no items you will get a 404 status code for both JSON and CSV response_formats.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        futuresV1HistoricalFundingRateMessages: async (market: string, instrument: string, afterTs?: number, lastCcseq?: number, limit?: number, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', return404OnEmptyResponse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'market' is not null or undefined
            assertParamExists('futuresV1HistoricalFundingRateMessages', 'market', market)
            // verify required parameter 'instrument' is not null or undefined
            assertParamExists('futuresV1HistoricalFundingRateMessages', 'instrument', instrument)
            const localVarPath = `/futures/v1/historical/funding-rate-messages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)

            if (market !== undefined) {
                localVarQueryParameter['market'] = market;
            }

            if (instrument !== undefined) {
                localVarQueryParameter['instrument'] = instrument;
            }

            if (afterTs !== undefined) {
                localVarQueryParameter['after_ts'] = afterTs;
            }

            if (lastCcseq !== undefined) {
                localVarQueryParameter['last_ccseq'] = lastCcseq;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (mappingPriority !== undefined) {
                localVarQueryParameter['mapping_priority'] = mappingPriority;
            }

            if (responseFormat !== undefined) {
                localVarQueryParameter['response_format'] = responseFormat;
            }

            if (return404OnEmptyResponse !== undefined) {
                localVarQueryParameter['return_404_on_empty_response'] = return404OnEmptyResponse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {number} [hourTs] Unix timestamp in seconds for the hour containing the funding rate updates you are interested in. You can pass any timestamp in the hour but we will round it down the the full hour timestmap and return all funding rate updates in that hour.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {boolean} [return404OnEmptyResponse] If set to false (default) then when there are no items to return, you will get a response status code of 200 and an empty JSON array or a CSV file with just the header. If set to true then when there are no items you will get a 404 status code for both JSON and CSV response_formats.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        futuresV1HistoricalFundingRateMessagesHour: async (market: string, instrument: string, hourTs?: number, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', return404OnEmptyResponse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'market' is not null or undefined
            assertParamExists('futuresV1HistoricalFundingRateMessagesHour', 'market', market)
            // verify required parameter 'instrument' is not null or undefined
            assertParamExists('futuresV1HistoricalFundingRateMessagesHour', 'instrument', instrument)
            const localVarPath = `/futures/v1/historical/funding-rate-messages/hour`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)

            if (market !== undefined) {
                localVarQueryParameter['market'] = market;
            }

            if (instrument !== undefined) {
                localVarQueryParameter['instrument'] = instrument;
            }

            if (hourTs !== undefined) {
                localVarQueryParameter['hour_ts'] = hourTs;
            }

            if (mappingPriority !== undefined) {
                localVarQueryParameter['mapping_priority'] = mappingPriority;
            }

            if (responseFormat !== undefined) {
                localVarQueryParameter['response_format'] = responseFormat;
            }

            if (return404OnEmptyResponse !== undefined) {
                localVarQueryParameter['return_404_on_empty_response'] = return404OnEmptyResponse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,VALUE,OHLC,OHLC_MESSAGE,MESSAGE
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        futuresV1HistoricalFundingRateMinutes: async (market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'market' is not null or undefined
            assertParamExists('futuresV1HistoricalFundingRateMinutes', 'market', market)
            // verify required parameter 'instrument' is not null or undefined
            assertParamExists('futuresV1HistoricalFundingRateMinutes', 'instrument', instrument)
            const localVarPath = `/futures/v1/historical/funding-rate/minutes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (market !== undefined) {
                localVarQueryParameter['market'] = market;
            }

            if (instrument !== undefined) {
                localVarQueryParameter['instrument'] = instrument;
            }

            if (groups) {
                localVarQueryParameter['groups'] = groups.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (toTs !== undefined) {
                localVarQueryParameter['to_ts'] = toTs;
            }

            if (aggregate !== undefined) {
                localVarQueryParameter['aggregate'] = aggregate;
            }

            if (fill !== undefined) {
                localVarQueryParameter['fill'] = fill;
            }

            if (mappingPriority !== undefined) {
                localVarQueryParameter['mapping_priority'] = mappingPriority;
            }

            if (responseFormat !== undefined) {
                localVarQueryParameter['response_format'] = responseFormat;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,OHLC,OHLC_TRADE,TRADE,VOLUME
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        futuresV1HistoricalHours: async (market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'market' is not null or undefined
            assertParamExists('futuresV1HistoricalHours', 'market', market)
            // verify required parameter 'instrument' is not null or undefined
            assertParamExists('futuresV1HistoricalHours', 'instrument', instrument)
            const localVarPath = `/futures/v1/historical/hours`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (market !== undefined) {
                localVarQueryParameter['market'] = market;
            }

            if (instrument !== undefined) {
                localVarQueryParameter['instrument'] = instrument;
            }

            if (groups) {
                localVarQueryParameter['groups'] = groups.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (toTs !== undefined) {
                localVarQueryParameter['to_ts'] = toTs;
            }

            if (aggregate !== undefined) {
                localVarQueryParameter['aggregate'] = aggregate;
            }

            if (fill !== undefined) {
                localVarQueryParameter['fill'] = fill;
            }

            if (mappingPriority !== undefined) {
                localVarQueryParameter['mapping_priority'] = mappingPriority;
            }

            if (responseFormat !== undefined) {
                localVarQueryParameter['response_format'] = responseFormat;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,OHLC,OHLC_TRADE,TRADE,VOLUME
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        futuresV1HistoricalMinutes: async (market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'market' is not null or undefined
            assertParamExists('futuresV1HistoricalMinutes', 'market', market)
            // verify required parameter 'instrument' is not null or undefined
            assertParamExists('futuresV1HistoricalMinutes', 'instrument', instrument)
            const localVarPath = `/futures/v1/historical/minutes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (market !== undefined) {
                localVarQueryParameter['market'] = market;
            }

            if (instrument !== undefined) {
                localVarQueryParameter['instrument'] = instrument;
            }

            if (groups) {
                localVarQueryParameter['groups'] = groups.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (toTs !== undefined) {
                localVarQueryParameter['to_ts'] = toTs;
            }

            if (aggregate !== undefined) {
                localVarQueryParameter['aggregate'] = aggregate;
            }

            if (fill !== undefined) {
                localVarQueryParameter['fill'] = fill;
            }

            if (mappingPriority !== undefined) {
                localVarQueryParameter['mapping_priority'] = mappingPriority;
            }

            if (responseFormat !== undefined) {
                localVarQueryParameter['response_format'] = responseFormat;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,OHLC,OHLC_MESSAGE,MESSAGE
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        futuresV1HistoricalOpenInterestDays: async (market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'market' is not null or undefined
            assertParamExists('futuresV1HistoricalOpenInterestDays', 'market', market)
            // verify required parameter 'instrument' is not null or undefined
            assertParamExists('futuresV1HistoricalOpenInterestDays', 'instrument', instrument)
            const localVarPath = `/futures/v1/historical/open-interest/days`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (market !== undefined) {
                localVarQueryParameter['market'] = market;
            }

            if (instrument !== undefined) {
                localVarQueryParameter['instrument'] = instrument;
            }

            if (groups) {
                localVarQueryParameter['groups'] = groups.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (toTs !== undefined) {
                localVarQueryParameter['to_ts'] = toTs;
            }

            if (aggregate !== undefined) {
                localVarQueryParameter['aggregate'] = aggregate;
            }

            if (fill !== undefined) {
                localVarQueryParameter['fill'] = fill;
            }

            if (mappingPriority !== undefined) {
                localVarQueryParameter['mapping_priority'] = mappingPriority;
            }

            if (responseFormat !== undefined) {
                localVarQueryParameter['response_format'] = responseFormat;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,OHLC,OHLC_MESSAGE,MESSAGE
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        futuresV1HistoricalOpenInterestHours: async (market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'market' is not null or undefined
            assertParamExists('futuresV1HistoricalOpenInterestHours', 'market', market)
            // verify required parameter 'instrument' is not null or undefined
            assertParamExists('futuresV1HistoricalOpenInterestHours', 'instrument', instrument)
            const localVarPath = `/futures/v1/historical/open-interest/hours`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (market !== undefined) {
                localVarQueryParameter['market'] = market;
            }

            if (instrument !== undefined) {
                localVarQueryParameter['instrument'] = instrument;
            }

            if (groups) {
                localVarQueryParameter['groups'] = groups.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (toTs !== undefined) {
                localVarQueryParameter['to_ts'] = toTs;
            }

            if (aggregate !== undefined) {
                localVarQueryParameter['aggregate'] = aggregate;
            }

            if (fill !== undefined) {
                localVarQueryParameter['fill'] = fill;
            }

            if (mappingPriority !== undefined) {
                localVarQueryParameter['mapping_priority'] = mappingPriority;
            }

            if (responseFormat !== undefined) {
                localVarQueryParameter['response_format'] = responseFormat;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {number} [afterTs] Unix timestamp in seconds of the earliest open interest message in the response
         * @param {number} [lastCcseq] The CCSEQ of the last message seen in the previous request. Useful for pagination within messages that happened in the same second. It will look though the messages in the same second and discard all messages until it reaches the CCSEQ from the last_ccseq parameter. If the CCSEQ is not part of that second, it will discard all messages in the second and only return messages starting from the next second onwards. When starting an integration with our API, on the first request, you should either not send a value for this paramater (defaults to 0 and does not discard any messages) or send 0. After you get a response use the TIMESTAMP and CCSEQ from the last message in the response. Pass the TIMESTAMP in the after_ts parameter and the CCSEQ in the last_ccseq parameter on your next request.
         * @param {number} [limit] The maximum number of open interest messages to return
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {boolean} [return404OnEmptyResponse] If set to false (default) then when there are no items to return, you will get a response status code of 200 and an empty JSON array or a CSV file with just the header. If set to true then when there are no items you will get a 404 status code for both JSON and CSV response_formats.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        futuresV1HistoricalOpenInterestMessages: async (market: string, instrument: string, afterTs?: number, lastCcseq?: number, limit?: number, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', return404OnEmptyResponse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'market' is not null or undefined
            assertParamExists('futuresV1HistoricalOpenInterestMessages', 'market', market)
            // verify required parameter 'instrument' is not null or undefined
            assertParamExists('futuresV1HistoricalOpenInterestMessages', 'instrument', instrument)
            const localVarPath = `/futures/v1/historical/open-interest-messages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)

            if (market !== undefined) {
                localVarQueryParameter['market'] = market;
            }

            if (instrument !== undefined) {
                localVarQueryParameter['instrument'] = instrument;
            }

            if (afterTs !== undefined) {
                localVarQueryParameter['after_ts'] = afterTs;
            }

            if (lastCcseq !== undefined) {
                localVarQueryParameter['last_ccseq'] = lastCcseq;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (mappingPriority !== undefined) {
                localVarQueryParameter['mapping_priority'] = mappingPriority;
            }

            if (responseFormat !== undefined) {
                localVarQueryParameter['response_format'] = responseFormat;
            }

            if (return404OnEmptyResponse !== undefined) {
                localVarQueryParameter['return_404_on_empty_response'] = return404OnEmptyResponse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {number} [hourTs] Unix timestamp in seconds for the hour containing the open interest updates you are interested in. You can pass any timestamp in the hour but we will round it down the the full hour timestmap and return all open interest updates in that hour.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {boolean} [return404OnEmptyResponse] If set to false (default) then when there are no items to return, you will get a response status code of 200 and an empty JSON array or a CSV file with just the header. If set to true then when there are no items you will get a 404 status code for both JSON and CSV response_formats.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        futuresV1HistoricalOpenInterestMessagesHour: async (market: string, instrument: string, hourTs?: number, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', return404OnEmptyResponse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'market' is not null or undefined
            assertParamExists('futuresV1HistoricalOpenInterestMessagesHour', 'market', market)
            // verify required parameter 'instrument' is not null or undefined
            assertParamExists('futuresV1HistoricalOpenInterestMessagesHour', 'instrument', instrument)
            const localVarPath = `/futures/v1/historical/open-interest-messages/hour`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)

            if (market !== undefined) {
                localVarQueryParameter['market'] = market;
            }

            if (instrument !== undefined) {
                localVarQueryParameter['instrument'] = instrument;
            }

            if (hourTs !== undefined) {
                localVarQueryParameter['hour_ts'] = hourTs;
            }

            if (mappingPriority !== undefined) {
                localVarQueryParameter['mapping_priority'] = mappingPriority;
            }

            if (responseFormat !== undefined) {
                localVarQueryParameter['response_format'] = responseFormat;
            }

            if (return404OnEmptyResponse !== undefined) {
                localVarQueryParameter['return_404_on_empty_response'] = return404OnEmptyResponse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,OHLC,OHLC_MESSAGE,MESSAGE
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        futuresV1HistoricalOpenInterestMinutes: async (market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'market' is not null or undefined
            assertParamExists('futuresV1HistoricalOpenInterestMinutes', 'market', market)
            // verify required parameter 'instrument' is not null or undefined
            assertParamExists('futuresV1HistoricalOpenInterestMinutes', 'instrument', instrument)
            const localVarPath = `/futures/v1/historical/open-interest/minutes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (market !== undefined) {
                localVarQueryParameter['market'] = market;
            }

            if (instrument !== undefined) {
                localVarQueryParameter['instrument'] = instrument;
            }

            if (groups) {
                localVarQueryParameter['groups'] = groups.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (toTs !== undefined) {
                localVarQueryParameter['to_ts'] = toTs;
            }

            if (aggregate !== undefined) {
                localVarQueryParameter['aggregate'] = aggregate;
            }

            if (fill !== undefined) {
                localVarQueryParameter['fill'] = fill;
            }

            if (mappingPriority !== undefined) {
                localVarQueryParameter['mapping_priority'] = mappingPriority;
            }

            if (responseFormat !== undefined) {
                localVarQueryParameter['response_format'] = responseFormat;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {number} [afterTs] Unix timestamp in seconds of the earliest trade in the response.
         * @param {number} [lastCcseq] The CCSEQ of the last message seen in the previous request. Useful for pagination within messages that happened in the same second. It will look though the messages in the same second and discard all messages until it reaches the CCSEQ from the last_ccseq parameter. If the CCSEQ is not part of that second, it will discard all messages in the second and only return messages starting from the next second onwards. When starting an integration with our API, on the first request, you should either not send a value for this paramater (defaults to 0 and does not discard any messages) or send 0. After you get a response use the TIMESTAMP and CCSEQ from the last message in the response. Pass the TIMESTAMP in the after_ts parameter and the CCSEQ in the last_ccseq parameter on your next request.
         * @param {number} [limit] The maximum number of trades to return
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {boolean} [return404OnEmptyResponse] If set to false (default) then when there are no items to return, you will get a response status code of 200 and an empty JSON array or a CSV file with just the header. If set to true then when there are no items you will get a 404 status code for both JSON and CSV response_formats.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        futuresV1HistoricalTrades: async (market: string, instrument: string, afterTs?: number, lastCcseq?: number, limit?: number, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', return404OnEmptyResponse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'market' is not null or undefined
            assertParamExists('futuresV1HistoricalTrades', 'market', market)
            // verify required parameter 'instrument' is not null or undefined
            assertParamExists('futuresV1HistoricalTrades', 'instrument', instrument)
            const localVarPath = `/futures/v1/historical/trades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)

            if (market !== undefined) {
                localVarQueryParameter['market'] = market;
            }

            if (instrument !== undefined) {
                localVarQueryParameter['instrument'] = instrument;
            }

            if (afterTs !== undefined) {
                localVarQueryParameter['after_ts'] = afterTs;
            }

            if (lastCcseq !== undefined) {
                localVarQueryParameter['last_ccseq'] = lastCcseq;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (mappingPriority !== undefined) {
                localVarQueryParameter['mapping_priority'] = mappingPriority;
            }

            if (responseFormat !== undefined) {
                localVarQueryParameter['response_format'] = responseFormat;
            }

            if (return404OnEmptyResponse !== undefined) {
                localVarQueryParameter['return_404_on_empty_response'] = return404OnEmptyResponse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {number} [hourTs] Unix timestamp in seconds for the hour containing the trades you are interested in. You can pass any timestamp within an hour but we will round it down the the full hour timestmap and return all trades in that hour.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {boolean} [return404OnEmptyResponse] If set to false (default) then when there are no items to return, you will get a response status code of 200 and an empty JSON array or a CSV file with just the header. If set to true then when there are no items you will get a 404 status code for both JSON and CSV response_formats.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        futuresV1HistoricalTradesHour: async (market: string, instrument: string, hourTs?: number, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', return404OnEmptyResponse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'market' is not null or undefined
            assertParamExists('futuresV1HistoricalTradesHour', 'market', market)
            // verify required parameter 'instrument' is not null or undefined
            assertParamExists('futuresV1HistoricalTradesHour', 'instrument', instrument)
            const localVarPath = `/futures/v1/historical/trades/hour`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)

            if (market !== undefined) {
                localVarQueryParameter['market'] = market;
            }

            if (instrument !== undefined) {
                localVarQueryParameter['instrument'] = instrument;
            }

            if (hourTs !== undefined) {
                localVarQueryParameter['hour_ts'] = hourTs;
            }

            if (mappingPriority !== undefined) {
                localVarQueryParameter['mapping_priority'] = mappingPriority;
            }

            if (responseFormat !== undefined) {
                localVarQueryParameter['response_format'] = responseFormat;
            }

            if (return404OnEmptyResponse !== undefined) {
                localVarQueryParameter['return_404_on_empty_response'] = return404OnEmptyResponse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {Array<string>} instruments A comma separated array of mapped and/or unmapped instruments to retrieve for a specific market (you can use either the instrument XXBTZUSD or mapped instrument (base - quote) BTC-USD on kraken as an example). We first check each instrument against the mapped list and then against the unmapped list but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting tick data you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,VALUE,LAST_UPDATE,CURRENT_HOUR,CURRENT_DAY,CURRENT_WEEK,CURRENT_MONTH,CURRENT_YEAR,MOVING_24_HOUR,MOVING_7_DAY,MOVING_30_DAY,MOVING_90_DAY,MOVING_180_DAY,MOVING_365_DAY,LIFETIME
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        futuresV1LatestFundingRateTick: async (market: string, instruments: Array<string>, groups?: Array<string>, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'market' is not null or undefined
            assertParamExists('futuresV1LatestFundingRateTick', 'market', market)
            // verify required parameter 'instruments' is not null or undefined
            assertParamExists('futuresV1LatestFundingRateTick', 'instruments', instruments)
            const localVarPath = `/futures/v1/latest/funding-rate/tick`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (market !== undefined) {
                localVarQueryParameter['market'] = market;
            }

            if (instruments) {
                localVarQueryParameter['instruments'] = instruments.join(COLLECTION_FORMATS.csv);
            }

            if (groups) {
                localVarQueryParameter['groups'] = groups.join(COLLECTION_FORMATS.csv);
            }

            if (mappingPriority !== undefined) {
                localVarQueryParameter['mapping_priority'] = mappingPriority;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {Array<string>} instruments A comma separated array of mapped and/or unmapped instruments to retrieve for a specific market (you can use either the instrument XXBTZUSD or mapped instrument (base - quote) BTC-USD on kraken as an example). We first check each instrument against the mapped list and then against the unmapped list but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting metadata entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: STATUS,INTERNAL,GENERAL,MIGRATION,SOURCE
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        futuresV1LatestInstrumentMetadata: async (market: string, instruments: Array<string>, groups?: Array<string>, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'market' is not null or undefined
            assertParamExists('futuresV1LatestInstrumentMetadata', 'market', market)
            // verify required parameter 'instruments' is not null or undefined
            assertParamExists('futuresV1LatestInstrumentMetadata', 'instruments', instruments)
            const localVarPath = `/futures/v1/latest/instrument/metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (market !== undefined) {
                localVarQueryParameter['market'] = market;
            }

            if (instruments) {
                localVarQueryParameter['instruments'] = instruments.join(COLLECTION_FORMATS.csv);
            }

            if (groups) {
                localVarQueryParameter['groups'] = groups.join(COLLECTION_FORMATS.csv);
            }

            if (mappingPriority !== undefined) {
                localVarQueryParameter['mapping_priority'] = mappingPriority;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {Array<string>} instruments A comma separated array of mapped and/or unmapped instruments to retrieve for a specific market (you can use either the instrument XXBTZUSD or mapped instrument (base - quote) BTC-USD on kraken as an example). We first check each instrument against the mapped list and then against the unmapped list but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting tick data you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,VALUE,LAST_UPDATE,CURRENT_HOUR,CURRENT_DAY,CURRENT_WEEK,CURRENT_MONTH,CURRENT_YEAR,MOVING_24_HOUR,MOVING_7_DAY,MOVING_30_DAY,MOVING_90_DAY,MOVING_180_DAY,MOVING_365_DAY,LIFETIME
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        futuresV1LatestOpenInterestTick: async (market: string, instruments: Array<string>, groups?: Array<string>, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'market' is not null or undefined
            assertParamExists('futuresV1LatestOpenInterestTick', 'market', market)
            // verify required parameter 'instruments' is not null or undefined
            assertParamExists('futuresV1LatestOpenInterestTick', 'instruments', instruments)
            const localVarPath = `/futures/v1/latest/open-interest/tick`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (market !== undefined) {
                localVarQueryParameter['market'] = market;
            }

            if (instruments) {
                localVarQueryParameter['instruments'] = instruments.join(COLLECTION_FORMATS.csv);
            }

            if (groups) {
                localVarQueryParameter['groups'] = groups.join(COLLECTION_FORMATS.csv);
            }

            if (mappingPriority !== undefined) {
                localVarQueryParameter['mapping_priority'] = mappingPriority;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {Array<string>} instruments A comma separated array of mapped and/or unmapped instruments to retrieve for a specific market (you can use either the instrument XXBTZUSD or mapped instrument (base - quote) BTC-USD on kraken as an example). We first check each instrument against the mapped list and then against the unmapped list but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting tick data you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,VALUE,LAST_UPDATE,TOP_OF_BOOK,CURRENT_HOUR,CURRENT_DAY,CURRENT_WEEK,CURRENT_MONTH,CURRENT_YEAR,MOVING_24_HOUR,MOVING_7_DAY,MOVING_30_DAY,MOVING_90_DAY,MOVING_180_DAY,MOVING_365_DAY,LIFETIME
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        futuresV1LatestTick: async (market: string, instruments: Array<string>, groups?: Array<string>, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'market' is not null or undefined
            assertParamExists('futuresV1LatestTick', 'market', market)
            // verify required parameter 'instruments' is not null or undefined
            assertParamExists('futuresV1LatestTick', 'instruments', instruments)
            const localVarPath = `/futures/v1/latest/tick`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (market !== undefined) {
                localVarQueryParameter['market'] = market;
            }

            if (instruments) {
                localVarQueryParameter['instruments'] = instruments.join(COLLECTION_FORMATS.csv);
            }

            if (groups) {
                localVarQueryParameter['groups'] = groups.join(COLLECTION_FORMATS.csv);
            }

            if (mappingPriority !== undefined) {
                localVarQueryParameter['mapping_priority'] = mappingPriority;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [market] The exchange to obtain data from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        futuresV1Markets: async (market?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/futures/v1/markets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (market !== undefined) {
                localVarQueryParameter['market'] = market;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [market] The exchange to obtain data from
         * @param {string} [instrument] The mapped instrument to retrieve on a specific market.
         * @param {Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>} [instrumentStatus] The status of the instrument, can be one of the following: ACTIVE, IGNORED, RETIRED, EXPIRED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        futuresV1MarketsInstruments: async (market?: string, instrument?: string, instrumentStatus?: Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/futures/v1/markets/instruments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (market !== undefined) {
                localVarQueryParameter['market'] = market;
            }

            if (instrument !== undefined) {
                localVarQueryParameter['instrument'] = instrument;
            }

            if (instrumentStatus) {
                localVarQueryParameter['instrument_status'] = instrumentStatus.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [market] The exchange to obtain data from
         * @param {string} [instrument] The unmapped instrument to retrieve on a specific market.
         * @param {Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>} [instrumentStatus] The status of the instrument, can be one of the following: ACTIVE, IGNORED, RETIRED, EXPIRED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        futuresV1MarketsInstrumentsUnmapped: async (market?: string, instrument?: string, instrumentStatus?: Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/futures/v1/markets/instruments/unmapped`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (market !== undefined) {
                localVarQueryParameter['market'] = market;
            }

            if (instrument !== undefined) {
                localVarQueryParameter['instrument'] = instrument;
            }

            if (instrumentStatus) {
                localVarQueryParameter['instrument_status'] = instrumentStatus.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,OHLC,OHLC_MESSAGE,MESSAGE,VOLUME
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexV1HistoricalDays: async (market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'market' is not null or undefined
            assertParamExists('indexV1HistoricalDays', 'market', market)
            // verify required parameter 'instrument' is not null or undefined
            assertParamExists('indexV1HistoricalDays', 'instrument', instrument)
            const localVarPath = `/index/v1/historical/days`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (market !== undefined) {
                localVarQueryParameter['market'] = market;
            }

            if (instrument !== undefined) {
                localVarQueryParameter['instrument'] = instrument;
            }

            if (groups) {
                localVarQueryParameter['groups'] = groups.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (toTs !== undefined) {
                localVarQueryParameter['to_ts'] = toTs;
            }

            if (aggregate !== undefined) {
                localVarQueryParameter['aggregate'] = aggregate;
            }

            if (fill !== undefined) {
                localVarQueryParameter['fill'] = fill;
            }

            if (mappingPriority !== undefined) {
                localVarQueryParameter['mapping_priority'] = mappingPriority;
            }

            if (responseFormat !== undefined) {
                localVarQueryParameter['response_format'] = responseFormat;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,OHLC,OHLC_MESSAGE,MESSAGE,VOLUME
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexV1HistoricalHours: async (market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'market' is not null or undefined
            assertParamExists('indexV1HistoricalHours', 'market', market)
            // verify required parameter 'instrument' is not null or undefined
            assertParamExists('indexV1HistoricalHours', 'instrument', instrument)
            const localVarPath = `/index/v1/historical/hours`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (market !== undefined) {
                localVarQueryParameter['market'] = market;
            }

            if (instrument !== undefined) {
                localVarQueryParameter['instrument'] = instrument;
            }

            if (groups) {
                localVarQueryParameter['groups'] = groups.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (toTs !== undefined) {
                localVarQueryParameter['to_ts'] = toTs;
            }

            if (aggregate !== undefined) {
                localVarQueryParameter['aggregate'] = aggregate;
            }

            if (fill !== undefined) {
                localVarQueryParameter['fill'] = fill;
            }

            if (mappingPriority !== undefined) {
                localVarQueryParameter['mapping_priority'] = mappingPriority;
            }

            if (responseFormat !== undefined) {
                localVarQueryParameter['response_format'] = responseFormat;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {number} [afterTs] Unix timestamp in seconds of the earliest index message in the response
         * @param {number} [lastCcseq] The CCSEQ of the last message seen in the previous request. Useful for pagination within messages that happened in the same second. It will look though the messages in the same second and discard all messages until it reaches the CCSEQ from the last_ccseq parameter. If the CCSEQ is not part of that second, it will discard all messages in the second and only return messages starting from the next second onwards. When starting an integration with our API, on the first request, you should either not send a value for this paramater (defaults to 0 and does not discard any messages) or send 0. After you get a response use the TIMESTAMP and CCSEQ from the last message in the response. Pass the TIMESTAMP in the after_ts parameter and the CCSEQ in the last_ccseq parameter on your next request.
         * @param {number} [limit] The maximum number of index messages to return
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {boolean} [return404OnEmptyResponse] If set to false (default) then when there are no items to return, you will get a response status code of 200 and an empty JSON array or a CSV file with just the header. If set to true then when there are no items you will get a 404 status code for both JSON and CSV response_formats.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexV1HistoricalMessages: async (market: string, instrument: string, afterTs?: number, lastCcseq?: number, limit?: number, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', return404OnEmptyResponse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'market' is not null or undefined
            assertParamExists('indexV1HistoricalMessages', 'market', market)
            // verify required parameter 'instrument' is not null or undefined
            assertParamExists('indexV1HistoricalMessages', 'instrument', instrument)
            const localVarPath = `/index/v1/historical/messages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)

            if (market !== undefined) {
                localVarQueryParameter['market'] = market;
            }

            if (instrument !== undefined) {
                localVarQueryParameter['instrument'] = instrument;
            }

            if (afterTs !== undefined) {
                localVarQueryParameter['after_ts'] = afterTs;
            }

            if (lastCcseq !== undefined) {
                localVarQueryParameter['last_ccseq'] = lastCcseq;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (mappingPriority !== undefined) {
                localVarQueryParameter['mapping_priority'] = mappingPriority;
            }

            if (responseFormat !== undefined) {
                localVarQueryParameter['response_format'] = responseFormat;
            }

            if (return404OnEmptyResponse !== undefined) {
                localVarQueryParameter['return_404_on_empty_response'] = return404OnEmptyResponse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {number} [hourTs] Unix timestamp in seconds for the hour containing the index updates you are interested in. You can pass any timestamp in the hour but we will round it down the the full hour timestmap and return all index updates in that hour.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {boolean} [return404OnEmptyResponse] If set to false (default) then when there are no items to return, you will get a response status code of 200 and an empty JSON array or a CSV file with just the header. If set to true then when there are no items you will get a 404 status code for both JSON and CSV response_formats.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexV1HistoricalMessagesHour: async (market: string, instrument: string, hourTs?: number, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', return404OnEmptyResponse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'market' is not null or undefined
            assertParamExists('indexV1HistoricalMessagesHour', 'market', market)
            // verify required parameter 'instrument' is not null or undefined
            assertParamExists('indexV1HistoricalMessagesHour', 'instrument', instrument)
            const localVarPath = `/index/v1/historical/messages/hour`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)

            if (market !== undefined) {
                localVarQueryParameter['market'] = market;
            }

            if (instrument !== undefined) {
                localVarQueryParameter['instrument'] = instrument;
            }

            if (hourTs !== undefined) {
                localVarQueryParameter['hour_ts'] = hourTs;
            }

            if (mappingPriority !== undefined) {
                localVarQueryParameter['mapping_priority'] = mappingPriority;
            }

            if (responseFormat !== undefined) {
                localVarQueryParameter['response_format'] = responseFormat;
            }

            if (return404OnEmptyResponse !== undefined) {
                localVarQueryParameter['return_404_on_empty_response'] = return404OnEmptyResponse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,OHLC,OHLC_MESSAGE,MESSAGE,VOLUME
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexV1HistoricalMinutes: async (market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'market' is not null or undefined
            assertParamExists('indexV1HistoricalMinutes', 'market', market)
            // verify required parameter 'instrument' is not null or undefined
            assertParamExists('indexV1HistoricalMinutes', 'instrument', instrument)
            const localVarPath = `/index/v1/historical/minutes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (market !== undefined) {
                localVarQueryParameter['market'] = market;
            }

            if (instrument !== undefined) {
                localVarQueryParameter['instrument'] = instrument;
            }

            if (groups) {
                localVarQueryParameter['groups'] = groups.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (toTs !== undefined) {
                localVarQueryParameter['to_ts'] = toTs;
            }

            if (aggregate !== undefined) {
                localVarQueryParameter['aggregate'] = aggregate;
            }

            if (fill !== undefined) {
                localVarQueryParameter['fill'] = fill;
            }

            if (mappingPriority !== undefined) {
                localVarQueryParameter['mapping_priority'] = mappingPriority;
            }

            if (responseFormat !== undefined) {
                localVarQueryParameter['response_format'] = responseFormat;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {Array<string>} instruments A comma separated array of mapped and/or unmapped instruments to retrieve for a specific market (you can use either the instrument XXBTZUSD or mapped instrument (base - quote) BTC-USD on kraken as an example). We first check each instrument against the mapped list and then against the unmapped list but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting metadata entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: STATUS,INTERNAL,GENERAL,MIGRATION,SOURCE
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexV1LatestInstrumentMetadata: async (market: string, instruments: Array<string>, groups?: Array<string>, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'market' is not null or undefined
            assertParamExists('indexV1LatestInstrumentMetadata', 'market', market)
            // verify required parameter 'instruments' is not null or undefined
            assertParamExists('indexV1LatestInstrumentMetadata', 'instruments', instruments)
            const localVarPath = `/index/v1/latest/instrument/metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (market !== undefined) {
                localVarQueryParameter['market'] = market;
            }

            if (instruments) {
                localVarQueryParameter['instruments'] = instruments.join(COLLECTION_FORMATS.csv);
            }

            if (groups) {
                localVarQueryParameter['groups'] = groups.join(COLLECTION_FORMATS.csv);
            }

            if (mappingPriority !== undefined) {
                localVarQueryParameter['mapping_priority'] = mappingPriority;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {Array<string>} instruments A comma separated array of mapped and/or unmapped instruments to retrieve for a specific market (you can use either the instrument XXBTZUSD or mapped instrument (base - quote) BTC-USD on kraken as an example). We first check each instrument against the mapped list and then against the unmapped list but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting tick data you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,VALUE,LAST_UPDATE,CURRENT_HOUR,CURRENT_DAY,CURRENT_WEEK,CURRENT_MONTH,CURRENT_YEAR,MOVING_24_HOUR,MOVING_7_DAY,MOVING_30_DAY,MOVING_90_DAY,MOVING_180_DAY,MOVING_365_DAY,LIFETIME
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexV1LatestTick: async (market: string, instruments: Array<string>, groups?: Array<string>, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'market' is not null or undefined
            assertParamExists('indexV1LatestTick', 'market', market)
            // verify required parameter 'instruments' is not null or undefined
            assertParamExists('indexV1LatestTick', 'instruments', instruments)
            const localVarPath = `/index/v1/latest/tick`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (market !== undefined) {
                localVarQueryParameter['market'] = market;
            }

            if (instruments) {
                localVarQueryParameter['instruments'] = instruments.join(COLLECTION_FORMATS.csv);
            }

            if (groups) {
                localVarQueryParameter['groups'] = groups.join(COLLECTION_FORMATS.csv);
            }

            if (mappingPriority !== undefined) {
                localVarQueryParameter['mapping_priority'] = mappingPriority;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [market] The exchange to obtain data from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexV1Markets: async (market?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/index/v1/markets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (market !== undefined) {
                localVarQueryParameter['market'] = market;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [market] The exchange to obtain data from
         * @param {string} [instrument] The mapped instrument to retrieve on a specific market.
         * @param {Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>} [instrumentStatus] The status of the instrument, can be one of the following: ACTIVE, IGNORED, RETIRED, EXPIRED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexV1MarketsInstruments: async (market?: string, instrument?: string, instrumentStatus?: Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/index/v1/markets/instruments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (market !== undefined) {
                localVarQueryParameter['market'] = market;
            }

            if (instrument !== undefined) {
                localVarQueryParameter['instrument'] = instrument;
            }

            if (instrumentStatus) {
                localVarQueryParameter['instrument_status'] = instrumentStatus.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [market] The exchange to obtain data from
         * @param {string} [instrument] The unmapped instrument to retrieve on a specific market.
         * @param {Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>} [instrumentStatus] The status of the instrument, can be one of the following: ACTIVE, IGNORED, RETIRED, EXPIRED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexV1MarketsInstrumentsUnmapped: async (market?: string, instrument?: string, instrumentStatus?: Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/index/v1/markets/instruments/unmapped`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (market !== undefined) {
                localVarQueryParameter['market'] = market;
            }

            if (instrument !== undefined) {
                localVarQueryParameter['instrument'] = instrument;
            }

            if (instrumentStatus) {
                localVarQueryParameter['instrument_status'] = instrumentStatus.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FuturesApi - functional programming interface
 * @export
 */
export const FuturesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FuturesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,OHLC,OHLC_TRADE,TRADE,VOLUME
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async futuresV1HistoricalDays(market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.futuresV1HistoricalDays(market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,VALUE,OHLC,OHLC_MESSAGE,MESSAGE
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async futuresV1HistoricalFundingRateDays(market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.futuresV1HistoricalFundingRateDays(market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,VALUE,OHLC,OHLC_MESSAGE,MESSAGE
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async futuresV1HistoricalFundingRateHours(market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.futuresV1HistoricalFundingRateHours(market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {number} [afterTs] Unix timestamp in seconds of the earliest funding rate message in the response
         * @param {number} [lastCcseq] The CCSEQ of the last message seen in the previous request. Useful for pagination within messages that happened in the same second. It will look though the messages in the same second and discard all messages until it reaches the CCSEQ from the last_ccseq parameter. If the CCSEQ is not part of that second, it will discard all messages in the second and only return messages starting from the next second onwards. When starting an integration with our API, on the first request, you should either not send a value for this paramater (defaults to 0 and does not discard any messages) or send 0. After you get a response use the TIMESTAMP and CCSEQ from the last message in the response. Pass the TIMESTAMP in the after_ts parameter and the CCSEQ in the last_ccseq parameter on your next request.
         * @param {number} [limit] The maximum number of funding rate messages to return
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {boolean} [return404OnEmptyResponse] If set to false (default) then when there are no items to return, you will get a response status code of 200 and an empty JSON array or a CSV file with just the header. If set to true then when there are no items you will get a 404 status code for both JSON and CSV response_formats.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async futuresV1HistoricalFundingRateMessages(market: string, instrument: string, afterTs?: number, lastCcseq?: number, limit?: number, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', return404OnEmptyResponse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.futuresV1HistoricalFundingRateMessages(market, instrument, afterTs, lastCcseq, limit, mappingPriority, responseFormat, return404OnEmptyResponse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {number} [hourTs] Unix timestamp in seconds for the hour containing the funding rate updates you are interested in. You can pass any timestamp in the hour but we will round it down the the full hour timestmap and return all funding rate updates in that hour.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {boolean} [return404OnEmptyResponse] If set to false (default) then when there are no items to return, you will get a response status code of 200 and an empty JSON array or a CSV file with just the header. If set to true then when there are no items you will get a 404 status code for both JSON and CSV response_formats.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async futuresV1HistoricalFundingRateMessagesHour(market: string, instrument: string, hourTs?: number, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', return404OnEmptyResponse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.futuresV1HistoricalFundingRateMessagesHour(market, instrument, hourTs, mappingPriority, responseFormat, return404OnEmptyResponse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,VALUE,OHLC,OHLC_MESSAGE,MESSAGE
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async futuresV1HistoricalFundingRateMinutes(market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.futuresV1HistoricalFundingRateMinutes(market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,OHLC,OHLC_TRADE,TRADE,VOLUME
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async futuresV1HistoricalHours(market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.futuresV1HistoricalHours(market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,OHLC,OHLC_TRADE,TRADE,VOLUME
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async futuresV1HistoricalMinutes(market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.futuresV1HistoricalMinutes(market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,OHLC,OHLC_MESSAGE,MESSAGE
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async futuresV1HistoricalOpenInterestDays(market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.futuresV1HistoricalOpenInterestDays(market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,OHLC,OHLC_MESSAGE,MESSAGE
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async futuresV1HistoricalOpenInterestHours(market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.futuresV1HistoricalOpenInterestHours(market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {number} [afterTs] Unix timestamp in seconds of the earliest open interest message in the response
         * @param {number} [lastCcseq] The CCSEQ of the last message seen in the previous request. Useful for pagination within messages that happened in the same second. It will look though the messages in the same second and discard all messages until it reaches the CCSEQ from the last_ccseq parameter. If the CCSEQ is not part of that second, it will discard all messages in the second and only return messages starting from the next second onwards. When starting an integration with our API, on the first request, you should either not send a value for this paramater (defaults to 0 and does not discard any messages) or send 0. After you get a response use the TIMESTAMP and CCSEQ from the last message in the response. Pass the TIMESTAMP in the after_ts parameter and the CCSEQ in the last_ccseq parameter on your next request.
         * @param {number} [limit] The maximum number of open interest messages to return
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {boolean} [return404OnEmptyResponse] If set to false (default) then when there are no items to return, you will get a response status code of 200 and an empty JSON array or a CSV file with just the header. If set to true then when there are no items you will get a 404 status code for both JSON and CSV response_formats.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async futuresV1HistoricalOpenInterestMessages(market: string, instrument: string, afterTs?: number, lastCcseq?: number, limit?: number, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', return404OnEmptyResponse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.futuresV1HistoricalOpenInterestMessages(market, instrument, afterTs, lastCcseq, limit, mappingPriority, responseFormat, return404OnEmptyResponse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {number} [hourTs] Unix timestamp in seconds for the hour containing the open interest updates you are interested in. You can pass any timestamp in the hour but we will round it down the the full hour timestmap and return all open interest updates in that hour.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {boolean} [return404OnEmptyResponse] If set to false (default) then when there are no items to return, you will get a response status code of 200 and an empty JSON array or a CSV file with just the header. If set to true then when there are no items you will get a 404 status code for both JSON and CSV response_formats.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async futuresV1HistoricalOpenInterestMessagesHour(market: string, instrument: string, hourTs?: number, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', return404OnEmptyResponse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.futuresV1HistoricalOpenInterestMessagesHour(market, instrument, hourTs, mappingPriority, responseFormat, return404OnEmptyResponse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,OHLC,OHLC_MESSAGE,MESSAGE
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async futuresV1HistoricalOpenInterestMinutes(market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.futuresV1HistoricalOpenInterestMinutes(market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {number} [afterTs] Unix timestamp in seconds of the earliest trade in the response.
         * @param {number} [lastCcseq] The CCSEQ of the last message seen in the previous request. Useful for pagination within messages that happened in the same second. It will look though the messages in the same second and discard all messages until it reaches the CCSEQ from the last_ccseq parameter. If the CCSEQ is not part of that second, it will discard all messages in the second and only return messages starting from the next second onwards. When starting an integration with our API, on the first request, you should either not send a value for this paramater (defaults to 0 and does not discard any messages) or send 0. After you get a response use the TIMESTAMP and CCSEQ from the last message in the response. Pass the TIMESTAMP in the after_ts parameter and the CCSEQ in the last_ccseq parameter on your next request.
         * @param {number} [limit] The maximum number of trades to return
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {boolean} [return404OnEmptyResponse] If set to false (default) then when there are no items to return, you will get a response status code of 200 and an empty JSON array or a CSV file with just the header. If set to true then when there are no items you will get a 404 status code for both JSON and CSV response_formats.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async futuresV1HistoricalTrades(market: string, instrument: string, afterTs?: number, lastCcseq?: number, limit?: number, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', return404OnEmptyResponse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.futuresV1HistoricalTrades(market, instrument, afterTs, lastCcseq, limit, mappingPriority, responseFormat, return404OnEmptyResponse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {number} [hourTs] Unix timestamp in seconds for the hour containing the trades you are interested in. You can pass any timestamp within an hour but we will round it down the the full hour timestmap and return all trades in that hour.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {boolean} [return404OnEmptyResponse] If set to false (default) then when there are no items to return, you will get a response status code of 200 and an empty JSON array or a CSV file with just the header. If set to true then when there are no items you will get a 404 status code for both JSON and CSV response_formats.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async futuresV1HistoricalTradesHour(market: string, instrument: string, hourTs?: number, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', return404OnEmptyResponse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.futuresV1HistoricalTradesHour(market, instrument, hourTs, mappingPriority, responseFormat, return404OnEmptyResponse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {Array<string>} instruments A comma separated array of mapped and/or unmapped instruments to retrieve for a specific market (you can use either the instrument XXBTZUSD or mapped instrument (base - quote) BTC-USD on kraken as an example). We first check each instrument against the mapped list and then against the unmapped list but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting tick data you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,VALUE,LAST_UPDATE,CURRENT_HOUR,CURRENT_DAY,CURRENT_WEEK,CURRENT_MONTH,CURRENT_YEAR,MOVING_24_HOUR,MOVING_7_DAY,MOVING_30_DAY,MOVING_90_DAY,MOVING_180_DAY,MOVING_365_DAY,LIFETIME
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async futuresV1LatestFundingRateTick(market: string, instruments: Array<string>, groups?: Array<string>, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.futuresV1LatestFundingRateTick(market, instruments, groups, mappingPriority, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {Array<string>} instruments A comma separated array of mapped and/or unmapped instruments to retrieve for a specific market (you can use either the instrument XXBTZUSD or mapped instrument (base - quote) BTC-USD on kraken as an example). We first check each instrument against the mapped list and then against the unmapped list but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting metadata entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: STATUS,INTERNAL,GENERAL,MIGRATION,SOURCE
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async futuresV1LatestInstrumentMetadata(market: string, instruments: Array<string>, groups?: Array<string>, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.futuresV1LatestInstrumentMetadata(market, instruments, groups, mappingPriority, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {Array<string>} instruments A comma separated array of mapped and/or unmapped instruments to retrieve for a specific market (you can use either the instrument XXBTZUSD or mapped instrument (base - quote) BTC-USD on kraken as an example). We first check each instrument against the mapped list and then against the unmapped list but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting tick data you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,VALUE,LAST_UPDATE,CURRENT_HOUR,CURRENT_DAY,CURRENT_WEEK,CURRENT_MONTH,CURRENT_YEAR,MOVING_24_HOUR,MOVING_7_DAY,MOVING_30_DAY,MOVING_90_DAY,MOVING_180_DAY,MOVING_365_DAY,LIFETIME
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async futuresV1LatestOpenInterestTick(market: string, instruments: Array<string>, groups?: Array<string>, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.futuresV1LatestOpenInterestTick(market, instruments, groups, mappingPriority, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {Array<string>} instruments A comma separated array of mapped and/or unmapped instruments to retrieve for a specific market (you can use either the instrument XXBTZUSD or mapped instrument (base - quote) BTC-USD on kraken as an example). We first check each instrument against the mapped list and then against the unmapped list but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting tick data you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,VALUE,LAST_UPDATE,TOP_OF_BOOK,CURRENT_HOUR,CURRENT_DAY,CURRENT_WEEK,CURRENT_MONTH,CURRENT_YEAR,MOVING_24_HOUR,MOVING_7_DAY,MOVING_30_DAY,MOVING_90_DAY,MOVING_180_DAY,MOVING_365_DAY,LIFETIME
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async futuresV1LatestTick(market: string, instruments: Array<string>, groups?: Array<string>, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.futuresV1LatestTick(market, instruments, groups, mappingPriority, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [market] The exchange to obtain data from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async futuresV1Markets(market?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.futuresV1Markets(market, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [market] The exchange to obtain data from
         * @param {string} [instrument] The mapped instrument to retrieve on a specific market.
         * @param {Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>} [instrumentStatus] The status of the instrument, can be one of the following: ACTIVE, IGNORED, RETIRED, EXPIRED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async futuresV1MarketsInstruments(market?: string, instrument?: string, instrumentStatus?: Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.futuresV1MarketsInstruments(market, instrument, instrumentStatus, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [market] The exchange to obtain data from
         * @param {string} [instrument] The unmapped instrument to retrieve on a specific market.
         * @param {Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>} [instrumentStatus] The status of the instrument, can be one of the following: ACTIVE, IGNORED, RETIRED, EXPIRED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async futuresV1MarketsInstrumentsUnmapped(market?: string, instrument?: string, instrumentStatus?: Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.futuresV1MarketsInstrumentsUnmapped(market, instrument, instrumentStatus, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,OHLC,OHLC_MESSAGE,MESSAGE,VOLUME
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async indexV1HistoricalDays(market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.indexV1HistoricalDays(market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,OHLC,OHLC_MESSAGE,MESSAGE,VOLUME
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async indexV1HistoricalHours(market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.indexV1HistoricalHours(market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {number} [afterTs] Unix timestamp in seconds of the earliest index message in the response
         * @param {number} [lastCcseq] The CCSEQ of the last message seen in the previous request. Useful for pagination within messages that happened in the same second. It will look though the messages in the same second and discard all messages until it reaches the CCSEQ from the last_ccseq parameter. If the CCSEQ is not part of that second, it will discard all messages in the second and only return messages starting from the next second onwards. When starting an integration with our API, on the first request, you should either not send a value for this paramater (defaults to 0 and does not discard any messages) or send 0. After you get a response use the TIMESTAMP and CCSEQ from the last message in the response. Pass the TIMESTAMP in the after_ts parameter and the CCSEQ in the last_ccseq parameter on your next request.
         * @param {number} [limit] The maximum number of index messages to return
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {boolean} [return404OnEmptyResponse] If set to false (default) then when there are no items to return, you will get a response status code of 200 and an empty JSON array or a CSV file with just the header. If set to true then when there are no items you will get a 404 status code for both JSON and CSV response_formats.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async indexV1HistoricalMessages(market: string, instrument: string, afterTs?: number, lastCcseq?: number, limit?: number, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', return404OnEmptyResponse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.indexV1HistoricalMessages(market, instrument, afterTs, lastCcseq, limit, mappingPriority, responseFormat, return404OnEmptyResponse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {number} [hourTs] Unix timestamp in seconds for the hour containing the index updates you are interested in. You can pass any timestamp in the hour but we will round it down the the full hour timestmap and return all index updates in that hour.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {boolean} [return404OnEmptyResponse] If set to false (default) then when there are no items to return, you will get a response status code of 200 and an empty JSON array or a CSV file with just the header. If set to true then when there are no items you will get a 404 status code for both JSON and CSV response_formats.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async indexV1HistoricalMessagesHour(market: string, instrument: string, hourTs?: number, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', return404OnEmptyResponse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.indexV1HistoricalMessagesHour(market, instrument, hourTs, mappingPriority, responseFormat, return404OnEmptyResponse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,OHLC,OHLC_MESSAGE,MESSAGE,VOLUME
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async indexV1HistoricalMinutes(market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.indexV1HistoricalMinutes(market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {Array<string>} instruments A comma separated array of mapped and/or unmapped instruments to retrieve for a specific market (you can use either the instrument XXBTZUSD or mapped instrument (base - quote) BTC-USD on kraken as an example). We first check each instrument against the mapped list and then against the unmapped list but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting metadata entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: STATUS,INTERNAL,GENERAL,MIGRATION,SOURCE
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async indexV1LatestInstrumentMetadata(market: string, instruments: Array<string>, groups?: Array<string>, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.indexV1LatestInstrumentMetadata(market, instruments, groups, mappingPriority, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {Array<string>} instruments A comma separated array of mapped and/or unmapped instruments to retrieve for a specific market (you can use either the instrument XXBTZUSD or mapped instrument (base - quote) BTC-USD on kraken as an example). We first check each instrument against the mapped list and then against the unmapped list but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting tick data you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,VALUE,LAST_UPDATE,CURRENT_HOUR,CURRENT_DAY,CURRENT_WEEK,CURRENT_MONTH,CURRENT_YEAR,MOVING_24_HOUR,MOVING_7_DAY,MOVING_30_DAY,MOVING_90_DAY,MOVING_180_DAY,MOVING_365_DAY,LIFETIME
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async indexV1LatestTick(market: string, instruments: Array<string>, groups?: Array<string>, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.indexV1LatestTick(market, instruments, groups, mappingPriority, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [market] The exchange to obtain data from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async indexV1Markets(market?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.indexV1Markets(market, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [market] The exchange to obtain data from
         * @param {string} [instrument] The mapped instrument to retrieve on a specific market.
         * @param {Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>} [instrumentStatus] The status of the instrument, can be one of the following: ACTIVE, IGNORED, RETIRED, EXPIRED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async indexV1MarketsInstruments(market?: string, instrument?: string, instrumentStatus?: Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.indexV1MarketsInstruments(market, instrument, instrumentStatus, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [market] The exchange to obtain data from
         * @param {string} [instrument] The unmapped instrument to retrieve on a specific market.
         * @param {Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>} [instrumentStatus] The status of the instrument, can be one of the following: ACTIVE, IGNORED, RETIRED, EXPIRED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async indexV1MarketsInstrumentsUnmapped(market?: string, instrument?: string, instrumentStatus?: Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.indexV1MarketsInstrumentsUnmapped(market, instrument, instrumentStatus, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FuturesApi - factory interface
 * @export
 */
export const FuturesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FuturesApiFp(configuration)
    return {
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,OHLC,OHLC_TRADE,TRADE,VOLUME
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        futuresV1HistoricalDays(market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.futuresV1HistoricalDays(market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,VALUE,OHLC,OHLC_MESSAGE,MESSAGE
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        futuresV1HistoricalFundingRateDays(market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.futuresV1HistoricalFundingRateDays(market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,VALUE,OHLC,OHLC_MESSAGE,MESSAGE
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        futuresV1HistoricalFundingRateHours(market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.futuresV1HistoricalFundingRateHours(market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {number} [afterTs] Unix timestamp in seconds of the earliest funding rate message in the response
         * @param {number} [lastCcseq] The CCSEQ of the last message seen in the previous request. Useful for pagination within messages that happened in the same second. It will look though the messages in the same second and discard all messages until it reaches the CCSEQ from the last_ccseq parameter. If the CCSEQ is not part of that second, it will discard all messages in the second and only return messages starting from the next second onwards. When starting an integration with our API, on the first request, you should either not send a value for this paramater (defaults to 0 and does not discard any messages) or send 0. After you get a response use the TIMESTAMP and CCSEQ from the last message in the response. Pass the TIMESTAMP in the after_ts parameter and the CCSEQ in the last_ccseq parameter on your next request.
         * @param {number} [limit] The maximum number of funding rate messages to return
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {boolean} [return404OnEmptyResponse] If set to false (default) then when there are no items to return, you will get a response status code of 200 and an empty JSON array or a CSV file with just the header. If set to true then when there are no items you will get a 404 status code for both JSON and CSV response_formats.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        futuresV1HistoricalFundingRateMessages(market: string, instrument: string, afterTs?: number, lastCcseq?: number, limit?: number, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', return404OnEmptyResponse?: boolean, options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.futuresV1HistoricalFundingRateMessages(market, instrument, afterTs, lastCcseq, limit, mappingPriority, responseFormat, return404OnEmptyResponse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {number} [hourTs] Unix timestamp in seconds for the hour containing the funding rate updates you are interested in. You can pass any timestamp in the hour but we will round it down the the full hour timestmap and return all funding rate updates in that hour.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {boolean} [return404OnEmptyResponse] If set to false (default) then when there are no items to return, you will get a response status code of 200 and an empty JSON array or a CSV file with just the header. If set to true then when there are no items you will get a 404 status code for both JSON and CSV response_formats.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        futuresV1HistoricalFundingRateMessagesHour(market: string, instrument: string, hourTs?: number, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', return404OnEmptyResponse?: boolean, options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.futuresV1HistoricalFundingRateMessagesHour(market, instrument, hourTs, mappingPriority, responseFormat, return404OnEmptyResponse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,VALUE,OHLC,OHLC_MESSAGE,MESSAGE
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        futuresV1HistoricalFundingRateMinutes(market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.futuresV1HistoricalFundingRateMinutes(market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,OHLC,OHLC_TRADE,TRADE,VOLUME
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        futuresV1HistoricalHours(market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.futuresV1HistoricalHours(market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,OHLC,OHLC_TRADE,TRADE,VOLUME
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        futuresV1HistoricalMinutes(market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.futuresV1HistoricalMinutes(market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,OHLC,OHLC_MESSAGE,MESSAGE
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        futuresV1HistoricalOpenInterestDays(market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.futuresV1HistoricalOpenInterestDays(market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,OHLC,OHLC_MESSAGE,MESSAGE
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        futuresV1HistoricalOpenInterestHours(market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.futuresV1HistoricalOpenInterestHours(market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {number} [afterTs] Unix timestamp in seconds of the earliest open interest message in the response
         * @param {number} [lastCcseq] The CCSEQ of the last message seen in the previous request. Useful for pagination within messages that happened in the same second. It will look though the messages in the same second and discard all messages until it reaches the CCSEQ from the last_ccseq parameter. If the CCSEQ is not part of that second, it will discard all messages in the second and only return messages starting from the next second onwards. When starting an integration with our API, on the first request, you should either not send a value for this paramater (defaults to 0 and does not discard any messages) or send 0. After you get a response use the TIMESTAMP and CCSEQ from the last message in the response. Pass the TIMESTAMP in the after_ts parameter and the CCSEQ in the last_ccseq parameter on your next request.
         * @param {number} [limit] The maximum number of open interest messages to return
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {boolean} [return404OnEmptyResponse] If set to false (default) then when there are no items to return, you will get a response status code of 200 and an empty JSON array or a CSV file with just the header. If set to true then when there are no items you will get a 404 status code for both JSON and CSV response_formats.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        futuresV1HistoricalOpenInterestMessages(market: string, instrument: string, afterTs?: number, lastCcseq?: number, limit?: number, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', return404OnEmptyResponse?: boolean, options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.futuresV1HistoricalOpenInterestMessages(market, instrument, afterTs, lastCcseq, limit, mappingPriority, responseFormat, return404OnEmptyResponse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {number} [hourTs] Unix timestamp in seconds for the hour containing the open interest updates you are interested in. You can pass any timestamp in the hour but we will round it down the the full hour timestmap and return all open interest updates in that hour.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {boolean} [return404OnEmptyResponse] If set to false (default) then when there are no items to return, you will get a response status code of 200 and an empty JSON array or a CSV file with just the header. If set to true then when there are no items you will get a 404 status code for both JSON and CSV response_formats.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        futuresV1HistoricalOpenInterestMessagesHour(market: string, instrument: string, hourTs?: number, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', return404OnEmptyResponse?: boolean, options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.futuresV1HistoricalOpenInterestMessagesHour(market, instrument, hourTs, mappingPriority, responseFormat, return404OnEmptyResponse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,OHLC,OHLC_MESSAGE,MESSAGE
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        futuresV1HistoricalOpenInterestMinutes(market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.futuresV1HistoricalOpenInterestMinutes(market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {number} [afterTs] Unix timestamp in seconds of the earliest trade in the response.
         * @param {number} [lastCcseq] The CCSEQ of the last message seen in the previous request. Useful for pagination within messages that happened in the same second. It will look though the messages in the same second and discard all messages until it reaches the CCSEQ from the last_ccseq parameter. If the CCSEQ is not part of that second, it will discard all messages in the second and only return messages starting from the next second onwards. When starting an integration with our API, on the first request, you should either not send a value for this paramater (defaults to 0 and does not discard any messages) or send 0. After you get a response use the TIMESTAMP and CCSEQ from the last message in the response. Pass the TIMESTAMP in the after_ts parameter and the CCSEQ in the last_ccseq parameter on your next request.
         * @param {number} [limit] The maximum number of trades to return
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {boolean} [return404OnEmptyResponse] If set to false (default) then when there are no items to return, you will get a response status code of 200 and an empty JSON array or a CSV file with just the header. If set to true then when there are no items you will get a 404 status code for both JSON and CSV response_formats.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        futuresV1HistoricalTrades(market: string, instrument: string, afterTs?: number, lastCcseq?: number, limit?: number, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', return404OnEmptyResponse?: boolean, options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.futuresV1HistoricalTrades(market, instrument, afterTs, lastCcseq, limit, mappingPriority, responseFormat, return404OnEmptyResponse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {number} [hourTs] Unix timestamp in seconds for the hour containing the trades you are interested in. You can pass any timestamp within an hour but we will round it down the the full hour timestmap and return all trades in that hour.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {boolean} [return404OnEmptyResponse] If set to false (default) then when there are no items to return, you will get a response status code of 200 and an empty JSON array or a CSV file with just the header. If set to true then when there are no items you will get a 404 status code for both JSON and CSV response_formats.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        futuresV1HistoricalTradesHour(market: string, instrument: string, hourTs?: number, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', return404OnEmptyResponse?: boolean, options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.futuresV1HistoricalTradesHour(market, instrument, hourTs, mappingPriority, responseFormat, return404OnEmptyResponse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {Array<string>} instruments A comma separated array of mapped and/or unmapped instruments to retrieve for a specific market (you can use either the instrument XXBTZUSD or mapped instrument (base - quote) BTC-USD on kraken as an example). We first check each instrument against the mapped list and then against the unmapped list but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting tick data you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,VALUE,LAST_UPDATE,CURRENT_HOUR,CURRENT_DAY,CURRENT_WEEK,CURRENT_MONTH,CURRENT_YEAR,MOVING_24_HOUR,MOVING_7_DAY,MOVING_30_DAY,MOVING_90_DAY,MOVING_180_DAY,MOVING_365_DAY,LIFETIME
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        futuresV1LatestFundingRateTick(market: string, instruments: Array<string>, groups?: Array<string>, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.futuresV1LatestFundingRateTick(market, instruments, groups, mappingPriority, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {Array<string>} instruments A comma separated array of mapped and/or unmapped instruments to retrieve for a specific market (you can use either the instrument XXBTZUSD or mapped instrument (base - quote) BTC-USD on kraken as an example). We first check each instrument against the mapped list and then against the unmapped list but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting metadata entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: STATUS,INTERNAL,GENERAL,MIGRATION,SOURCE
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        futuresV1LatestInstrumentMetadata(market: string, instruments: Array<string>, groups?: Array<string>, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.futuresV1LatestInstrumentMetadata(market, instruments, groups, mappingPriority, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {Array<string>} instruments A comma separated array of mapped and/or unmapped instruments to retrieve for a specific market (you can use either the instrument XXBTZUSD or mapped instrument (base - quote) BTC-USD on kraken as an example). We first check each instrument against the mapped list and then against the unmapped list but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting tick data you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,VALUE,LAST_UPDATE,CURRENT_HOUR,CURRENT_DAY,CURRENT_WEEK,CURRENT_MONTH,CURRENT_YEAR,MOVING_24_HOUR,MOVING_7_DAY,MOVING_30_DAY,MOVING_90_DAY,MOVING_180_DAY,MOVING_365_DAY,LIFETIME
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        futuresV1LatestOpenInterestTick(market: string, instruments: Array<string>, groups?: Array<string>, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.futuresV1LatestOpenInterestTick(market, instruments, groups, mappingPriority, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {Array<string>} instruments A comma separated array of mapped and/or unmapped instruments to retrieve for a specific market (you can use either the instrument XXBTZUSD or mapped instrument (base - quote) BTC-USD on kraken as an example). We first check each instrument against the mapped list and then against the unmapped list but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting tick data you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,VALUE,LAST_UPDATE,TOP_OF_BOOK,CURRENT_HOUR,CURRENT_DAY,CURRENT_WEEK,CURRENT_MONTH,CURRENT_YEAR,MOVING_24_HOUR,MOVING_7_DAY,MOVING_30_DAY,MOVING_90_DAY,MOVING_180_DAY,MOVING_365_DAY,LIFETIME
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        futuresV1LatestTick(market: string, instruments: Array<string>, groups?: Array<string>, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.futuresV1LatestTick(market, instruments, groups, mappingPriority, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [market] The exchange to obtain data from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        futuresV1Markets(market?: string, options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.futuresV1Markets(market, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [market] The exchange to obtain data from
         * @param {string} [instrument] The mapped instrument to retrieve on a specific market.
         * @param {Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>} [instrumentStatus] The status of the instrument, can be one of the following: ACTIVE, IGNORED, RETIRED, EXPIRED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        futuresV1MarketsInstruments(market?: string, instrument?: string, instrumentStatus?: Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>, options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.futuresV1MarketsInstruments(market, instrument, instrumentStatus, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [market] The exchange to obtain data from
         * @param {string} [instrument] The unmapped instrument to retrieve on a specific market.
         * @param {Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>} [instrumentStatus] The status of the instrument, can be one of the following: ACTIVE, IGNORED, RETIRED, EXPIRED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        futuresV1MarketsInstrumentsUnmapped(market?: string, instrument?: string, instrumentStatus?: Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>, options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.futuresV1MarketsInstrumentsUnmapped(market, instrument, instrumentStatus, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,OHLC,OHLC_MESSAGE,MESSAGE,VOLUME
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexV1HistoricalDays(market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.indexV1HistoricalDays(market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,OHLC,OHLC_MESSAGE,MESSAGE,VOLUME
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexV1HistoricalHours(market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.indexV1HistoricalHours(market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {number} [afterTs] Unix timestamp in seconds of the earliest index message in the response
         * @param {number} [lastCcseq] The CCSEQ of the last message seen in the previous request. Useful for pagination within messages that happened in the same second. It will look though the messages in the same second and discard all messages until it reaches the CCSEQ from the last_ccseq parameter. If the CCSEQ is not part of that second, it will discard all messages in the second and only return messages starting from the next second onwards. When starting an integration with our API, on the first request, you should either not send a value for this paramater (defaults to 0 and does not discard any messages) or send 0. After you get a response use the TIMESTAMP and CCSEQ from the last message in the response. Pass the TIMESTAMP in the after_ts parameter and the CCSEQ in the last_ccseq parameter on your next request.
         * @param {number} [limit] The maximum number of index messages to return
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {boolean} [return404OnEmptyResponse] If set to false (default) then when there are no items to return, you will get a response status code of 200 and an empty JSON array or a CSV file with just the header. If set to true then when there are no items you will get a 404 status code for both JSON and CSV response_formats.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexV1HistoricalMessages(market: string, instrument: string, afterTs?: number, lastCcseq?: number, limit?: number, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', return404OnEmptyResponse?: boolean, options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.indexV1HistoricalMessages(market, instrument, afterTs, lastCcseq, limit, mappingPriority, responseFormat, return404OnEmptyResponse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {number} [hourTs] Unix timestamp in seconds for the hour containing the index updates you are interested in. You can pass any timestamp in the hour but we will round it down the the full hour timestmap and return all index updates in that hour.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {boolean} [return404OnEmptyResponse] If set to false (default) then when there are no items to return, you will get a response status code of 200 and an empty JSON array or a CSV file with just the header. If set to true then when there are no items you will get a 404 status code for both JSON and CSV response_formats.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexV1HistoricalMessagesHour(market: string, instrument: string, hourTs?: number, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', return404OnEmptyResponse?: boolean, options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.indexV1HistoricalMessagesHour(market, instrument, hourTs, mappingPriority, responseFormat, return404OnEmptyResponse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,OHLC,OHLC_MESSAGE,MESSAGE,VOLUME
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexV1HistoricalMinutes(market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.indexV1HistoricalMinutes(market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {Array<string>} instruments A comma separated array of mapped and/or unmapped instruments to retrieve for a specific market (you can use either the instrument XXBTZUSD or mapped instrument (base - quote) BTC-USD on kraken as an example). We first check each instrument against the mapped list and then against the unmapped list but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting metadata entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: STATUS,INTERNAL,GENERAL,MIGRATION,SOURCE
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexV1LatestInstrumentMetadata(market: string, instruments: Array<string>, groups?: Array<string>, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.indexV1LatestInstrumentMetadata(market, instruments, groups, mappingPriority, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {Array<string>} instruments A comma separated array of mapped and/or unmapped instruments to retrieve for a specific market (you can use either the instrument XXBTZUSD or mapped instrument (base - quote) BTC-USD on kraken as an example). We first check each instrument against the mapped list and then against the unmapped list but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting tick data you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,VALUE,LAST_UPDATE,CURRENT_HOUR,CURRENT_DAY,CURRENT_WEEK,CURRENT_MONTH,CURRENT_YEAR,MOVING_24_HOUR,MOVING_7_DAY,MOVING_30_DAY,MOVING_90_DAY,MOVING_180_DAY,MOVING_365_DAY,LIFETIME
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexV1LatestTick(market: string, instruments: Array<string>, groups?: Array<string>, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.indexV1LatestTick(market, instruments, groups, mappingPriority, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [market] The exchange to obtain data from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexV1Markets(market?: string, options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.indexV1Markets(market, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [market] The exchange to obtain data from
         * @param {string} [instrument] The mapped instrument to retrieve on a specific market.
         * @param {Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>} [instrumentStatus] The status of the instrument, can be one of the following: ACTIVE, IGNORED, RETIRED, EXPIRED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexV1MarketsInstruments(market?: string, instrument?: string, instrumentStatus?: Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>, options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.indexV1MarketsInstruments(market, instrument, instrumentStatus, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [market] The exchange to obtain data from
         * @param {string} [instrument] The unmapped instrument to retrieve on a specific market.
         * @param {Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>} [instrumentStatus] The status of the instrument, can be one of the following: ACTIVE, IGNORED, RETIRED, EXPIRED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexV1MarketsInstrumentsUnmapped(market?: string, instrument?: string, instrumentStatus?: Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>, options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.indexV1MarketsInstrumentsUnmapped(market, instrument, instrumentStatus, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FuturesApi - object-oriented interface
 * @export
 * @class FuturesApi
 * @extends {BaseAPI}
 */
export class FuturesApi extends BaseAPI {
    /**
     * 
     * @param {string} market The exchange to obtain data from
     * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
     * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,OHLC,OHLC_TRADE,TRADE,VOLUME
     * @param {number} [limit] The number of data points to return
     * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
     * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
     * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
     * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
     * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public futuresV1HistoricalDays(market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options?: AxiosRequestConfig) {
        return FuturesApiFp(this.configuration).futuresV1HistoricalDays(market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} market The exchange to obtain data from
     * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
     * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,VALUE,OHLC,OHLC_MESSAGE,MESSAGE
     * @param {number} [limit] The number of data points to return
     * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
     * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
     * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
     * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
     * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public futuresV1HistoricalFundingRateDays(market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options?: AxiosRequestConfig) {
        return FuturesApiFp(this.configuration).futuresV1HistoricalFundingRateDays(market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} market The exchange to obtain data from
     * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
     * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,VALUE,OHLC,OHLC_MESSAGE,MESSAGE
     * @param {number} [limit] The number of data points to return
     * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
     * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
     * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
     * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
     * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public futuresV1HistoricalFundingRateHours(market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options?: AxiosRequestConfig) {
        return FuturesApiFp(this.configuration).futuresV1HistoricalFundingRateHours(market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} market The exchange to obtain data from
     * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
     * @param {number} [afterTs] Unix timestamp in seconds of the earliest funding rate message in the response
     * @param {number} [lastCcseq] The CCSEQ of the last message seen in the previous request. Useful for pagination within messages that happened in the same second. It will look though the messages in the same second and discard all messages until it reaches the CCSEQ from the last_ccseq parameter. If the CCSEQ is not part of that second, it will discard all messages in the second and only return messages starting from the next second onwards. When starting an integration with our API, on the first request, you should either not send a value for this paramater (defaults to 0 and does not discard any messages) or send 0. After you get a response use the TIMESTAMP and CCSEQ from the last message in the response. Pass the TIMESTAMP in the after_ts parameter and the CCSEQ in the last_ccseq parameter on your next request.
     * @param {number} [limit] The maximum number of funding rate messages to return
     * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
     * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
     * @param {boolean} [return404OnEmptyResponse] If set to false (default) then when there are no items to return, you will get a response status code of 200 and an empty JSON array or a CSV file with just the header. If set to true then when there are no items you will get a 404 status code for both JSON and CSV response_formats.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public futuresV1HistoricalFundingRateMessages(market: string, instrument: string, afterTs?: number, lastCcseq?: number, limit?: number, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', return404OnEmptyResponse?: boolean, options?: AxiosRequestConfig) {
        return FuturesApiFp(this.configuration).futuresV1HistoricalFundingRateMessages(market, instrument, afterTs, lastCcseq, limit, mappingPriority, responseFormat, return404OnEmptyResponse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} market The exchange to obtain data from
     * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
     * @param {number} [hourTs] Unix timestamp in seconds for the hour containing the funding rate updates you are interested in. You can pass any timestamp in the hour but we will round it down the the full hour timestmap and return all funding rate updates in that hour.
     * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
     * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
     * @param {boolean} [return404OnEmptyResponse] If set to false (default) then when there are no items to return, you will get a response status code of 200 and an empty JSON array or a CSV file with just the header. If set to true then when there are no items you will get a 404 status code for both JSON and CSV response_formats.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public futuresV1HistoricalFundingRateMessagesHour(market: string, instrument: string, hourTs?: number, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', return404OnEmptyResponse?: boolean, options?: AxiosRequestConfig) {
        return FuturesApiFp(this.configuration).futuresV1HistoricalFundingRateMessagesHour(market, instrument, hourTs, mappingPriority, responseFormat, return404OnEmptyResponse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} market The exchange to obtain data from
     * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
     * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,VALUE,OHLC,OHLC_MESSAGE,MESSAGE
     * @param {number} [limit] The number of data points to return
     * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
     * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
     * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
     * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
     * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public futuresV1HistoricalFundingRateMinutes(market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options?: AxiosRequestConfig) {
        return FuturesApiFp(this.configuration).futuresV1HistoricalFundingRateMinutes(market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} market The exchange to obtain data from
     * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
     * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,OHLC,OHLC_TRADE,TRADE,VOLUME
     * @param {number} [limit] The number of data points to return
     * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
     * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
     * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
     * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
     * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public futuresV1HistoricalHours(market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options?: AxiosRequestConfig) {
        return FuturesApiFp(this.configuration).futuresV1HistoricalHours(market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} market The exchange to obtain data from
     * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
     * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,OHLC,OHLC_TRADE,TRADE,VOLUME
     * @param {number} [limit] The number of data points to return
     * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
     * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
     * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
     * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
     * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public futuresV1HistoricalMinutes(market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options?: AxiosRequestConfig) {
        return FuturesApiFp(this.configuration).futuresV1HistoricalMinutes(market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} market The exchange to obtain data from
     * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
     * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,OHLC,OHLC_MESSAGE,MESSAGE
     * @param {number} [limit] The number of data points to return
     * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
     * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
     * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
     * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
     * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public futuresV1HistoricalOpenInterestDays(market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options?: AxiosRequestConfig) {
        return FuturesApiFp(this.configuration).futuresV1HistoricalOpenInterestDays(market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} market The exchange to obtain data from
     * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
     * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,OHLC,OHLC_MESSAGE,MESSAGE
     * @param {number} [limit] The number of data points to return
     * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
     * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
     * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
     * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
     * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public futuresV1HistoricalOpenInterestHours(market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options?: AxiosRequestConfig) {
        return FuturesApiFp(this.configuration).futuresV1HistoricalOpenInterestHours(market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} market The exchange to obtain data from
     * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
     * @param {number} [afterTs] Unix timestamp in seconds of the earliest open interest message in the response
     * @param {number} [lastCcseq] The CCSEQ of the last message seen in the previous request. Useful for pagination within messages that happened in the same second. It will look though the messages in the same second and discard all messages until it reaches the CCSEQ from the last_ccseq parameter. If the CCSEQ is not part of that second, it will discard all messages in the second and only return messages starting from the next second onwards. When starting an integration with our API, on the first request, you should either not send a value for this paramater (defaults to 0 and does not discard any messages) or send 0. After you get a response use the TIMESTAMP and CCSEQ from the last message in the response. Pass the TIMESTAMP in the after_ts parameter and the CCSEQ in the last_ccseq parameter on your next request.
     * @param {number} [limit] The maximum number of open interest messages to return
     * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
     * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
     * @param {boolean} [return404OnEmptyResponse] If set to false (default) then when there are no items to return, you will get a response status code of 200 and an empty JSON array or a CSV file with just the header. If set to true then when there are no items you will get a 404 status code for both JSON and CSV response_formats.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public futuresV1HistoricalOpenInterestMessages(market: string, instrument: string, afterTs?: number, lastCcseq?: number, limit?: number, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', return404OnEmptyResponse?: boolean, options?: AxiosRequestConfig) {
        return FuturesApiFp(this.configuration).futuresV1HistoricalOpenInterestMessages(market, instrument, afterTs, lastCcseq, limit, mappingPriority, responseFormat, return404OnEmptyResponse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} market The exchange to obtain data from
     * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
     * @param {number} [hourTs] Unix timestamp in seconds for the hour containing the open interest updates you are interested in. You can pass any timestamp in the hour but we will round it down the the full hour timestmap and return all open interest updates in that hour.
     * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
     * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
     * @param {boolean} [return404OnEmptyResponse] If set to false (default) then when there are no items to return, you will get a response status code of 200 and an empty JSON array or a CSV file with just the header. If set to true then when there are no items you will get a 404 status code for both JSON and CSV response_formats.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public futuresV1HistoricalOpenInterestMessagesHour(market: string, instrument: string, hourTs?: number, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', return404OnEmptyResponse?: boolean, options?: AxiosRequestConfig) {
        return FuturesApiFp(this.configuration).futuresV1HistoricalOpenInterestMessagesHour(market, instrument, hourTs, mappingPriority, responseFormat, return404OnEmptyResponse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} market The exchange to obtain data from
     * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
     * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,OHLC,OHLC_MESSAGE,MESSAGE
     * @param {number} [limit] The number of data points to return
     * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
     * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
     * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
     * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
     * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public futuresV1HistoricalOpenInterestMinutes(market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options?: AxiosRequestConfig) {
        return FuturesApiFp(this.configuration).futuresV1HistoricalOpenInterestMinutes(market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} market The exchange to obtain data from
     * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
     * @param {number} [afterTs] Unix timestamp in seconds of the earliest trade in the response.
     * @param {number} [lastCcseq] The CCSEQ of the last message seen in the previous request. Useful for pagination within messages that happened in the same second. It will look though the messages in the same second and discard all messages until it reaches the CCSEQ from the last_ccseq parameter. If the CCSEQ is not part of that second, it will discard all messages in the second and only return messages starting from the next second onwards. When starting an integration with our API, on the first request, you should either not send a value for this paramater (defaults to 0 and does not discard any messages) or send 0. After you get a response use the TIMESTAMP and CCSEQ from the last message in the response. Pass the TIMESTAMP in the after_ts parameter and the CCSEQ in the last_ccseq parameter on your next request.
     * @param {number} [limit] The maximum number of trades to return
     * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
     * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
     * @param {boolean} [return404OnEmptyResponse] If set to false (default) then when there are no items to return, you will get a response status code of 200 and an empty JSON array or a CSV file with just the header. If set to true then when there are no items you will get a 404 status code for both JSON and CSV response_formats.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public futuresV1HistoricalTrades(market: string, instrument: string, afterTs?: number, lastCcseq?: number, limit?: number, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', return404OnEmptyResponse?: boolean, options?: AxiosRequestConfig) {
        return FuturesApiFp(this.configuration).futuresV1HistoricalTrades(market, instrument, afterTs, lastCcseq, limit, mappingPriority, responseFormat, return404OnEmptyResponse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} market The exchange to obtain data from
     * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
     * @param {number} [hourTs] Unix timestamp in seconds for the hour containing the trades you are interested in. You can pass any timestamp within an hour but we will round it down the the full hour timestmap and return all trades in that hour.
     * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
     * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
     * @param {boolean} [return404OnEmptyResponse] If set to false (default) then when there are no items to return, you will get a response status code of 200 and an empty JSON array or a CSV file with just the header. If set to true then when there are no items you will get a 404 status code for both JSON and CSV response_formats.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public futuresV1HistoricalTradesHour(market: string, instrument: string, hourTs?: number, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', return404OnEmptyResponse?: boolean, options?: AxiosRequestConfig) {
        return FuturesApiFp(this.configuration).futuresV1HistoricalTradesHour(market, instrument, hourTs, mappingPriority, responseFormat, return404OnEmptyResponse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} market The exchange to obtain data from
     * @param {Array<string>} instruments A comma separated array of mapped and/or unmapped instruments to retrieve for a specific market (you can use either the instrument XXBTZUSD or mapped instrument (base - quote) BTC-USD on kraken as an example). We first check each instrument against the mapped list and then against the unmapped list but you can use the mapping_priority param to check the unmapped list first.
     * @param {Array<string>} [groups] When requesting tick data you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,VALUE,LAST_UPDATE,CURRENT_HOUR,CURRENT_DAY,CURRENT_WEEK,CURRENT_MONTH,CURRENT_YEAR,MOVING_24_HOUR,MOVING_7_DAY,MOVING_30_DAY,MOVING_90_DAY,MOVING_180_DAY,MOVING_365_DAY,LIFETIME
     * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public futuresV1LatestFundingRateTick(market: string, instruments: Array<string>, groups?: Array<string>, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', options?: AxiosRequestConfig) {
        return FuturesApiFp(this.configuration).futuresV1LatestFundingRateTick(market, instruments, groups, mappingPriority, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} market The exchange to obtain data from
     * @param {Array<string>} instruments A comma separated array of mapped and/or unmapped instruments to retrieve for a specific market (you can use either the instrument XXBTZUSD or mapped instrument (base - quote) BTC-USD on kraken as an example). We first check each instrument against the mapped list and then against the unmapped list but you can use the mapping_priority param to check the unmapped list first.
     * @param {Array<string>} [groups] When requesting metadata entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: STATUS,INTERNAL,GENERAL,MIGRATION,SOURCE
     * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public futuresV1LatestInstrumentMetadata(market: string, instruments: Array<string>, groups?: Array<string>, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', options?: AxiosRequestConfig) {
        return FuturesApiFp(this.configuration).futuresV1LatestInstrumentMetadata(market, instruments, groups, mappingPriority, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} market The exchange to obtain data from
     * @param {Array<string>} instruments A comma separated array of mapped and/or unmapped instruments to retrieve for a specific market (you can use either the instrument XXBTZUSD or mapped instrument (base - quote) BTC-USD on kraken as an example). We first check each instrument against the mapped list and then against the unmapped list but you can use the mapping_priority param to check the unmapped list first.
     * @param {Array<string>} [groups] When requesting tick data you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,VALUE,LAST_UPDATE,CURRENT_HOUR,CURRENT_DAY,CURRENT_WEEK,CURRENT_MONTH,CURRENT_YEAR,MOVING_24_HOUR,MOVING_7_DAY,MOVING_30_DAY,MOVING_90_DAY,MOVING_180_DAY,MOVING_365_DAY,LIFETIME
     * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public futuresV1LatestOpenInterestTick(market: string, instruments: Array<string>, groups?: Array<string>, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', options?: AxiosRequestConfig) {
        return FuturesApiFp(this.configuration).futuresV1LatestOpenInterestTick(market, instruments, groups, mappingPriority, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} market The exchange to obtain data from
     * @param {Array<string>} instruments A comma separated array of mapped and/or unmapped instruments to retrieve for a specific market (you can use either the instrument XXBTZUSD or mapped instrument (base - quote) BTC-USD on kraken as an example). We first check each instrument against the mapped list and then against the unmapped list but you can use the mapping_priority param to check the unmapped list first.
     * @param {Array<string>} [groups] When requesting tick data you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,VALUE,LAST_UPDATE,TOP_OF_BOOK,CURRENT_HOUR,CURRENT_DAY,CURRENT_WEEK,CURRENT_MONTH,CURRENT_YEAR,MOVING_24_HOUR,MOVING_7_DAY,MOVING_30_DAY,MOVING_90_DAY,MOVING_180_DAY,MOVING_365_DAY,LIFETIME
     * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public futuresV1LatestTick(market: string, instruments: Array<string>, groups?: Array<string>, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', options?: AxiosRequestConfig) {
        return FuturesApiFp(this.configuration).futuresV1LatestTick(market, instruments, groups, mappingPriority, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [market] The exchange to obtain data from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public futuresV1Markets(market?: string, options?: AxiosRequestConfig) {
        return FuturesApiFp(this.configuration).futuresV1Markets(market, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [market] The exchange to obtain data from
     * @param {string} [instrument] The mapped instrument to retrieve on a specific market.
     * @param {Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>} [instrumentStatus] The status of the instrument, can be one of the following: ACTIVE, IGNORED, RETIRED, EXPIRED
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public futuresV1MarketsInstruments(market?: string, instrument?: string, instrumentStatus?: Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>, options?: AxiosRequestConfig) {
        return FuturesApiFp(this.configuration).futuresV1MarketsInstruments(market, instrument, instrumentStatus, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [market] The exchange to obtain data from
     * @param {string} [instrument] The unmapped instrument to retrieve on a specific market.
     * @param {Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>} [instrumentStatus] The status of the instrument, can be one of the following: ACTIVE, IGNORED, RETIRED, EXPIRED
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public futuresV1MarketsInstrumentsUnmapped(market?: string, instrument?: string, instrumentStatus?: Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>, options?: AxiosRequestConfig) {
        return FuturesApiFp(this.configuration).futuresV1MarketsInstrumentsUnmapped(market, instrument, instrumentStatus, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} market The exchange to obtain data from
     * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
     * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,OHLC,OHLC_MESSAGE,MESSAGE,VOLUME
     * @param {number} [limit] The number of data points to return
     * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
     * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
     * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
     * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
     * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public indexV1HistoricalDays(market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options?: AxiosRequestConfig) {
        return FuturesApiFp(this.configuration).indexV1HistoricalDays(market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} market The exchange to obtain data from
     * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
     * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,OHLC,OHLC_MESSAGE,MESSAGE,VOLUME
     * @param {number} [limit] The number of data points to return
     * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
     * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
     * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
     * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
     * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public indexV1HistoricalHours(market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options?: AxiosRequestConfig) {
        return FuturesApiFp(this.configuration).indexV1HistoricalHours(market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} market The exchange to obtain data from
     * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
     * @param {number} [afterTs] Unix timestamp in seconds of the earliest index message in the response
     * @param {number} [lastCcseq] The CCSEQ of the last message seen in the previous request. Useful for pagination within messages that happened in the same second. It will look though the messages in the same second and discard all messages until it reaches the CCSEQ from the last_ccseq parameter. If the CCSEQ is not part of that second, it will discard all messages in the second and only return messages starting from the next second onwards. When starting an integration with our API, on the first request, you should either not send a value for this paramater (defaults to 0 and does not discard any messages) or send 0. After you get a response use the TIMESTAMP and CCSEQ from the last message in the response. Pass the TIMESTAMP in the after_ts parameter and the CCSEQ in the last_ccseq parameter on your next request.
     * @param {number} [limit] The maximum number of index messages to return
     * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
     * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
     * @param {boolean} [return404OnEmptyResponse] If set to false (default) then when there are no items to return, you will get a response status code of 200 and an empty JSON array or a CSV file with just the header. If set to true then when there are no items you will get a 404 status code for both JSON and CSV response_formats.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public indexV1HistoricalMessages(market: string, instrument: string, afterTs?: number, lastCcseq?: number, limit?: number, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', return404OnEmptyResponse?: boolean, options?: AxiosRequestConfig) {
        return FuturesApiFp(this.configuration).indexV1HistoricalMessages(market, instrument, afterTs, lastCcseq, limit, mappingPriority, responseFormat, return404OnEmptyResponse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} market The exchange to obtain data from
     * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
     * @param {number} [hourTs] Unix timestamp in seconds for the hour containing the index updates you are interested in. You can pass any timestamp in the hour but we will round it down the the full hour timestmap and return all index updates in that hour.
     * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
     * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
     * @param {boolean} [return404OnEmptyResponse] If set to false (default) then when there are no items to return, you will get a response status code of 200 and an empty JSON array or a CSV file with just the header. If set to true then when there are no items you will get a 404 status code for both JSON and CSV response_formats.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public indexV1HistoricalMessagesHour(market: string, instrument: string, hourTs?: number, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', return404OnEmptyResponse?: boolean, options?: AxiosRequestConfig) {
        return FuturesApiFp(this.configuration).indexV1HistoricalMessagesHour(market, instrument, hourTs, mappingPriority, responseFormat, return404OnEmptyResponse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} market The exchange to obtain data from
     * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
     * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,OHLC,OHLC_MESSAGE,MESSAGE,VOLUME
     * @param {number} [limit] The number of data points to return
     * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
     * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
     * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
     * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
     * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public indexV1HistoricalMinutes(market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options?: AxiosRequestConfig) {
        return FuturesApiFp(this.configuration).indexV1HistoricalMinutes(market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} market The exchange to obtain data from
     * @param {Array<string>} instruments A comma separated array of mapped and/or unmapped instruments to retrieve for a specific market (you can use either the instrument XXBTZUSD or mapped instrument (base - quote) BTC-USD on kraken as an example). We first check each instrument against the mapped list and then against the unmapped list but you can use the mapping_priority param to check the unmapped list first.
     * @param {Array<string>} [groups] When requesting metadata entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: STATUS,INTERNAL,GENERAL,MIGRATION,SOURCE
     * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public indexV1LatestInstrumentMetadata(market: string, instruments: Array<string>, groups?: Array<string>, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', options?: AxiosRequestConfig) {
        return FuturesApiFp(this.configuration).indexV1LatestInstrumentMetadata(market, instruments, groups, mappingPriority, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} market The exchange to obtain data from
     * @param {Array<string>} instruments A comma separated array of mapped and/or unmapped instruments to retrieve for a specific market (you can use either the instrument XXBTZUSD or mapped instrument (base - quote) BTC-USD on kraken as an example). We first check each instrument against the mapped list and then against the unmapped list but you can use the mapping_priority param to check the unmapped list first.
     * @param {Array<string>} [groups] When requesting tick data you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,VALUE,LAST_UPDATE,CURRENT_HOUR,CURRENT_DAY,CURRENT_WEEK,CURRENT_MONTH,CURRENT_YEAR,MOVING_24_HOUR,MOVING_7_DAY,MOVING_30_DAY,MOVING_90_DAY,MOVING_180_DAY,MOVING_365_DAY,LIFETIME
     * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public indexV1LatestTick(market: string, instruments: Array<string>, groups?: Array<string>, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', options?: AxiosRequestConfig) {
        return FuturesApiFp(this.configuration).indexV1LatestTick(market, instruments, groups, mappingPriority, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [market] The exchange to obtain data from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public indexV1Markets(market?: string, options?: AxiosRequestConfig) {
        return FuturesApiFp(this.configuration).indexV1Markets(market, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [market] The exchange to obtain data from
     * @param {string} [instrument] The mapped instrument to retrieve on a specific market.
     * @param {Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>} [instrumentStatus] The status of the instrument, can be one of the following: ACTIVE, IGNORED, RETIRED, EXPIRED
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public indexV1MarketsInstruments(market?: string, instrument?: string, instrumentStatus?: Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>, options?: AxiosRequestConfig) {
        return FuturesApiFp(this.configuration).indexV1MarketsInstruments(market, instrument, instrumentStatus, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [market] The exchange to obtain data from
     * @param {string} [instrument] The unmapped instrument to retrieve on a specific market.
     * @param {Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>} [instrumentStatus] The status of the instrument, can be one of the following: ACTIVE, IGNORED, RETIRED, EXPIRED
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public indexV1MarketsInstrumentsUnmapped(market?: string, instrument?: string, instrumentStatus?: Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>, options?: AxiosRequestConfig) {
        return FuturesApiFp(this.configuration).indexV1MarketsInstrumentsUnmapped(market, instrument, instrumentStatus, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NewsApi - axios parameter creator
 * @export
 */
export const NewsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Array<string>} [sourceIds] Get articles from specific sources; either by their ids or keys
         * @param {'EN' | 'ES' | 'PT' | ''} [lang] The article Preferred language - English (EN), Portuguese (PT), Espanol (ES)
         * @param {Array<'1INCH' | 'AAVE' | 'ADA' | 'ALGO' | 'ALTCOIN' | 'ASIA' | 'ATOM' | 'AVAX' | 'AXS' | 'BAL' | 'BAT' | 'BCH' | 'BLOCKCHAIN' | 'BTC' | 'BUSINESS' | 'COMMODITY' | 'COMP' | 'CRV' | 'DASH' | 'DOGE' | 'DOT' | 'ENJ' | 'ETC' | 'ETH' | 'EXCHANGE' | 'FIAT' | 'FIL' | 'FTM' | 'ICO' | 'KNC' | 'LINK' | 'LRC' | 'LTC' | 'LUNA' | 'LUNC' | 'MANA' | 'MARKET' | 'MATIC' | 'MINING' | 'MKR' | 'REGULATION' | 'REN' | 'SAND' | 'SHIB' | 'SNX' | 'SOL' | 'SPONSORED' | 'SUSHI' | 'TECHNOLOGY' | 'TRADING' | 'TRX' | 'UMA' | 'UNI' | 'USDT' | 'WALLET' | 'XLM' | 'XMR' | 'XRP' | 'XTZ' | 'YFI' | 'ZEC' | 'ZRX' | ''>} [categories] News article categories to return
         * @param {Array<'1INCH' | 'AAVE' | 'ADA' | 'ALGO' | 'ALTCOIN' | 'ASIA' | 'ATOM' | 'AVAX' | 'AXS' | 'BAL' | 'BAT' | 'BCH' | 'BLOCKCHAIN' | 'BTC' | 'BUSINESS' | 'COMMODITY' | 'COMP' | 'CRV' | 'DASH' | 'DOGE' | 'DOT' | 'ENJ' | 'ETC' | 'ETH' | 'EXCHANGE' | 'FIAT' | 'FIL' | 'FTM' | 'ICO' | 'KNC' | 'LINK' | 'LRC' | 'LTC' | 'LUNA' | 'LUNC' | 'MANA' | 'MARKET' | 'MATIC' | 'MINING' | 'MKR' | 'REGULATION' | 'REN' | 'SAND' | 'SHIB' | 'SNX' | 'SOL' | 'SPONSORED' | 'SUSHI' | 'TECHNOLOGY' | 'TRADING' | 'TRX' | 'UMA' | 'UNI' | 'USDT' | 'WALLET' | 'XLM' | 'XMR' | 'XRP' | 'XTZ' | 'YFI' | 'ZEC' | 'ZRX' | ''>} [excludeCategories] News article categories to exclude from results
         * @param {number} [toTs] Articles published on or before this timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newsV1ArticleList: async (sourceIds?: Array<string>, lang?: 'EN' | 'ES' | 'PT' | '', categories?: Array<'1INCH' | 'AAVE' | 'ADA' | 'ALGO' | 'ALTCOIN' | 'ASIA' | 'ATOM' | 'AVAX' | 'AXS' | 'BAL' | 'BAT' | 'BCH' | 'BLOCKCHAIN' | 'BTC' | 'BUSINESS' | 'COMMODITY' | 'COMP' | 'CRV' | 'DASH' | 'DOGE' | 'DOT' | 'ENJ' | 'ETC' | 'ETH' | 'EXCHANGE' | 'FIAT' | 'FIL' | 'FTM' | 'ICO' | 'KNC' | 'LINK' | 'LRC' | 'LTC' | 'LUNA' | 'LUNC' | 'MANA' | 'MARKET' | 'MATIC' | 'MINING' | 'MKR' | 'REGULATION' | 'REN' | 'SAND' | 'SHIB' | 'SNX' | 'SOL' | 'SPONSORED' | 'SUSHI' | 'TECHNOLOGY' | 'TRADING' | 'TRX' | 'UMA' | 'UNI' | 'USDT' | 'WALLET' | 'XLM' | 'XMR' | 'XRP' | 'XTZ' | 'YFI' | 'ZEC' | 'ZRX' | ''>, excludeCategories?: Array<'1INCH' | 'AAVE' | 'ADA' | 'ALGO' | 'ALTCOIN' | 'ASIA' | 'ATOM' | 'AVAX' | 'AXS' | 'BAL' | 'BAT' | 'BCH' | 'BLOCKCHAIN' | 'BTC' | 'BUSINESS' | 'COMMODITY' | 'COMP' | 'CRV' | 'DASH' | 'DOGE' | 'DOT' | 'ENJ' | 'ETC' | 'ETH' | 'EXCHANGE' | 'FIAT' | 'FIL' | 'FTM' | 'ICO' | 'KNC' | 'LINK' | 'LRC' | 'LTC' | 'LUNA' | 'LUNC' | 'MANA' | 'MARKET' | 'MATIC' | 'MINING' | 'MKR' | 'REGULATION' | 'REN' | 'SAND' | 'SHIB' | 'SNX' | 'SOL' | 'SPONSORED' | 'SUSHI' | 'TECHNOLOGY' | 'TRADING' | 'TRX' | 'UMA' | 'UNI' | 'USDT' | 'WALLET' | 'XLM' | 'XMR' | 'XRP' | 'XTZ' | 'YFI' | 'ZEC' | 'ZRX' | ''>, toTs?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/news/v1/article/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sourceIds) {
                localVarQueryParameter['source_ids'] = sourceIds.join(COLLECTION_FORMATS.csv);
            }

            if (lang !== undefined) {
                localVarQueryParameter['lang'] = lang;
            }

            if (categories) {
                localVarQueryParameter['categories'] = categories.join(COLLECTION_FORMATS.csv);
            }

            if (excludeCategories) {
                localVarQueryParameter['exclude_categories'] = excludeCategories.join(COLLECTION_FORMATS.csv);
            }

            if (toTs !== undefined) {
                localVarQueryParameter['to_ts'] = toTs;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newsV1CategoryList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/news/v1/category/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {'EN' | 'ES' | 'PT' | ''} [lang] The article source Preferred language - English (EN), Portuguese (PT), Espanol (ES)
         * @param {'RSS' | 'API' | 'TWITTER' | ''} [type] RSS, API, TWITTER
         * @param {'ACTIVE' | 'INACTIVE' | ''} [status] The status for the  article source entry. Allowed values: ACTIVE, INACTIVE
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newsV1SourceList: async (lang?: 'EN' | 'ES' | 'PT' | '', type?: 'RSS' | 'API' | 'TWITTER' | '', status?: 'ACTIVE' | 'INACTIVE' | '', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/news/v1/source/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (lang !== undefined) {
                localVarQueryParameter['lang'] = lang;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NewsApi - functional programming interface
 * @export
 */
export const NewsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NewsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Array<string>} [sourceIds] Get articles from specific sources; either by their ids or keys
         * @param {'EN' | 'ES' | 'PT' | ''} [lang] The article Preferred language - English (EN), Portuguese (PT), Espanol (ES)
         * @param {Array<'1INCH' | 'AAVE' | 'ADA' | 'ALGO' | 'ALTCOIN' | 'ASIA' | 'ATOM' | 'AVAX' | 'AXS' | 'BAL' | 'BAT' | 'BCH' | 'BLOCKCHAIN' | 'BTC' | 'BUSINESS' | 'COMMODITY' | 'COMP' | 'CRV' | 'DASH' | 'DOGE' | 'DOT' | 'ENJ' | 'ETC' | 'ETH' | 'EXCHANGE' | 'FIAT' | 'FIL' | 'FTM' | 'ICO' | 'KNC' | 'LINK' | 'LRC' | 'LTC' | 'LUNA' | 'LUNC' | 'MANA' | 'MARKET' | 'MATIC' | 'MINING' | 'MKR' | 'REGULATION' | 'REN' | 'SAND' | 'SHIB' | 'SNX' | 'SOL' | 'SPONSORED' | 'SUSHI' | 'TECHNOLOGY' | 'TRADING' | 'TRX' | 'UMA' | 'UNI' | 'USDT' | 'WALLET' | 'XLM' | 'XMR' | 'XRP' | 'XTZ' | 'YFI' | 'ZEC' | 'ZRX' | ''>} [categories] News article categories to return
         * @param {Array<'1INCH' | 'AAVE' | 'ADA' | 'ALGO' | 'ALTCOIN' | 'ASIA' | 'ATOM' | 'AVAX' | 'AXS' | 'BAL' | 'BAT' | 'BCH' | 'BLOCKCHAIN' | 'BTC' | 'BUSINESS' | 'COMMODITY' | 'COMP' | 'CRV' | 'DASH' | 'DOGE' | 'DOT' | 'ENJ' | 'ETC' | 'ETH' | 'EXCHANGE' | 'FIAT' | 'FIL' | 'FTM' | 'ICO' | 'KNC' | 'LINK' | 'LRC' | 'LTC' | 'LUNA' | 'LUNC' | 'MANA' | 'MARKET' | 'MATIC' | 'MINING' | 'MKR' | 'REGULATION' | 'REN' | 'SAND' | 'SHIB' | 'SNX' | 'SOL' | 'SPONSORED' | 'SUSHI' | 'TECHNOLOGY' | 'TRADING' | 'TRX' | 'UMA' | 'UNI' | 'USDT' | 'WALLET' | 'XLM' | 'XMR' | 'XRP' | 'XTZ' | 'YFI' | 'ZEC' | 'ZRX' | ''>} [excludeCategories] News article categories to exclude from results
         * @param {number} [toTs] Articles published on or before this timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async newsV1ArticleList(sourceIds?: Array<string>, lang?: 'EN' | 'ES' | 'PT' | '', categories?: Array<'1INCH' | 'AAVE' | 'ADA' | 'ALGO' | 'ALTCOIN' | 'ASIA' | 'ATOM' | 'AVAX' | 'AXS' | 'BAL' | 'BAT' | 'BCH' | 'BLOCKCHAIN' | 'BTC' | 'BUSINESS' | 'COMMODITY' | 'COMP' | 'CRV' | 'DASH' | 'DOGE' | 'DOT' | 'ENJ' | 'ETC' | 'ETH' | 'EXCHANGE' | 'FIAT' | 'FIL' | 'FTM' | 'ICO' | 'KNC' | 'LINK' | 'LRC' | 'LTC' | 'LUNA' | 'LUNC' | 'MANA' | 'MARKET' | 'MATIC' | 'MINING' | 'MKR' | 'REGULATION' | 'REN' | 'SAND' | 'SHIB' | 'SNX' | 'SOL' | 'SPONSORED' | 'SUSHI' | 'TECHNOLOGY' | 'TRADING' | 'TRX' | 'UMA' | 'UNI' | 'USDT' | 'WALLET' | 'XLM' | 'XMR' | 'XRP' | 'XTZ' | 'YFI' | 'ZEC' | 'ZRX' | ''>, excludeCategories?: Array<'1INCH' | 'AAVE' | 'ADA' | 'ALGO' | 'ALTCOIN' | 'ASIA' | 'ATOM' | 'AVAX' | 'AXS' | 'BAL' | 'BAT' | 'BCH' | 'BLOCKCHAIN' | 'BTC' | 'BUSINESS' | 'COMMODITY' | 'COMP' | 'CRV' | 'DASH' | 'DOGE' | 'DOT' | 'ENJ' | 'ETC' | 'ETH' | 'EXCHANGE' | 'FIAT' | 'FIL' | 'FTM' | 'ICO' | 'KNC' | 'LINK' | 'LRC' | 'LTC' | 'LUNA' | 'LUNC' | 'MANA' | 'MARKET' | 'MATIC' | 'MINING' | 'MKR' | 'REGULATION' | 'REN' | 'SAND' | 'SHIB' | 'SNX' | 'SOL' | 'SPONSORED' | 'SUSHI' | 'TECHNOLOGY' | 'TRADING' | 'TRX' | 'UMA' | 'UNI' | 'USDT' | 'WALLET' | 'XLM' | 'XMR' | 'XRP' | 'XTZ' | 'YFI' | 'ZEC' | 'ZRX' | ''>, toTs?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.newsV1ArticleList(sourceIds, lang, categories, excludeCategories, toTs, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async newsV1CategoryList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.newsV1CategoryList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {'EN' | 'ES' | 'PT' | ''} [lang] The article source Preferred language - English (EN), Portuguese (PT), Espanol (ES)
         * @param {'RSS' | 'API' | 'TWITTER' | ''} [type] RSS, API, TWITTER
         * @param {'ACTIVE' | 'INACTIVE' | ''} [status] The status for the  article source entry. Allowed values: ACTIVE, INACTIVE
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async newsV1SourceList(lang?: 'EN' | 'ES' | 'PT' | '', type?: 'RSS' | 'API' | 'TWITTER' | '', status?: 'ACTIVE' | 'INACTIVE' | '', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.newsV1SourceList(lang, type, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NewsApi - factory interface
 * @export
 */
export const NewsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NewsApiFp(configuration)
    return {
        /**
         * 
         * @param {Array<string>} [sourceIds] Get articles from specific sources; either by their ids or keys
         * @param {'EN' | 'ES' | 'PT' | ''} [lang] The article Preferred language - English (EN), Portuguese (PT), Espanol (ES)
         * @param {Array<'1INCH' | 'AAVE' | 'ADA' | 'ALGO' | 'ALTCOIN' | 'ASIA' | 'ATOM' | 'AVAX' | 'AXS' | 'BAL' | 'BAT' | 'BCH' | 'BLOCKCHAIN' | 'BTC' | 'BUSINESS' | 'COMMODITY' | 'COMP' | 'CRV' | 'DASH' | 'DOGE' | 'DOT' | 'ENJ' | 'ETC' | 'ETH' | 'EXCHANGE' | 'FIAT' | 'FIL' | 'FTM' | 'ICO' | 'KNC' | 'LINK' | 'LRC' | 'LTC' | 'LUNA' | 'LUNC' | 'MANA' | 'MARKET' | 'MATIC' | 'MINING' | 'MKR' | 'REGULATION' | 'REN' | 'SAND' | 'SHIB' | 'SNX' | 'SOL' | 'SPONSORED' | 'SUSHI' | 'TECHNOLOGY' | 'TRADING' | 'TRX' | 'UMA' | 'UNI' | 'USDT' | 'WALLET' | 'XLM' | 'XMR' | 'XRP' | 'XTZ' | 'YFI' | 'ZEC' | 'ZRX' | ''>} [categories] News article categories to return
         * @param {Array<'1INCH' | 'AAVE' | 'ADA' | 'ALGO' | 'ALTCOIN' | 'ASIA' | 'ATOM' | 'AVAX' | 'AXS' | 'BAL' | 'BAT' | 'BCH' | 'BLOCKCHAIN' | 'BTC' | 'BUSINESS' | 'COMMODITY' | 'COMP' | 'CRV' | 'DASH' | 'DOGE' | 'DOT' | 'ENJ' | 'ETC' | 'ETH' | 'EXCHANGE' | 'FIAT' | 'FIL' | 'FTM' | 'ICO' | 'KNC' | 'LINK' | 'LRC' | 'LTC' | 'LUNA' | 'LUNC' | 'MANA' | 'MARKET' | 'MATIC' | 'MINING' | 'MKR' | 'REGULATION' | 'REN' | 'SAND' | 'SHIB' | 'SNX' | 'SOL' | 'SPONSORED' | 'SUSHI' | 'TECHNOLOGY' | 'TRADING' | 'TRX' | 'UMA' | 'UNI' | 'USDT' | 'WALLET' | 'XLM' | 'XMR' | 'XRP' | 'XTZ' | 'YFI' | 'ZEC' | 'ZRX' | ''>} [excludeCategories] News article categories to exclude from results
         * @param {number} [toTs] Articles published on or before this timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newsV1ArticleList(sourceIds?: Array<string>, lang?: 'EN' | 'ES' | 'PT' | '', categories?: Array<'1INCH' | 'AAVE' | 'ADA' | 'ALGO' | 'ALTCOIN' | 'ASIA' | 'ATOM' | 'AVAX' | 'AXS' | 'BAL' | 'BAT' | 'BCH' | 'BLOCKCHAIN' | 'BTC' | 'BUSINESS' | 'COMMODITY' | 'COMP' | 'CRV' | 'DASH' | 'DOGE' | 'DOT' | 'ENJ' | 'ETC' | 'ETH' | 'EXCHANGE' | 'FIAT' | 'FIL' | 'FTM' | 'ICO' | 'KNC' | 'LINK' | 'LRC' | 'LTC' | 'LUNA' | 'LUNC' | 'MANA' | 'MARKET' | 'MATIC' | 'MINING' | 'MKR' | 'REGULATION' | 'REN' | 'SAND' | 'SHIB' | 'SNX' | 'SOL' | 'SPONSORED' | 'SUSHI' | 'TECHNOLOGY' | 'TRADING' | 'TRX' | 'UMA' | 'UNI' | 'USDT' | 'WALLET' | 'XLM' | 'XMR' | 'XRP' | 'XTZ' | 'YFI' | 'ZEC' | 'ZRX' | ''>, excludeCategories?: Array<'1INCH' | 'AAVE' | 'ADA' | 'ALGO' | 'ALTCOIN' | 'ASIA' | 'ATOM' | 'AVAX' | 'AXS' | 'BAL' | 'BAT' | 'BCH' | 'BLOCKCHAIN' | 'BTC' | 'BUSINESS' | 'COMMODITY' | 'COMP' | 'CRV' | 'DASH' | 'DOGE' | 'DOT' | 'ENJ' | 'ETC' | 'ETH' | 'EXCHANGE' | 'FIAT' | 'FIL' | 'FTM' | 'ICO' | 'KNC' | 'LINK' | 'LRC' | 'LTC' | 'LUNA' | 'LUNC' | 'MANA' | 'MARKET' | 'MATIC' | 'MINING' | 'MKR' | 'REGULATION' | 'REN' | 'SAND' | 'SHIB' | 'SNX' | 'SOL' | 'SPONSORED' | 'SUSHI' | 'TECHNOLOGY' | 'TRADING' | 'TRX' | 'UMA' | 'UNI' | 'USDT' | 'WALLET' | 'XLM' | 'XMR' | 'XRP' | 'XTZ' | 'YFI' | 'ZEC' | 'ZRX' | ''>, toTs?: number, options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.newsV1ArticleList(sourceIds, lang, categories, excludeCategories, toTs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newsV1CategoryList(options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.newsV1CategoryList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {'EN' | 'ES' | 'PT' | ''} [lang] The article source Preferred language - English (EN), Portuguese (PT), Espanol (ES)
         * @param {'RSS' | 'API' | 'TWITTER' | ''} [type] RSS, API, TWITTER
         * @param {'ACTIVE' | 'INACTIVE' | ''} [status] The status for the  article source entry. Allowed values: ACTIVE, INACTIVE
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newsV1SourceList(lang?: 'EN' | 'ES' | 'PT' | '', type?: 'RSS' | 'API' | 'TWITTER' | '', status?: 'ACTIVE' | 'INACTIVE' | '', options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.newsV1SourceList(lang, type, status, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NewsApi - object-oriented interface
 * @export
 * @class NewsApi
 * @extends {BaseAPI}
 */
export class NewsApi extends BaseAPI {
    /**
     * 
     * @param {Array<string>} [sourceIds] Get articles from specific sources; either by their ids or keys
     * @param {'EN' | 'ES' | 'PT' | ''} [lang] The article Preferred language - English (EN), Portuguese (PT), Espanol (ES)
     * @param {Array<'1INCH' | 'AAVE' | 'ADA' | 'ALGO' | 'ALTCOIN' | 'ASIA' | 'ATOM' | 'AVAX' | 'AXS' | 'BAL' | 'BAT' | 'BCH' | 'BLOCKCHAIN' | 'BTC' | 'BUSINESS' | 'COMMODITY' | 'COMP' | 'CRV' | 'DASH' | 'DOGE' | 'DOT' | 'ENJ' | 'ETC' | 'ETH' | 'EXCHANGE' | 'FIAT' | 'FIL' | 'FTM' | 'ICO' | 'KNC' | 'LINK' | 'LRC' | 'LTC' | 'LUNA' | 'LUNC' | 'MANA' | 'MARKET' | 'MATIC' | 'MINING' | 'MKR' | 'REGULATION' | 'REN' | 'SAND' | 'SHIB' | 'SNX' | 'SOL' | 'SPONSORED' | 'SUSHI' | 'TECHNOLOGY' | 'TRADING' | 'TRX' | 'UMA' | 'UNI' | 'USDT' | 'WALLET' | 'XLM' | 'XMR' | 'XRP' | 'XTZ' | 'YFI' | 'ZEC' | 'ZRX' | ''>} [categories] News article categories to return
     * @param {Array<'1INCH' | 'AAVE' | 'ADA' | 'ALGO' | 'ALTCOIN' | 'ASIA' | 'ATOM' | 'AVAX' | 'AXS' | 'BAL' | 'BAT' | 'BCH' | 'BLOCKCHAIN' | 'BTC' | 'BUSINESS' | 'COMMODITY' | 'COMP' | 'CRV' | 'DASH' | 'DOGE' | 'DOT' | 'ENJ' | 'ETC' | 'ETH' | 'EXCHANGE' | 'FIAT' | 'FIL' | 'FTM' | 'ICO' | 'KNC' | 'LINK' | 'LRC' | 'LTC' | 'LUNA' | 'LUNC' | 'MANA' | 'MARKET' | 'MATIC' | 'MINING' | 'MKR' | 'REGULATION' | 'REN' | 'SAND' | 'SHIB' | 'SNX' | 'SOL' | 'SPONSORED' | 'SUSHI' | 'TECHNOLOGY' | 'TRADING' | 'TRX' | 'UMA' | 'UNI' | 'USDT' | 'WALLET' | 'XLM' | 'XMR' | 'XRP' | 'XTZ' | 'YFI' | 'ZEC' | 'ZRX' | ''>} [excludeCategories] News article categories to exclude from results
     * @param {number} [toTs] Articles published on or before this timestamp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NewsApi
     */
    public newsV1ArticleList(sourceIds?: Array<string>, lang?: 'EN' | 'ES' | 'PT' | '', categories?: Array<'1INCH' | 'AAVE' | 'ADA' | 'ALGO' | 'ALTCOIN' | 'ASIA' | 'ATOM' | 'AVAX' | 'AXS' | 'BAL' | 'BAT' | 'BCH' | 'BLOCKCHAIN' | 'BTC' | 'BUSINESS' | 'COMMODITY' | 'COMP' | 'CRV' | 'DASH' | 'DOGE' | 'DOT' | 'ENJ' | 'ETC' | 'ETH' | 'EXCHANGE' | 'FIAT' | 'FIL' | 'FTM' | 'ICO' | 'KNC' | 'LINK' | 'LRC' | 'LTC' | 'LUNA' | 'LUNC' | 'MANA' | 'MARKET' | 'MATIC' | 'MINING' | 'MKR' | 'REGULATION' | 'REN' | 'SAND' | 'SHIB' | 'SNX' | 'SOL' | 'SPONSORED' | 'SUSHI' | 'TECHNOLOGY' | 'TRADING' | 'TRX' | 'UMA' | 'UNI' | 'USDT' | 'WALLET' | 'XLM' | 'XMR' | 'XRP' | 'XTZ' | 'YFI' | 'ZEC' | 'ZRX' | ''>, excludeCategories?: Array<'1INCH' | 'AAVE' | 'ADA' | 'ALGO' | 'ALTCOIN' | 'ASIA' | 'ATOM' | 'AVAX' | 'AXS' | 'BAL' | 'BAT' | 'BCH' | 'BLOCKCHAIN' | 'BTC' | 'BUSINESS' | 'COMMODITY' | 'COMP' | 'CRV' | 'DASH' | 'DOGE' | 'DOT' | 'ENJ' | 'ETC' | 'ETH' | 'EXCHANGE' | 'FIAT' | 'FIL' | 'FTM' | 'ICO' | 'KNC' | 'LINK' | 'LRC' | 'LTC' | 'LUNA' | 'LUNC' | 'MANA' | 'MARKET' | 'MATIC' | 'MINING' | 'MKR' | 'REGULATION' | 'REN' | 'SAND' | 'SHIB' | 'SNX' | 'SOL' | 'SPONSORED' | 'SUSHI' | 'TECHNOLOGY' | 'TRADING' | 'TRX' | 'UMA' | 'UNI' | 'USDT' | 'WALLET' | 'XLM' | 'XMR' | 'XRP' | 'XTZ' | 'YFI' | 'ZEC' | 'ZRX' | ''>, toTs?: number, options?: AxiosRequestConfig) {
        return NewsApiFp(this.configuration).newsV1ArticleList(sourceIds, lang, categories, excludeCategories, toTs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NewsApi
     */
    public newsV1CategoryList(options?: AxiosRequestConfig) {
        return NewsApiFp(this.configuration).newsV1CategoryList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {'EN' | 'ES' | 'PT' | ''} [lang] The article source Preferred language - English (EN), Portuguese (PT), Espanol (ES)
     * @param {'RSS' | 'API' | 'TWITTER' | ''} [type] RSS, API, TWITTER
     * @param {'ACTIVE' | 'INACTIVE' | ''} [status] The status for the  article source entry. Allowed values: ACTIVE, INACTIVE
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NewsApi
     */
    public newsV1SourceList(lang?: 'EN' | 'ES' | 'PT' | '', type?: 'RSS' | 'API' | 'TWITTER' | '', status?: 'ACTIVE' | 'INACTIVE' | '', options?: AxiosRequestConfig) {
        return NewsApiFp(this.configuration).newsV1SourceList(lang, type, status, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OverviewApi - axios parameter creator
 * @export
 */
export const OverviewApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Array<string>} [groups] When requesting all market cap historical data you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,OHLC,VOLUME
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        overviewV1HistoricalMarketcapAllAssetsDays: async (groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, responseFormat?: 'JSON' | 'CSV', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/overview/v1/historical/marketcap/all/assets/days`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (groups) {
                localVarQueryParameter['groups'] = groups.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (toTs !== undefined) {
                localVarQueryParameter['to_ts'] = toTs;
            }

            if (aggregate !== undefined) {
                localVarQueryParameter['aggregate'] = aggregate;
            }

            if (fill !== undefined) {
                localVarQueryParameter['fill'] = fill;
            }

            if (responseFormat !== undefined) {
                localVarQueryParameter['response_format'] = responseFormat;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<string>} [groups] When requesting all market cap historical data you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,OHLC,VOLUME
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        overviewV1HistoricalMarketcapAllAssetsHours: async (groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, responseFormat?: 'JSON' | 'CSV', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/overview/v1/historical/marketcap/all/assets/hours`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (groups) {
                localVarQueryParameter['groups'] = groups.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (toTs !== undefined) {
                localVarQueryParameter['to_ts'] = toTs;
            }

            if (aggregate !== undefined) {
                localVarQueryParameter['aggregate'] = aggregate;
            }

            if (fill !== undefined) {
                localVarQueryParameter['fill'] = fill;
            }

            if (responseFormat !== undefined) {
                localVarQueryParameter['response_format'] = responseFormat;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<string>} [groups] When requesting ftw universe market cap historical data you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,OHLC,VOLUME
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        overviewV1HistoricalMarketcapFtwAssetsDays: async (groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, responseFormat?: 'JSON' | 'CSV', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/overview/v1/historical/marketcap/ftw/assets/days`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (groups) {
                localVarQueryParameter['groups'] = groups.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (toTs !== undefined) {
                localVarQueryParameter['to_ts'] = toTs;
            }

            if (aggregate !== undefined) {
                localVarQueryParameter['aggregate'] = aggregate;
            }

            if (fill !== undefined) {
                localVarQueryParameter['fill'] = fill;
            }

            if (responseFormat !== undefined) {
                localVarQueryParameter['response_format'] = responseFormat;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<string>} [groups] When requesting ftw universe market cap historical data you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,OHLC,VOLUME
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        overviewV1HistoricalMarketcapFtwAssetsHours: async (groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, responseFormat?: 'JSON' | 'CSV', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/overview/v1/historical/marketcap/ftw/assets/hours`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (groups) {
                localVarQueryParameter['groups'] = groups.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (toTs !== undefined) {
                localVarQueryParameter['to_ts'] = toTs;
            }

            if (aggregate !== undefined) {
                localVarQueryParameter['aggregate'] = aggregate;
            }

            if (fill !== undefined) {
                localVarQueryParameter['fill'] = fill;
            }

            if (responseFormat !== undefined) {
                localVarQueryParameter['response_format'] = responseFormat;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<string>} [groups] When requesting all market cap tick data you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,VALUE,LAST_UPDATE,CURRENT_HOUR,CURRENT_DAY,MOVING_24_HOUR
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        overviewV1LatestMarketcapAllTick: async (groups?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/overview/v1/latest/marketcap/all/tick`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (groups) {
                localVarQueryParameter['groups'] = groups.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<string>} [groups] When requesting ftw universe market cap tick data you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,VALUE,LAST_UPDATE,CURRENT_HOUR,CURRENT_DAY,MOVING_24_HOUR
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        overviewV1LatestMarketcapFtwTick: async (groups?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/overview/v1/latest/marketcap/ftw/tick`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (groups) {
                localVarQueryParameter['groups'] = groups.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OverviewApi - functional programming interface
 * @export
 */
export const OverviewApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OverviewApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Array<string>} [groups] When requesting all market cap historical data you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,OHLC,VOLUME
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async overviewV1HistoricalMarketcapAllAssetsDays(groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, responseFormat?: 'JSON' | 'CSV', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.overviewV1HistoricalMarketcapAllAssetsDays(groups, limit, toTs, aggregate, fill, responseFormat, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<string>} [groups] When requesting all market cap historical data you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,OHLC,VOLUME
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async overviewV1HistoricalMarketcapAllAssetsHours(groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, responseFormat?: 'JSON' | 'CSV', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.overviewV1HistoricalMarketcapAllAssetsHours(groups, limit, toTs, aggregate, fill, responseFormat, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<string>} [groups] When requesting ftw universe market cap historical data you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,OHLC,VOLUME
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async overviewV1HistoricalMarketcapFtwAssetsDays(groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, responseFormat?: 'JSON' | 'CSV', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.overviewV1HistoricalMarketcapFtwAssetsDays(groups, limit, toTs, aggregate, fill, responseFormat, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<string>} [groups] When requesting ftw universe market cap historical data you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,OHLC,VOLUME
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async overviewV1HistoricalMarketcapFtwAssetsHours(groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, responseFormat?: 'JSON' | 'CSV', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.overviewV1HistoricalMarketcapFtwAssetsHours(groups, limit, toTs, aggregate, fill, responseFormat, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<string>} [groups] When requesting all market cap tick data you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,VALUE,LAST_UPDATE,CURRENT_HOUR,CURRENT_DAY,MOVING_24_HOUR
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async overviewV1LatestMarketcapAllTick(groups?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.overviewV1LatestMarketcapAllTick(groups, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<string>} [groups] When requesting ftw universe market cap tick data you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,VALUE,LAST_UPDATE,CURRENT_HOUR,CURRENT_DAY,MOVING_24_HOUR
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async overviewV1LatestMarketcapFtwTick(groups?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.overviewV1LatestMarketcapFtwTick(groups, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OverviewApi - factory interface
 * @export
 */
export const OverviewApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OverviewApiFp(configuration)
    return {
        /**
         * 
         * @param {Array<string>} [groups] When requesting all market cap historical data you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,OHLC,VOLUME
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        overviewV1HistoricalMarketcapAllAssetsDays(groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, responseFormat?: 'JSON' | 'CSV', options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.overviewV1HistoricalMarketcapAllAssetsDays(groups, limit, toTs, aggregate, fill, responseFormat, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<string>} [groups] When requesting all market cap historical data you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,OHLC,VOLUME
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        overviewV1HistoricalMarketcapAllAssetsHours(groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, responseFormat?: 'JSON' | 'CSV', options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.overviewV1HistoricalMarketcapAllAssetsHours(groups, limit, toTs, aggregate, fill, responseFormat, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<string>} [groups] When requesting ftw universe market cap historical data you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,OHLC,VOLUME
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        overviewV1HistoricalMarketcapFtwAssetsDays(groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, responseFormat?: 'JSON' | 'CSV', options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.overviewV1HistoricalMarketcapFtwAssetsDays(groups, limit, toTs, aggregate, fill, responseFormat, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<string>} [groups] When requesting ftw universe market cap historical data you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,OHLC,VOLUME
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        overviewV1HistoricalMarketcapFtwAssetsHours(groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, responseFormat?: 'JSON' | 'CSV', options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.overviewV1HistoricalMarketcapFtwAssetsHours(groups, limit, toTs, aggregate, fill, responseFormat, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<string>} [groups] When requesting all market cap tick data you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,VALUE,LAST_UPDATE,CURRENT_HOUR,CURRENT_DAY,MOVING_24_HOUR
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        overviewV1LatestMarketcapAllTick(groups?: Array<string>, options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.overviewV1LatestMarketcapAllTick(groups, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<string>} [groups] When requesting ftw universe market cap tick data you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,VALUE,LAST_UPDATE,CURRENT_HOUR,CURRENT_DAY,MOVING_24_HOUR
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        overviewV1LatestMarketcapFtwTick(groups?: Array<string>, options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.overviewV1LatestMarketcapFtwTick(groups, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OverviewApi - object-oriented interface
 * @export
 * @class OverviewApi
 * @extends {BaseAPI}
 */
export class OverviewApi extends BaseAPI {
    /**
     * 
     * @param {Array<string>} [groups] When requesting all market cap historical data you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,OHLC,VOLUME
     * @param {number} [limit] The number of data points to return
     * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
     * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
     * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
     * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OverviewApi
     */
    public overviewV1HistoricalMarketcapAllAssetsDays(groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, responseFormat?: 'JSON' | 'CSV', options?: AxiosRequestConfig) {
        return OverviewApiFp(this.configuration).overviewV1HistoricalMarketcapAllAssetsDays(groups, limit, toTs, aggregate, fill, responseFormat, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<string>} [groups] When requesting all market cap historical data you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,OHLC,VOLUME
     * @param {number} [limit] The number of data points to return
     * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
     * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
     * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
     * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OverviewApi
     */
    public overviewV1HistoricalMarketcapAllAssetsHours(groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, responseFormat?: 'JSON' | 'CSV', options?: AxiosRequestConfig) {
        return OverviewApiFp(this.configuration).overviewV1HistoricalMarketcapAllAssetsHours(groups, limit, toTs, aggregate, fill, responseFormat, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<string>} [groups] When requesting ftw universe market cap historical data you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,OHLC,VOLUME
     * @param {number} [limit] The number of data points to return
     * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
     * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
     * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
     * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OverviewApi
     */
    public overviewV1HistoricalMarketcapFtwAssetsDays(groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, responseFormat?: 'JSON' | 'CSV', options?: AxiosRequestConfig) {
        return OverviewApiFp(this.configuration).overviewV1HistoricalMarketcapFtwAssetsDays(groups, limit, toTs, aggregate, fill, responseFormat, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<string>} [groups] When requesting ftw universe market cap historical data you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,OHLC,VOLUME
     * @param {number} [limit] The number of data points to return
     * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
     * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
     * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
     * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OverviewApi
     */
    public overviewV1HistoricalMarketcapFtwAssetsHours(groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, responseFormat?: 'JSON' | 'CSV', options?: AxiosRequestConfig) {
        return OverviewApiFp(this.configuration).overviewV1HistoricalMarketcapFtwAssetsHours(groups, limit, toTs, aggregate, fill, responseFormat, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<string>} [groups] When requesting all market cap tick data you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,VALUE,LAST_UPDATE,CURRENT_HOUR,CURRENT_DAY,MOVING_24_HOUR
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OverviewApi
     */
    public overviewV1LatestMarketcapAllTick(groups?: Array<string>, options?: AxiosRequestConfig) {
        return OverviewApiFp(this.configuration).overviewV1LatestMarketcapAllTick(groups, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<string>} [groups] When requesting ftw universe market cap tick data you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,VALUE,LAST_UPDATE,CURRENT_HOUR,CURRENT_DAY,MOVING_24_HOUR
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OverviewApi
     */
    public overviewV1LatestMarketcapFtwTick(groups?: Array<string>, options?: AxiosRequestConfig) {
        return OverviewApiFp(this.configuration).overviewV1LatestMarketcapFtwTick(groups, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ReferenceRatesApi - axios parameter creator
 * @export
 */
export const ReferenceRatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,OHLC,OHLC_MESSAGE,MESSAGE,VOLUME
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexCcV1HistoricalDays: async (market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'market' is not null or undefined
            assertParamExists('indexCcV1HistoricalDays', 'market', market)
            // verify required parameter 'instrument' is not null or undefined
            assertParamExists('indexCcV1HistoricalDays', 'instrument', instrument)
            const localVarPath = `/index/cc/v1/historical/days`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (market !== undefined) {
                localVarQueryParameter['market'] = market;
            }

            if (instrument !== undefined) {
                localVarQueryParameter['instrument'] = instrument;
            }

            if (groups) {
                localVarQueryParameter['groups'] = groups.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (toTs !== undefined) {
                localVarQueryParameter['to_ts'] = toTs;
            }

            if (aggregate !== undefined) {
                localVarQueryParameter['aggregate'] = aggregate;
            }

            if (fill !== undefined) {
                localVarQueryParameter['fill'] = fill;
            }

            if (mappingPriority !== undefined) {
                localVarQueryParameter['mapping_priority'] = mappingPriority;
            }

            if (responseFormat !== undefined) {
                localVarQueryParameter['response_format'] = responseFormat;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,OHLC,OHLC_MESSAGE,MESSAGE,VOLUME
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexCcV1HistoricalHours: async (market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'market' is not null or undefined
            assertParamExists('indexCcV1HistoricalHours', 'market', market)
            // verify required parameter 'instrument' is not null or undefined
            assertParamExists('indexCcV1HistoricalHours', 'instrument', instrument)
            const localVarPath = `/index/cc/v1/historical/hours`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (market !== undefined) {
                localVarQueryParameter['market'] = market;
            }

            if (instrument !== undefined) {
                localVarQueryParameter['instrument'] = instrument;
            }

            if (groups) {
                localVarQueryParameter['groups'] = groups.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (toTs !== undefined) {
                localVarQueryParameter['to_ts'] = toTs;
            }

            if (aggregate !== undefined) {
                localVarQueryParameter['aggregate'] = aggregate;
            }

            if (fill !== undefined) {
                localVarQueryParameter['fill'] = fill;
            }

            if (mappingPriority !== undefined) {
                localVarQueryParameter['mapping_priority'] = mappingPriority;
            }

            if (responseFormat !== undefined) {
                localVarQueryParameter['response_format'] = responseFormat;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {number} [afterTs] Unix timestamp in seconds of the earliest index message in the response
         * @param {number} [lastCcseq] The CCSEQ of the last message seen in the previous request. Useful for pagination within messages that happened in the same second. It will look though the messages in the same second and discard all messages until it reaches the CCSEQ from the last_ccseq parameter. If the CCSEQ is not part of that second, it will discard all messages in the second and only return messages starting from the next second onwards. When starting an integration with our API, on the first request, you should either not send a value for this paramater (defaults to 0 and does not discard any messages) or send 0. After you get a response use the TIMESTAMP and CCSEQ from the last message in the response. Pass the TIMESTAMP in the after_ts parameter and the CCSEQ in the last_ccseq parameter on your next request.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {number} [limit] The maximum number of index messages to return
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {boolean} [return404OnEmptyResponse] If set to false (default) then when there are no items to return, you will get a response status code of 200 and an empty JSON array or a CSV file with just the header. If set to true then when there are no items you will get a 404 status code for both JSON and CSV response_formats.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexCcV1HistoricalMessages: async (market: string, instrument: string, afterTs?: number, lastCcseq?: number, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', limit?: number, responseFormat?: 'JSON' | 'CSV', return404OnEmptyResponse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'market' is not null or undefined
            assertParamExists('indexCcV1HistoricalMessages', 'market', market)
            // verify required parameter 'instrument' is not null or undefined
            assertParamExists('indexCcV1HistoricalMessages', 'instrument', instrument)
            const localVarPath = `/index/cc/v1/historical/messages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)

            if (market !== undefined) {
                localVarQueryParameter['market'] = market;
            }

            if (instrument !== undefined) {
                localVarQueryParameter['instrument'] = instrument;
            }

            if (afterTs !== undefined) {
                localVarQueryParameter['after_ts'] = afterTs;
            }

            if (lastCcseq !== undefined) {
                localVarQueryParameter['last_ccseq'] = lastCcseq;
            }

            if (mappingPriority !== undefined) {
                localVarQueryParameter['mapping_priority'] = mappingPriority;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (responseFormat !== undefined) {
                localVarQueryParameter['response_format'] = responseFormat;
            }

            if (return404OnEmptyResponse !== undefined) {
                localVarQueryParameter['return_404_on_empty_response'] = return404OnEmptyResponse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {number} [hourTs] Unix timestamp in seconds for the hour containing the index updates you are interested in. You can pass any timestamp in the hour but we will round it down the the full hour timestmap and return all index updates in that hour.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {boolean} [return404OnEmptyResponse] If set to false (default) then when there are no items to return, you will get a response status code of 200 and an empty JSON array or a CSV file with just the header. If set to true then when there are no items you will get a 404 status code for both JSON and CSV response_formats.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexCcV1HistoricalMessagesHour: async (market: string, instrument: string, hourTs?: number, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', return404OnEmptyResponse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'market' is not null or undefined
            assertParamExists('indexCcV1HistoricalMessagesHour', 'market', market)
            // verify required parameter 'instrument' is not null or undefined
            assertParamExists('indexCcV1HistoricalMessagesHour', 'instrument', instrument)
            const localVarPath = `/index/cc/v1/historical/messages/hour`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)

            if (market !== undefined) {
                localVarQueryParameter['market'] = market;
            }

            if (instrument !== undefined) {
                localVarQueryParameter['instrument'] = instrument;
            }

            if (hourTs !== undefined) {
                localVarQueryParameter['hour_ts'] = hourTs;
            }

            if (mappingPriority !== undefined) {
                localVarQueryParameter['mapping_priority'] = mappingPriority;
            }

            if (responseFormat !== undefined) {
                localVarQueryParameter['response_format'] = responseFormat;
            }

            if (return404OnEmptyResponse !== undefined) {
                localVarQueryParameter['return_404_on_empty_response'] = return404OnEmptyResponse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,OHLC,OHLC_MESSAGE,MESSAGE,VOLUME
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexCcV1HistoricalMinutes: async (market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'market' is not null or undefined
            assertParamExists('indexCcV1HistoricalMinutes', 'market', market)
            // verify required parameter 'instrument' is not null or undefined
            assertParamExists('indexCcV1HistoricalMinutes', 'instrument', instrument)
            const localVarPath = `/index/cc/v1/historical/minutes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (market !== undefined) {
                localVarQueryParameter['market'] = market;
            }

            if (instrument !== undefined) {
                localVarQueryParameter['instrument'] = instrument;
            }

            if (groups) {
                localVarQueryParameter['groups'] = groups.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (toTs !== undefined) {
                localVarQueryParameter['to_ts'] = toTs;
            }

            if (aggregate !== undefined) {
                localVarQueryParameter['aggregate'] = aggregate;
            }

            if (fill !== undefined) {
                localVarQueryParameter['fill'] = fill;
            }

            if (mappingPriority !== undefined) {
                localVarQueryParameter['mapping_priority'] = mappingPriority;
            }

            if (responseFormat !== undefined) {
                localVarQueryParameter['response_format'] = responseFormat;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {Array<string>} instruments A comma separated array of mapped and/or unmapped instruments to retrieve for a specific market (you can use either the instrument XXBTZUSD or mapped instrument (base - quote) BTC-USD on kraken as an example). We first check each instrument against the mapped list and then against the unmapped list but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting metadata entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: STATUS,INTERNAL,GENERAL,MIGRATION,SOURCE
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexCcV1LatestInstrumentMetadata: async (market: string, instruments: Array<string>, groups?: Array<string>, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'market' is not null or undefined
            assertParamExists('indexCcV1LatestInstrumentMetadata', 'market', market)
            // verify required parameter 'instruments' is not null or undefined
            assertParamExists('indexCcV1LatestInstrumentMetadata', 'instruments', instruments)
            const localVarPath = `/index/cc/v1/latest/instrument/metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (market !== undefined) {
                localVarQueryParameter['market'] = market;
            }

            if (instruments) {
                localVarQueryParameter['instruments'] = instruments.join(COLLECTION_FORMATS.csv);
            }

            if (groups) {
                localVarQueryParameter['groups'] = groups.join(COLLECTION_FORMATS.csv);
            }

            if (mappingPriority !== undefined) {
                localVarQueryParameter['mapping_priority'] = mappingPriority;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {Array<string>} instruments A comma separated array of mapped and/or unmapped instruments to retrieve for a specific market (you can use either the instrument XXBTZUSD or mapped instrument (base - quote) BTC-USD on kraken as an example). We first check each instrument against the mapped list and then against the unmapped list but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting tick data you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,VALUE,LAST_UPDATE,CURRENT_HOUR,CURRENT_DAY,CURRENT_WEEK,CURRENT_MONTH,CURRENT_YEAR,MOVING_24_HOUR,MOVING_7_DAY,MOVING_30_DAY,MOVING_90_DAY,MOVING_180_DAY,MOVING_365_DAY,LIFETIME
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexCcV1LatestTick: async (market: string, instruments: Array<string>, groups?: Array<string>, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'market' is not null or undefined
            assertParamExists('indexCcV1LatestTick', 'market', market)
            // verify required parameter 'instruments' is not null or undefined
            assertParamExists('indexCcV1LatestTick', 'instruments', instruments)
            const localVarPath = `/index/cc/v1/latest/tick`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (market !== undefined) {
                localVarQueryParameter['market'] = market;
            }

            if (instruments) {
                localVarQueryParameter['instruments'] = instruments.join(COLLECTION_FORMATS.csv);
            }

            if (groups) {
                localVarQueryParameter['groups'] = groups.join(COLLECTION_FORMATS.csv);
            }

            if (mappingPriority !== undefined) {
                localVarQueryParameter['mapping_priority'] = mappingPriority;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [market] The exchange to obtain data from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexCcV1Markets: async (market?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/index/cc/v1/markets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (market !== undefined) {
                localVarQueryParameter['market'] = market;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [market] The exchange to obtain data from
         * @param {string} [instrument] The mapped instrument to retrieve on a specific market.
         * @param {Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>} [instrumentStatus] The status of the instrument, can be one of the following: ACTIVE, IGNORED, RETIRED, EXPIRED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexCcV1MarketsInstruments: async (market?: string, instrument?: string, instrumentStatus?: Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/index/cc/v1/markets/instruments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (market !== undefined) {
                localVarQueryParameter['market'] = market;
            }

            if (instrument !== undefined) {
                localVarQueryParameter['instrument'] = instrument;
            }

            if (instrumentStatus) {
                localVarQueryParameter['instrument_status'] = instrumentStatus.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [market] The exchange to obtain data from
         * @param {string} [instrument] The unmapped instrument to retrieve on a specific market.
         * @param {Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>} [instrumentStatus] The status of the instrument, can be one of the following: ACTIVE, IGNORED, RETIRED, EXPIRED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexCcV1MarketsInstrumentsUnmapped: async (market?: string, instrument?: string, instrumentStatus?: Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/index/cc/v1/markets/instruments/unmapped`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (market !== undefined) {
                localVarQueryParameter['market'] = market;
            }

            if (instrument !== undefined) {
                localVarQueryParameter['instrument'] = instrument;
            }

            if (instrumentStatus) {
                localVarQueryParameter['instrument_status'] = instrumentStatus.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReferenceRatesApi - functional programming interface
 * @export
 */
export const ReferenceRatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReferenceRatesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,OHLC,OHLC_MESSAGE,MESSAGE,VOLUME
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async indexCcV1HistoricalDays(market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.indexCcV1HistoricalDays(market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,OHLC,OHLC_MESSAGE,MESSAGE,VOLUME
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async indexCcV1HistoricalHours(market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.indexCcV1HistoricalHours(market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {number} [afterTs] Unix timestamp in seconds of the earliest index message in the response
         * @param {number} [lastCcseq] The CCSEQ of the last message seen in the previous request. Useful for pagination within messages that happened in the same second. It will look though the messages in the same second and discard all messages until it reaches the CCSEQ from the last_ccseq parameter. If the CCSEQ is not part of that second, it will discard all messages in the second and only return messages starting from the next second onwards. When starting an integration with our API, on the first request, you should either not send a value for this paramater (defaults to 0 and does not discard any messages) or send 0. After you get a response use the TIMESTAMP and CCSEQ from the last message in the response. Pass the TIMESTAMP in the after_ts parameter and the CCSEQ in the last_ccseq parameter on your next request.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {number} [limit] The maximum number of index messages to return
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {boolean} [return404OnEmptyResponse] If set to false (default) then when there are no items to return, you will get a response status code of 200 and an empty JSON array or a CSV file with just the header. If set to true then when there are no items you will get a 404 status code for both JSON and CSV response_formats.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async indexCcV1HistoricalMessages(market: string, instrument: string, afterTs?: number, lastCcseq?: number, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', limit?: number, responseFormat?: 'JSON' | 'CSV', return404OnEmptyResponse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.indexCcV1HistoricalMessages(market, instrument, afterTs, lastCcseq, mappingPriority, limit, responseFormat, return404OnEmptyResponse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {number} [hourTs] Unix timestamp in seconds for the hour containing the index updates you are interested in. You can pass any timestamp in the hour but we will round it down the the full hour timestmap and return all index updates in that hour.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {boolean} [return404OnEmptyResponse] If set to false (default) then when there are no items to return, you will get a response status code of 200 and an empty JSON array or a CSV file with just the header. If set to true then when there are no items you will get a 404 status code for both JSON and CSV response_formats.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async indexCcV1HistoricalMessagesHour(market: string, instrument: string, hourTs?: number, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', return404OnEmptyResponse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.indexCcV1HistoricalMessagesHour(market, instrument, hourTs, mappingPriority, responseFormat, return404OnEmptyResponse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,OHLC,OHLC_MESSAGE,MESSAGE,VOLUME
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async indexCcV1HistoricalMinutes(market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.indexCcV1HistoricalMinutes(market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {Array<string>} instruments A comma separated array of mapped and/or unmapped instruments to retrieve for a specific market (you can use either the instrument XXBTZUSD or mapped instrument (base - quote) BTC-USD on kraken as an example). We first check each instrument against the mapped list and then against the unmapped list but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting metadata entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: STATUS,INTERNAL,GENERAL,MIGRATION,SOURCE
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async indexCcV1LatestInstrumentMetadata(market: string, instruments: Array<string>, groups?: Array<string>, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.indexCcV1LatestInstrumentMetadata(market, instruments, groups, mappingPriority, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {Array<string>} instruments A comma separated array of mapped and/or unmapped instruments to retrieve for a specific market (you can use either the instrument XXBTZUSD or mapped instrument (base - quote) BTC-USD on kraken as an example). We first check each instrument against the mapped list and then against the unmapped list but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting tick data you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,VALUE,LAST_UPDATE,CURRENT_HOUR,CURRENT_DAY,CURRENT_WEEK,CURRENT_MONTH,CURRENT_YEAR,MOVING_24_HOUR,MOVING_7_DAY,MOVING_30_DAY,MOVING_90_DAY,MOVING_180_DAY,MOVING_365_DAY,LIFETIME
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async indexCcV1LatestTick(market: string, instruments: Array<string>, groups?: Array<string>, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.indexCcV1LatestTick(market, instruments, groups, mappingPriority, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [market] The exchange to obtain data from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async indexCcV1Markets(market?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.indexCcV1Markets(market, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [market] The exchange to obtain data from
         * @param {string} [instrument] The mapped instrument to retrieve on a specific market.
         * @param {Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>} [instrumentStatus] The status of the instrument, can be one of the following: ACTIVE, IGNORED, RETIRED, EXPIRED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async indexCcV1MarketsInstruments(market?: string, instrument?: string, instrumentStatus?: Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.indexCcV1MarketsInstruments(market, instrument, instrumentStatus, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [market] The exchange to obtain data from
         * @param {string} [instrument] The unmapped instrument to retrieve on a specific market.
         * @param {Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>} [instrumentStatus] The status of the instrument, can be one of the following: ACTIVE, IGNORED, RETIRED, EXPIRED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async indexCcV1MarketsInstrumentsUnmapped(market?: string, instrument?: string, instrumentStatus?: Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.indexCcV1MarketsInstrumentsUnmapped(market, instrument, instrumentStatus, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ReferenceRatesApi - factory interface
 * @export
 */
export const ReferenceRatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReferenceRatesApiFp(configuration)
    return {
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,OHLC,OHLC_MESSAGE,MESSAGE,VOLUME
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexCcV1HistoricalDays(market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.indexCcV1HistoricalDays(market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,OHLC,OHLC_MESSAGE,MESSAGE,VOLUME
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexCcV1HistoricalHours(market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.indexCcV1HistoricalHours(market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {number} [afterTs] Unix timestamp in seconds of the earliest index message in the response
         * @param {number} [lastCcseq] The CCSEQ of the last message seen in the previous request. Useful for pagination within messages that happened in the same second. It will look though the messages in the same second and discard all messages until it reaches the CCSEQ from the last_ccseq parameter. If the CCSEQ is not part of that second, it will discard all messages in the second and only return messages starting from the next second onwards. When starting an integration with our API, on the first request, you should either not send a value for this paramater (defaults to 0 and does not discard any messages) or send 0. After you get a response use the TIMESTAMP and CCSEQ from the last message in the response. Pass the TIMESTAMP in the after_ts parameter and the CCSEQ in the last_ccseq parameter on your next request.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {number} [limit] The maximum number of index messages to return
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {boolean} [return404OnEmptyResponse] If set to false (default) then when there are no items to return, you will get a response status code of 200 and an empty JSON array or a CSV file with just the header. If set to true then when there are no items you will get a 404 status code for both JSON and CSV response_formats.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexCcV1HistoricalMessages(market: string, instrument: string, afterTs?: number, lastCcseq?: number, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', limit?: number, responseFormat?: 'JSON' | 'CSV', return404OnEmptyResponse?: boolean, options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.indexCcV1HistoricalMessages(market, instrument, afterTs, lastCcseq, mappingPriority, limit, responseFormat, return404OnEmptyResponse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {number} [hourTs] Unix timestamp in seconds for the hour containing the index updates you are interested in. You can pass any timestamp in the hour but we will round it down the the full hour timestmap and return all index updates in that hour.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {boolean} [return404OnEmptyResponse] If set to false (default) then when there are no items to return, you will get a response status code of 200 and an empty JSON array or a CSV file with just the header. If set to true then when there are no items you will get a 404 status code for both JSON and CSV response_formats.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexCcV1HistoricalMessagesHour(market: string, instrument: string, hourTs?: number, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', return404OnEmptyResponse?: boolean, options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.indexCcV1HistoricalMessagesHour(market, instrument, hourTs, mappingPriority, responseFormat, return404OnEmptyResponse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,OHLC,OHLC_MESSAGE,MESSAGE,VOLUME
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexCcV1HistoricalMinutes(market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.indexCcV1HistoricalMinutes(market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {Array<string>} instruments A comma separated array of mapped and/or unmapped instruments to retrieve for a specific market (you can use either the instrument XXBTZUSD or mapped instrument (base - quote) BTC-USD on kraken as an example). We first check each instrument against the mapped list and then against the unmapped list but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting metadata entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: STATUS,INTERNAL,GENERAL,MIGRATION,SOURCE
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexCcV1LatestInstrumentMetadata(market: string, instruments: Array<string>, groups?: Array<string>, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.indexCcV1LatestInstrumentMetadata(market, instruments, groups, mappingPriority, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {Array<string>} instruments A comma separated array of mapped and/or unmapped instruments to retrieve for a specific market (you can use either the instrument XXBTZUSD or mapped instrument (base - quote) BTC-USD on kraken as an example). We first check each instrument against the mapped list and then against the unmapped list but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting tick data you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,VALUE,LAST_UPDATE,CURRENT_HOUR,CURRENT_DAY,CURRENT_WEEK,CURRENT_MONTH,CURRENT_YEAR,MOVING_24_HOUR,MOVING_7_DAY,MOVING_30_DAY,MOVING_90_DAY,MOVING_180_DAY,MOVING_365_DAY,LIFETIME
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexCcV1LatestTick(market: string, instruments: Array<string>, groups?: Array<string>, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.indexCcV1LatestTick(market, instruments, groups, mappingPriority, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [market] The exchange to obtain data from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexCcV1Markets(market?: string, options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.indexCcV1Markets(market, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [market] The exchange to obtain data from
         * @param {string} [instrument] The mapped instrument to retrieve on a specific market.
         * @param {Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>} [instrumentStatus] The status of the instrument, can be one of the following: ACTIVE, IGNORED, RETIRED, EXPIRED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexCcV1MarketsInstruments(market?: string, instrument?: string, instrumentStatus?: Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>, options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.indexCcV1MarketsInstruments(market, instrument, instrumentStatus, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [market] The exchange to obtain data from
         * @param {string} [instrument] The unmapped instrument to retrieve on a specific market.
         * @param {Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>} [instrumentStatus] The status of the instrument, can be one of the following: ACTIVE, IGNORED, RETIRED, EXPIRED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexCcV1MarketsInstrumentsUnmapped(market?: string, instrument?: string, instrumentStatus?: Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>, options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.indexCcV1MarketsInstrumentsUnmapped(market, instrument, instrumentStatus, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReferenceRatesApi - object-oriented interface
 * @export
 * @class ReferenceRatesApi
 * @extends {BaseAPI}
 */
export class ReferenceRatesApi extends BaseAPI {
    /**
     * 
     * @param {string} market The exchange to obtain data from
     * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
     * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,OHLC,OHLC_MESSAGE,MESSAGE,VOLUME
     * @param {number} [limit] The number of data points to return
     * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
     * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
     * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
     * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
     * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferenceRatesApi
     */
    public indexCcV1HistoricalDays(market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options?: AxiosRequestConfig) {
        return ReferenceRatesApiFp(this.configuration).indexCcV1HistoricalDays(market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} market The exchange to obtain data from
     * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
     * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,OHLC,OHLC_MESSAGE,MESSAGE,VOLUME
     * @param {number} [limit] The number of data points to return
     * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
     * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
     * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
     * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
     * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferenceRatesApi
     */
    public indexCcV1HistoricalHours(market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options?: AxiosRequestConfig) {
        return ReferenceRatesApiFp(this.configuration).indexCcV1HistoricalHours(market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} market The exchange to obtain data from
     * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
     * @param {number} [afterTs] Unix timestamp in seconds of the earliest index message in the response
     * @param {number} [lastCcseq] The CCSEQ of the last message seen in the previous request. Useful for pagination within messages that happened in the same second. It will look though the messages in the same second and discard all messages until it reaches the CCSEQ from the last_ccseq parameter. If the CCSEQ is not part of that second, it will discard all messages in the second and only return messages starting from the next second onwards. When starting an integration with our API, on the first request, you should either not send a value for this paramater (defaults to 0 and does not discard any messages) or send 0. After you get a response use the TIMESTAMP and CCSEQ from the last message in the response. Pass the TIMESTAMP in the after_ts parameter and the CCSEQ in the last_ccseq parameter on your next request.
     * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
     * @param {number} [limit] The maximum number of index messages to return
     * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
     * @param {boolean} [return404OnEmptyResponse] If set to false (default) then when there are no items to return, you will get a response status code of 200 and an empty JSON array or a CSV file with just the header. If set to true then when there are no items you will get a 404 status code for both JSON and CSV response_formats.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferenceRatesApi
     */
    public indexCcV1HistoricalMessages(market: string, instrument: string, afterTs?: number, lastCcseq?: number, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', limit?: number, responseFormat?: 'JSON' | 'CSV', return404OnEmptyResponse?: boolean, options?: AxiosRequestConfig) {
        return ReferenceRatesApiFp(this.configuration).indexCcV1HistoricalMessages(market, instrument, afterTs, lastCcseq, mappingPriority, limit, responseFormat, return404OnEmptyResponse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} market The exchange to obtain data from
     * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
     * @param {number} [hourTs] Unix timestamp in seconds for the hour containing the index updates you are interested in. You can pass any timestamp in the hour but we will round it down the the full hour timestmap and return all index updates in that hour.
     * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
     * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
     * @param {boolean} [return404OnEmptyResponse] If set to false (default) then when there are no items to return, you will get a response status code of 200 and an empty JSON array or a CSV file with just the header. If set to true then when there are no items you will get a 404 status code for both JSON and CSV response_formats.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferenceRatesApi
     */
    public indexCcV1HistoricalMessagesHour(market: string, instrument: string, hourTs?: number, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', return404OnEmptyResponse?: boolean, options?: AxiosRequestConfig) {
        return ReferenceRatesApiFp(this.configuration).indexCcV1HistoricalMessagesHour(market, instrument, hourTs, mappingPriority, responseFormat, return404OnEmptyResponse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} market The exchange to obtain data from
     * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
     * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,OHLC,OHLC_MESSAGE,MESSAGE,VOLUME
     * @param {number} [limit] The number of data points to return
     * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
     * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
     * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
     * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
     * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferenceRatesApi
     */
    public indexCcV1HistoricalMinutes(market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options?: AxiosRequestConfig) {
        return ReferenceRatesApiFp(this.configuration).indexCcV1HistoricalMinutes(market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} market The exchange to obtain data from
     * @param {Array<string>} instruments A comma separated array of mapped and/or unmapped instruments to retrieve for a specific market (you can use either the instrument XXBTZUSD or mapped instrument (base - quote) BTC-USD on kraken as an example). We first check each instrument against the mapped list and then against the unmapped list but you can use the mapping_priority param to check the unmapped list first.
     * @param {Array<string>} [groups] When requesting metadata entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: STATUS,INTERNAL,GENERAL,MIGRATION,SOURCE
     * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferenceRatesApi
     */
    public indexCcV1LatestInstrumentMetadata(market: string, instruments: Array<string>, groups?: Array<string>, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', options?: AxiosRequestConfig) {
        return ReferenceRatesApiFp(this.configuration).indexCcV1LatestInstrumentMetadata(market, instruments, groups, mappingPriority, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} market The exchange to obtain data from
     * @param {Array<string>} instruments A comma separated array of mapped and/or unmapped instruments to retrieve for a specific market (you can use either the instrument XXBTZUSD or mapped instrument (base - quote) BTC-USD on kraken as an example). We first check each instrument against the mapped list and then against the unmapped list but you can use the mapping_priority param to check the unmapped list first.
     * @param {Array<string>} [groups] When requesting tick data you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,VALUE,LAST_UPDATE,CURRENT_HOUR,CURRENT_DAY,CURRENT_WEEK,CURRENT_MONTH,CURRENT_YEAR,MOVING_24_HOUR,MOVING_7_DAY,MOVING_30_DAY,MOVING_90_DAY,MOVING_180_DAY,MOVING_365_DAY,LIFETIME
     * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferenceRatesApi
     */
    public indexCcV1LatestTick(market: string, instruments: Array<string>, groups?: Array<string>, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', options?: AxiosRequestConfig) {
        return ReferenceRatesApiFp(this.configuration).indexCcV1LatestTick(market, instruments, groups, mappingPriority, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [market] The exchange to obtain data from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferenceRatesApi
     */
    public indexCcV1Markets(market?: string, options?: AxiosRequestConfig) {
        return ReferenceRatesApiFp(this.configuration).indexCcV1Markets(market, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [market] The exchange to obtain data from
     * @param {string} [instrument] The mapped instrument to retrieve on a specific market.
     * @param {Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>} [instrumentStatus] The status of the instrument, can be one of the following: ACTIVE, IGNORED, RETIRED, EXPIRED
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferenceRatesApi
     */
    public indexCcV1MarketsInstruments(market?: string, instrument?: string, instrumentStatus?: Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>, options?: AxiosRequestConfig) {
        return ReferenceRatesApiFp(this.configuration).indexCcV1MarketsInstruments(market, instrument, instrumentStatus, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [market] The exchange to obtain data from
     * @param {string} [instrument] The unmapped instrument to retrieve on a specific market.
     * @param {Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>} [instrumentStatus] The status of the instrument, can be one of the following: ACTIVE, IGNORED, RETIRED, EXPIRED
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferenceRatesApi
     */
    public indexCcV1MarketsInstrumentsUnmapped(market?: string, instrument?: string, instrumentStatus?: Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>, options?: AxiosRequestConfig) {
        return ReferenceRatesApiFp(this.configuration).indexCcV1MarketsInstrumentsUnmapped(market, instrument, instrumentStatus, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SpotApi - axios parameter creator
 * @export
 */
export const SpotApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,OHLC,OHLC_TRADE,TRADE,VOLUME
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotV1HistoricalDays: async (market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'market' is not null or undefined
            assertParamExists('spotV1HistoricalDays', 'market', market)
            // verify required parameter 'instrument' is not null or undefined
            assertParamExists('spotV1HistoricalDays', 'instrument', instrument)
            const localVarPath = `/spot/v1/historical/days`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (market !== undefined) {
                localVarQueryParameter['market'] = market;
            }

            if (instrument !== undefined) {
                localVarQueryParameter['instrument'] = instrument;
            }

            if (groups) {
                localVarQueryParameter['groups'] = groups.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (toTs !== undefined) {
                localVarQueryParameter['to_ts'] = toTs;
            }

            if (aggregate !== undefined) {
                localVarQueryParameter['aggregate'] = aggregate;
            }

            if (fill !== undefined) {
                localVarQueryParameter['fill'] = fill;
            }

            if (mappingPriority !== undefined) {
                localVarQueryParameter['mapping_priority'] = mappingPriority;
            }

            if (responseFormat !== undefined) {
                localVarQueryParameter['response_format'] = responseFormat;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,OHLC,OHLC_TRADE,TRADE,VOLUME
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotV1HistoricalHours: async (market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'market' is not null or undefined
            assertParamExists('spotV1HistoricalHours', 'market', market)
            // verify required parameter 'instrument' is not null or undefined
            assertParamExists('spotV1HistoricalHours', 'instrument', instrument)
            const localVarPath = `/spot/v1/historical/hours`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (market !== undefined) {
                localVarQueryParameter['market'] = market;
            }

            if (instrument !== undefined) {
                localVarQueryParameter['instrument'] = instrument;
            }

            if (groups) {
                localVarQueryParameter['groups'] = groups.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (toTs !== undefined) {
                localVarQueryParameter['to_ts'] = toTs;
            }

            if (aggregate !== undefined) {
                localVarQueryParameter['aggregate'] = aggregate;
            }

            if (fill !== undefined) {
                localVarQueryParameter['fill'] = fill;
            }

            if (mappingPriority !== undefined) {
                localVarQueryParameter['mapping_priority'] = mappingPriority;
            }

            if (responseFormat !== undefined) {
                localVarQueryParameter['response_format'] = responseFormat;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,OHLC,OHLC_TRADE,TRADE,VOLUME
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotV1HistoricalMinutes: async (market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'market' is not null or undefined
            assertParamExists('spotV1HistoricalMinutes', 'market', market)
            // verify required parameter 'instrument' is not null or undefined
            assertParamExists('spotV1HistoricalMinutes', 'instrument', instrument)
            const localVarPath = `/spot/v1/historical/minutes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (market !== undefined) {
                localVarQueryParameter['market'] = market;
            }

            if (instrument !== undefined) {
                localVarQueryParameter['instrument'] = instrument;
            }

            if (groups) {
                localVarQueryParameter['groups'] = groups.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (toTs !== undefined) {
                localVarQueryParameter['to_ts'] = toTs;
            }

            if (aggregate !== undefined) {
                localVarQueryParameter['aggregate'] = aggregate;
            }

            if (fill !== undefined) {
                localVarQueryParameter['fill'] = fill;
            }

            if (mappingPriority !== undefined) {
                localVarQueryParameter['mapping_priority'] = mappingPriority;
            }

            if (responseFormat !== undefined) {
                localVarQueryParameter['response_format'] = responseFormat;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {number} minuteTs Unix timestamp in seconds for the minute of the orderbook snapshot you are interested in. You can pass any timestamp within a minute but we will round it down the the full minute timestmap and return the orderbook l2 snapshot at that minute.
         * @param {number} [depth] The number of top bids and asks to return.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotV1HistoricalOrderbookL2SnapshotMinute: async (market: string, instrument: string, minuteTs: number, depth?: number, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'market' is not null or undefined
            assertParamExists('spotV1HistoricalOrderbookL2SnapshotMinute', 'market', market)
            // verify required parameter 'instrument' is not null or undefined
            assertParamExists('spotV1HistoricalOrderbookL2SnapshotMinute', 'instrument', instrument)
            // verify required parameter 'minuteTs' is not null or undefined
            assertParamExists('spotV1HistoricalOrderbookL2SnapshotMinute', 'minuteTs', minuteTs)
            const localVarPath = `/spot/v1/historical/orderbook/l2/snapshot/minute`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)

            if (market !== undefined) {
                localVarQueryParameter['market'] = market;
            }

            if (instrument !== undefined) {
                localVarQueryParameter['instrument'] = instrument;
            }

            if (minuteTs !== undefined) {
                localVarQueryParameter['minute_ts'] = minuteTs;
            }

            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if (mappingPriority !== undefined) {
                localVarQueryParameter['mapping_priority'] = mappingPriority;
            }

            if (responseFormat !== undefined) {
                localVarQueryParameter['response_format'] = responseFormat;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {number} [afterTs] Unix timestamp in seconds of the earliest trade in the response.
         * @param {number} [lastCcseq] The CCSEQ of the last message seen in the previous request. Useful for pagination within messages that happened in the same second. It will look though the messages in the same second and discard all messages until it reaches the CCSEQ from the last_ccseq parameter. If the CCSEQ is not part of that second, it will discard all messages in the second and only return messages starting from the next second onwards. When starting an integration with our API, on the first request, you should either not send a value for this paramater (defaults to 0 and does not discard any messages) or send 0. After you get a response use the TIMESTAMP and CCSEQ from the last message in the response. Pass the TIMESTAMP in the after_ts parameter and the CCSEQ in the last_ccseq parameter on your next request.
         * @param {number} [limit] The maximum number of trades to return
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {boolean} [return404OnEmptyResponse] If set to false (default) then when there are no items to return, you will get a response status code of 200 and an empty JSON array or a CSV file with just the header. If set to true then when there are no items you will get a 404 status code for both JSON and CSV response_formats.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotV1HistoricalTrades: async (market: string, instrument: string, afterTs?: number, lastCcseq?: number, limit?: number, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', return404OnEmptyResponse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'market' is not null or undefined
            assertParamExists('spotV1HistoricalTrades', 'market', market)
            // verify required parameter 'instrument' is not null or undefined
            assertParamExists('spotV1HistoricalTrades', 'instrument', instrument)
            const localVarPath = `/spot/v1/historical/trades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)

            if (market !== undefined) {
                localVarQueryParameter['market'] = market;
            }

            if (instrument !== undefined) {
                localVarQueryParameter['instrument'] = instrument;
            }

            if (afterTs !== undefined) {
                localVarQueryParameter['after_ts'] = afterTs;
            }

            if (lastCcseq !== undefined) {
                localVarQueryParameter['last_ccseq'] = lastCcseq;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (mappingPriority !== undefined) {
                localVarQueryParameter['mapping_priority'] = mappingPriority;
            }

            if (responseFormat !== undefined) {
                localVarQueryParameter['response_format'] = responseFormat;
            }

            if (return404OnEmptyResponse !== undefined) {
                localVarQueryParameter['return_404_on_empty_response'] = return404OnEmptyResponse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {number} [hourTs] Unix timestamp in seconds for the hour containing the trades you are interested in. You can pass any timestamp within an hour but we will round it down the the full hour timestmap and return all trades in that hour.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {boolean} [return404OnEmptyResponse] If set to false (default) then when there are no items to return, you will get a response status code of 200 and an empty JSON array or a CSV file with just the header. If set to true then when there are no items you will get a 404 status code for both JSON and CSV response_formats.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotV1HistoricalTradesHour: async (market: string, instrument: string, hourTs?: number, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', return404OnEmptyResponse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'market' is not null or undefined
            assertParamExists('spotV1HistoricalTradesHour', 'market', market)
            // verify required parameter 'instrument' is not null or undefined
            assertParamExists('spotV1HistoricalTradesHour', 'instrument', instrument)
            const localVarPath = `/spot/v1/historical/trades/hour`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)

            if (market !== undefined) {
                localVarQueryParameter['market'] = market;
            }

            if (instrument !== undefined) {
                localVarQueryParameter['instrument'] = instrument;
            }

            if (hourTs !== undefined) {
                localVarQueryParameter['hour_ts'] = hourTs;
            }

            if (mappingPriority !== undefined) {
                localVarQueryParameter['mapping_priority'] = mappingPriority;
            }

            if (responseFormat !== undefined) {
                localVarQueryParameter['response_format'] = responseFormat;
            }

            if (return404OnEmptyResponse !== undefined) {
                localVarQueryParameter['return_404_on_empty_response'] = return404OnEmptyResponse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {Array<string>} instruments A comma separated array of mapped and/or unmapped instruments to retrieve for a specific market (you can use either the instrument XXBTZUSD or mapped instrument (base - quote) BTC-USD on kraken as an example). We first check each instrument against the mapped list and then against the unmapped list but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting metadata entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: STATUS,INTERNAL,GENERAL,MIGRATION,SOURCE
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotV1LatestInstrumentMetadata: async (market: string, instruments: Array<string>, groups?: Array<string>, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'market' is not null or undefined
            assertParamExists('spotV1LatestInstrumentMetadata', 'market', market)
            // verify required parameter 'instruments' is not null or undefined
            assertParamExists('spotV1LatestInstrumentMetadata', 'instruments', instruments)
            const localVarPath = `/spot/v1/latest/instrument/metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (market !== undefined) {
                localVarQueryParameter['market'] = market;
            }

            if (instruments) {
                localVarQueryParameter['instruments'] = instruments.join(COLLECTION_FORMATS.csv);
            }

            if (groups) {
                localVarQueryParameter['groups'] = groups.join(COLLECTION_FORMATS.csv);
            }

            if (mappingPriority !== undefined) {
                localVarQueryParameter['mapping_priority'] = mappingPriority;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {Array<string>} instruments A comma separated array of mapped and/or unmapped instruments to retrieve for a specific market (you can use either the instrument XXBTZUSD or mapped instrument (base - quote) BTC-USD on kraken as an example). We first check each instrument against the mapped list and then against the unmapped list but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting tick data you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,VALUE,LAST_UPDATE,LAST_PROCESSED,TOP_OF_BOOK,CURRENT_HOUR,CURRENT_DAY,CURRENT_WEEK,CURRENT_MONTH,CURRENT_YEAR,MOVING_24_HOUR,MOVING_7_DAY,MOVING_30_DAY,MOVING_90_DAY,MOVING_180_DAY,MOVING_365_DAY,LIFETIME
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotV1LatestTick: async (market: string, instruments: Array<string>, groups?: Array<string>, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'market' is not null or undefined
            assertParamExists('spotV1LatestTick', 'market', market)
            // verify required parameter 'instruments' is not null or undefined
            assertParamExists('spotV1LatestTick', 'instruments', instruments)
            const localVarPath = `/spot/v1/latest/tick`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (market !== undefined) {
                localVarQueryParameter['market'] = market;
            }

            if (instruments) {
                localVarQueryParameter['instruments'] = instruments.join(COLLECTION_FORMATS.csv);
            }

            if (groups) {
                localVarQueryParameter['groups'] = groups.join(COLLECTION_FORMATS.csv);
            }

            if (mappingPriority !== undefined) {
                localVarQueryParameter['mapping_priority'] = mappingPriority;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [market] The exchange to obtain data from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotV1Markets: async (market?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/spot/v1/markets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (market !== undefined) {
                localVarQueryParameter['market'] = market;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [market] The exchange to obtain data from
         * @param {string} [instrument] The mapped instrument to retrieve on a specific market.
         * @param {Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>} [instrumentStatus] The status of the instrument, can be one of the following: ACTIVE, IGNORED, RETIRED, EXPIRED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotV1MarketsInstruments: async (market?: string, instrument?: string, instrumentStatus?: Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/spot/v1/markets/instruments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (market !== undefined) {
                localVarQueryParameter['market'] = market;
            }

            if (instrument !== undefined) {
                localVarQueryParameter['instrument'] = instrument;
            }

            if (instrumentStatus) {
                localVarQueryParameter['instrument_status'] = instrumentStatus.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [market] The exchange to obtain data from
         * @param {string} [instrument] The unmapped instrument to retrieve on a specific market.
         * @param {Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>} [instrumentStatus] The status of the instrument, can be one of the following: ACTIVE, IGNORED, RETIRED, EXPIRED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotV1MarketsInstrumentsUnmapped: async (market?: string, instrument?: string, instrumentStatus?: Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/spot/v1/markets/instruments/unmapped`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (market !== undefined) {
                localVarQueryParameter['market'] = market;
            }

            if (instrument !== undefined) {
                localVarQueryParameter['instrument'] = instrument;
            }

            if (instrumentStatus) {
                localVarQueryParameter['instrument_status'] = instrumentStatus.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SpotApi - functional programming interface
 * @export
 */
export const SpotApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SpotApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,OHLC,OHLC_TRADE,TRADE,VOLUME
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async spotV1HistoricalDays(market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SPOTINSTRUMENTHISTODATARESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.spotV1HistoricalDays(market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,OHLC,OHLC_TRADE,TRADE,VOLUME
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async spotV1HistoricalHours(market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SPOTINSTRUMENTHISTODATARESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.spotV1HistoricalHours(market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,OHLC,OHLC_TRADE,TRADE,VOLUME
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async spotV1HistoricalMinutes(market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SPOTINSTRUMENTHISTODATARESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.spotV1HistoricalMinutes(market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {number} minuteTs Unix timestamp in seconds for the minute of the orderbook snapshot you are interested in. You can pass any timestamp within a minute but we will round it down the the full minute timestmap and return the orderbook l2 snapshot at that minute.
         * @param {number} [depth] The number of top bids and asks to return.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async spotV1HistoricalOrderbookL2SnapshotMinute(market: string, instrument: string, minuteTs: number, depth?: number, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.spotV1HistoricalOrderbookL2SnapshotMinute(market, instrument, minuteTs, depth, mappingPriority, responseFormat, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {number} [afterTs] Unix timestamp in seconds of the earliest trade in the response.
         * @param {number} [lastCcseq] The CCSEQ of the last message seen in the previous request. Useful for pagination within messages that happened in the same second. It will look though the messages in the same second and discard all messages until it reaches the CCSEQ from the last_ccseq parameter. If the CCSEQ is not part of that second, it will discard all messages in the second and only return messages starting from the next second onwards. When starting an integration with our API, on the first request, you should either not send a value for this paramater (defaults to 0 and does not discard any messages) or send 0. After you get a response use the TIMESTAMP and CCSEQ from the last message in the response. Pass the TIMESTAMP in the after_ts parameter and the CCSEQ in the last_ccseq parameter on your next request.
         * @param {number} [limit] The maximum number of trades to return
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {boolean} [return404OnEmptyResponse] If set to false (default) then when there are no items to return, you will get a response status code of 200 and an empty JSON array or a CSV file with just the header. If set to true then when there are no items you will get a 404 status code for both JSON and CSV response_formats.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async spotV1HistoricalTrades(market: string, instrument: string, afterTs?: number, lastCcseq?: number, limit?: number, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', return404OnEmptyResponse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SPOTINSTRUMENTTRADERESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.spotV1HistoricalTrades(market, instrument, afterTs, lastCcseq, limit, mappingPriority, responseFormat, return404OnEmptyResponse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {number} [hourTs] Unix timestamp in seconds for the hour containing the trades you are interested in. You can pass any timestamp within an hour but we will round it down the the full hour timestmap and return all trades in that hour.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {boolean} [return404OnEmptyResponse] If set to false (default) then when there are no items to return, you will get a response status code of 200 and an empty JSON array or a CSV file with just the header. If set to true then when there are no items you will get a 404 status code for both JSON and CSV response_formats.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async spotV1HistoricalTradesHour(market: string, instrument: string, hourTs?: number, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', return404OnEmptyResponse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SPOTINSTRUMENTTRADERESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.spotV1HistoricalTradesHour(market, instrument, hourTs, mappingPriority, responseFormat, return404OnEmptyResponse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {Array<string>} instruments A comma separated array of mapped and/or unmapped instruments to retrieve for a specific market (you can use either the instrument XXBTZUSD or mapped instrument (base - quote) BTC-USD on kraken as an example). We first check each instrument against the mapped list and then against the unmapped list but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting metadata entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: STATUS,INTERNAL,GENERAL,MIGRATION,SOURCE
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async spotV1LatestInstrumentMetadata(market: string, instruments: Array<string>, groups?: Array<string>, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SPOTINSTRUMENTMETADATARESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.spotV1LatestInstrumentMetadata(market, instruments, groups, mappingPriority, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {Array<string>} instruments A comma separated array of mapped and/or unmapped instruments to retrieve for a specific market (you can use either the instrument XXBTZUSD or mapped instrument (base - quote) BTC-USD on kraken as an example). We first check each instrument against the mapped list and then against the unmapped list but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting tick data you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,VALUE,LAST_UPDATE,LAST_PROCESSED,TOP_OF_BOOK,CURRENT_HOUR,CURRENT_DAY,CURRENT_WEEK,CURRENT_MONTH,CURRENT_YEAR,MOVING_24_HOUR,MOVING_7_DAY,MOVING_30_DAY,MOVING_90_DAY,MOVING_180_DAY,MOVING_365_DAY,LIFETIME
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async spotV1LatestTick(market: string, instruments: Array<string>, groups?: Array<string>, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SPOTINSTRUMENTMARKETDATARESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.spotV1LatestTick(market, instruments, groups, mappingPriority, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [market] The exchange to obtain data from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async spotV1Markets(market?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.spotV1Markets(market, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [market] The exchange to obtain data from
         * @param {string} [instrument] The mapped instrument to retrieve on a specific market.
         * @param {Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>} [instrumentStatus] The status of the instrument, can be one of the following: ACTIVE, IGNORED, RETIRED, EXPIRED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async spotV1MarketsInstruments(market?: string, instrument?: string, instrumentStatus?: Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.spotV1MarketsInstruments(market, instrument, instrumentStatus, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [market] The exchange to obtain data from
         * @param {string} [instrument] The unmapped instrument to retrieve on a specific market.
         * @param {Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>} [instrumentStatus] The status of the instrument, can be one of the following: ACTIVE, IGNORED, RETIRED, EXPIRED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async spotV1MarketsInstrumentsUnmapped(market?: string, instrument?: string, instrumentStatus?: Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GENERICRESPONSE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.spotV1MarketsInstrumentsUnmapped(market, instrument, instrumentStatus, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SpotApi - factory interface
 * @export
 */
export const SpotApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SpotApiFp(configuration)
    return {
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,OHLC,OHLC_TRADE,TRADE,VOLUME
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotV1HistoricalDays(market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options?: any): AxiosPromise<SPOTINSTRUMENTHISTODATARESPONSE> {
            return localVarFp.spotV1HistoricalDays(market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,OHLC,OHLC_TRADE,TRADE,VOLUME
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotV1HistoricalHours(market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options?: any): AxiosPromise<SPOTINSTRUMENTHISTODATARESPONSE> {
            return localVarFp.spotV1HistoricalHours(market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,OHLC,OHLC_TRADE,TRADE,VOLUME
         * @param {number} [limit] The number of data points to return
         * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
         * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
         * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotV1HistoricalMinutes(market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options?: any): AxiosPromise<SPOTINSTRUMENTHISTODATARESPONSE> {
            return localVarFp.spotV1HistoricalMinutes(market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {number} minuteTs Unix timestamp in seconds for the minute of the orderbook snapshot you are interested in. You can pass any timestamp within a minute but we will round it down the the full minute timestmap and return the orderbook l2 snapshot at that minute.
         * @param {number} [depth] The number of top bids and asks to return.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotV1HistoricalOrderbookL2SnapshotMinute(market: string, instrument: string, minuteTs: number, depth?: number, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.spotV1HistoricalOrderbookL2SnapshotMinute(market, instrument, minuteTs, depth, mappingPriority, responseFormat, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {number} [afterTs] Unix timestamp in seconds of the earliest trade in the response.
         * @param {number} [lastCcseq] The CCSEQ of the last message seen in the previous request. Useful for pagination within messages that happened in the same second. It will look though the messages in the same second and discard all messages until it reaches the CCSEQ from the last_ccseq parameter. If the CCSEQ is not part of that second, it will discard all messages in the second and only return messages starting from the next second onwards. When starting an integration with our API, on the first request, you should either not send a value for this paramater (defaults to 0 and does not discard any messages) or send 0. After you get a response use the TIMESTAMP and CCSEQ from the last message in the response. Pass the TIMESTAMP in the after_ts parameter and the CCSEQ in the last_ccseq parameter on your next request.
         * @param {number} [limit] The maximum number of trades to return
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {boolean} [return404OnEmptyResponse] If set to false (default) then when there are no items to return, you will get a response status code of 200 and an empty JSON array or a CSV file with just the header. If set to true then when there are no items you will get a 404 status code for both JSON and CSV response_formats.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotV1HistoricalTrades(market: string, instrument: string, afterTs?: number, lastCcseq?: number, limit?: number, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', return404OnEmptyResponse?: boolean, options?: any): AxiosPromise<SPOTINSTRUMENTTRADERESPONSE> {
            return localVarFp.spotV1HistoricalTrades(market, instrument, afterTs, lastCcseq, limit, mappingPriority, responseFormat, return404OnEmptyResponse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
         * @param {number} [hourTs] Unix timestamp in seconds for the hour containing the trades you are interested in. You can pass any timestamp within an hour but we will round it down the the full hour timestmap and return all trades in that hour.
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
         * @param {boolean} [return404OnEmptyResponse] If set to false (default) then when there are no items to return, you will get a response status code of 200 and an empty JSON array or a CSV file with just the header. If set to true then when there are no items you will get a 404 status code for both JSON and CSV response_formats.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotV1HistoricalTradesHour(market: string, instrument: string, hourTs?: number, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', return404OnEmptyResponse?: boolean, options?: any): AxiosPromise<SPOTINSTRUMENTTRADERESPONSE> {
            return localVarFp.spotV1HistoricalTradesHour(market, instrument, hourTs, mappingPriority, responseFormat, return404OnEmptyResponse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {Array<string>} instruments A comma separated array of mapped and/or unmapped instruments to retrieve for a specific market (you can use either the instrument XXBTZUSD or mapped instrument (base - quote) BTC-USD on kraken as an example). We first check each instrument against the mapped list and then against the unmapped list but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting metadata entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: STATUS,INTERNAL,GENERAL,MIGRATION,SOURCE
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotV1LatestInstrumentMetadata(market: string, instruments: Array<string>, groups?: Array<string>, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', options?: any): AxiosPromise<SPOTINSTRUMENTMETADATARESPONSE> {
            return localVarFp.spotV1LatestInstrumentMetadata(market, instruments, groups, mappingPriority, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} market The exchange to obtain data from
         * @param {Array<string>} instruments A comma separated array of mapped and/or unmapped instruments to retrieve for a specific market (you can use either the instrument XXBTZUSD or mapped instrument (base - quote) BTC-USD on kraken as an example). We first check each instrument against the mapped list and then against the unmapped list but you can use the mapping_priority param to check the unmapped list first.
         * @param {Array<string>} [groups] When requesting tick data you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,VALUE,LAST_UPDATE,LAST_PROCESSED,TOP_OF_BOOK,CURRENT_HOUR,CURRENT_DAY,CURRENT_WEEK,CURRENT_MONTH,CURRENT_YEAR,MOVING_24_HOUR,MOVING_7_DAY,MOVING_30_DAY,MOVING_90_DAY,MOVING_180_DAY,MOVING_365_DAY,LIFETIME
         * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotV1LatestTick(market: string, instruments: Array<string>, groups?: Array<string>, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', options?: any): AxiosPromise<SPOTINSTRUMENTMARKETDATARESPONSE> {
            return localVarFp.spotV1LatestTick(market, instruments, groups, mappingPriority, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [market] The exchange to obtain data from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotV1Markets(market?: string, options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.spotV1Markets(market, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [market] The exchange to obtain data from
         * @param {string} [instrument] The mapped instrument to retrieve on a specific market.
         * @param {Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>} [instrumentStatus] The status of the instrument, can be one of the following: ACTIVE, IGNORED, RETIRED, EXPIRED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotV1MarketsInstruments(market?: string, instrument?: string, instrumentStatus?: Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>, options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.spotV1MarketsInstruments(market, instrument, instrumentStatus, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [market] The exchange to obtain data from
         * @param {string} [instrument] The unmapped instrument to retrieve on a specific market.
         * @param {Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>} [instrumentStatus] The status of the instrument, can be one of the following: ACTIVE, IGNORED, RETIRED, EXPIRED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotV1MarketsInstrumentsUnmapped(market?: string, instrument?: string, instrumentStatus?: Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>, options?: any): AxiosPromise<GENERICRESPONSE> {
            return localVarFp.spotV1MarketsInstrumentsUnmapped(market, instrument, instrumentStatus, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SpotApi - object-oriented interface
 * @export
 * @class SpotApi
 * @extends {BaseAPI}
 */
export class SpotApi extends BaseAPI {
    /**
     * 
     * @param {string} market The exchange to obtain data from
     * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
     * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,OHLC,OHLC_TRADE,TRADE,VOLUME
     * @param {number} [limit] The number of data points to return
     * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
     * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
     * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
     * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
     * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotApi
     */
    public spotV1HistoricalDays(market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options?: AxiosRequestConfig) {
        return SpotApiFp(this.configuration).spotV1HistoricalDays(market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} market The exchange to obtain data from
     * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
     * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,OHLC,OHLC_TRADE,TRADE,VOLUME
     * @param {number} [limit] The number of data points to return
     * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
     * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
     * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
     * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
     * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotApi
     */
    public spotV1HistoricalHours(market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options?: AxiosRequestConfig) {
        return SpotApiFp(this.configuration).spotV1HistoricalHours(market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} market The exchange to obtain data from
     * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
     * @param {Array<string>} [groups] When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,OHLC,OHLC_TRADE,TRADE,VOLUME
     * @param {number} [limit] The number of data points to return
     * @param {number} [toTs] Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit&#x3D;2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &amp;limit&#x3D;2000&amp;to_ts&#x3D;{the earliest unix timestamp received}
     * @param {number} [aggregate] The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
     * @param {boolean} [fill] Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
     * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
     * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotApi
     */
    public spotV1HistoricalMinutes(market: string, instrument: string, groups?: Array<string>, limit?: number, toTs?: number, aggregate?: number, fill?: boolean, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options?: AxiosRequestConfig) {
        return SpotApiFp(this.configuration).spotV1HistoricalMinutes(market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} market The exchange to obtain data from
     * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
     * @param {number} minuteTs Unix timestamp in seconds for the minute of the orderbook snapshot you are interested in. You can pass any timestamp within a minute but we will round it down the the full minute timestmap and return the orderbook l2 snapshot at that minute.
     * @param {number} [depth] The number of top bids and asks to return.
     * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
     * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotApi
     */
    public spotV1HistoricalOrderbookL2SnapshotMinute(market: string, instrument: string, minuteTs: number, depth?: number, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', options?: AxiosRequestConfig) {
        return SpotApiFp(this.configuration).spotV1HistoricalOrderbookL2SnapshotMinute(market, instrument, minuteTs, depth, mappingPriority, responseFormat, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} market The exchange to obtain data from
     * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
     * @param {number} [afterTs] Unix timestamp in seconds of the earliest trade in the response.
     * @param {number} [lastCcseq] The CCSEQ of the last message seen in the previous request. Useful for pagination within messages that happened in the same second. It will look though the messages in the same second and discard all messages until it reaches the CCSEQ from the last_ccseq parameter. If the CCSEQ is not part of that second, it will discard all messages in the second and only return messages starting from the next second onwards. When starting an integration with our API, on the first request, you should either not send a value for this paramater (defaults to 0 and does not discard any messages) or send 0. After you get a response use the TIMESTAMP and CCSEQ from the last message in the response. Pass the TIMESTAMP in the after_ts parameter and the CCSEQ in the last_ccseq parameter on your next request.
     * @param {number} [limit] The maximum number of trades to return
     * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
     * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
     * @param {boolean} [return404OnEmptyResponse] If set to false (default) then when there are no items to return, you will get a response status code of 200 and an empty JSON array or a CSV file with just the header. If set to true then when there are no items you will get a 404 status code for both JSON and CSV response_formats.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotApi
     */
    public spotV1HistoricalTrades(market: string, instrument: string, afterTs?: number, lastCcseq?: number, limit?: number, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', return404OnEmptyResponse?: boolean, options?: AxiosRequestConfig) {
        return SpotApiFp(this.configuration).spotV1HistoricalTrades(market, instrument, afterTs, lastCcseq, limit, mappingPriority, responseFormat, return404OnEmptyResponse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} market The exchange to obtain data from
     * @param {string} instrument The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
     * @param {number} [hourTs] Unix timestamp in seconds for the hour containing the trades you are interested in. You can pass any timestamp within an hour but we will round it down the the full hour timestmap and return all trades in that hour.
     * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
     * @param {'JSON' | 'CSV'} [responseFormat] The format of the data response in uppercase. It can be one of the following: JSON,CSV
     * @param {boolean} [return404OnEmptyResponse] If set to false (default) then when there are no items to return, you will get a response status code of 200 and an empty JSON array or a CSV file with just the header. If set to true then when there are no items you will get a 404 status code for both JSON and CSV response_formats.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotApi
     */
    public spotV1HistoricalTradesHour(market: string, instrument: string, hourTs?: number, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', responseFormat?: 'JSON' | 'CSV', return404OnEmptyResponse?: boolean, options?: AxiosRequestConfig) {
        return SpotApiFp(this.configuration).spotV1HistoricalTradesHour(market, instrument, hourTs, mappingPriority, responseFormat, return404OnEmptyResponse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} market The exchange to obtain data from
     * @param {Array<string>} instruments A comma separated array of mapped and/or unmapped instruments to retrieve for a specific market (you can use either the instrument XXBTZUSD or mapped instrument (base - quote) BTC-USD on kraken as an example). We first check each instrument against the mapped list and then against the unmapped list but you can use the mapping_priority param to check the unmapped list first.
     * @param {Array<string>} [groups] When requesting metadata entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: STATUS,INTERNAL,GENERAL,MIGRATION,SOURCE
     * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotApi
     */
    public spotV1LatestInstrumentMetadata(market: string, instruments: Array<string>, groups?: Array<string>, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', options?: AxiosRequestConfig) {
        return SpotApiFp(this.configuration).spotV1LatestInstrumentMetadata(market, instruments, groups, mappingPriority, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} market The exchange to obtain data from
     * @param {Array<string>} instruments A comma separated array of mapped and/or unmapped instruments to retrieve for a specific market (you can use either the instrument XXBTZUSD or mapped instrument (base - quote) BTC-USD on kraken as an example). We first check each instrument against the mapped list and then against the unmapped list but you can use the mapping_priority param to check the unmapped list first.
     * @param {Array<string>} [groups] When requesting tick data you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,VALUE,LAST_UPDATE,LAST_PROCESSED,TOP_OF_BOOK,CURRENT_HOUR,CURRENT_DAY,CURRENT_WEEK,CURRENT_MONTH,CURRENT_YEAR,MOVING_24_HOUR,MOVING_7_DAY,MOVING_30_DAY,MOVING_90_DAY,MOVING_180_DAY,MOVING_365_DAY,LIFETIME
     * @param {'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST'} [mappingPriority] The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotApi
     */
    public spotV1LatestTick(market: string, instruments: Array<string>, groups?: Array<string>, mappingPriority?: 'CHECK_MAPPED_FIRST' | 'CHECK_UNMAPPED_FIRST', options?: AxiosRequestConfig) {
        return SpotApiFp(this.configuration).spotV1LatestTick(market, instruments, groups, mappingPriority, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [market] The exchange to obtain data from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotApi
     */
    public spotV1Markets(market?: string, options?: AxiosRequestConfig) {
        return SpotApiFp(this.configuration).spotV1Markets(market, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [market] The exchange to obtain data from
     * @param {string} [instrument] The mapped instrument to retrieve on a specific market.
     * @param {Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>} [instrumentStatus] The status of the instrument, can be one of the following: ACTIVE, IGNORED, RETIRED, EXPIRED
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotApi
     */
    public spotV1MarketsInstruments(market?: string, instrument?: string, instrumentStatus?: Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>, options?: AxiosRequestConfig) {
        return SpotApiFp(this.configuration).spotV1MarketsInstruments(market, instrument, instrumentStatus, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [market] The exchange to obtain data from
     * @param {string} [instrument] The unmapped instrument to retrieve on a specific market.
     * @param {Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>} [instrumentStatus] The status of the instrument, can be one of the following: ACTIVE, IGNORED, RETIRED, EXPIRED
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotApi
     */
    public spotV1MarketsInstrumentsUnmapped(market?: string, instrument?: string, instrumentStatus?: Array<'ACTIVE' | 'IGNORED' | 'RETIRED' | 'EXPIRED'>, options?: AxiosRequestConfig) {
        return SpotApiFp(this.configuration).spotV1MarketsInstrumentsUnmapped(market, instrument, instrumentStatus, options).then((request) => request(this.axios, this.basePath));
    }
}


