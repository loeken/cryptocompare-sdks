// tslint:disable
/**
 * CryptoCompare Market, Index, Reference Data, News and Overview Metrcis API for the Cryptocurrency Industry
 * CryptoCompare is the world\'s leading digital asset data company, providing services that cater to corporate, government and retail clients. Our main reference index is widely recognized as a reliable benchmark, and we have been authorized by the Financial Conduct Authority (FCA) in the United Kingdom to operate as a benchmark administrator. In addition to catering to corporate, government, and retail clients, we offer a range of services including comprehensive market data for cryptocurrency exchanges in both the centralized and decentralized finance sectors, as well as individual asset data on custodians, supported platforms, and privacy solutions. Our offerings include price, volume, trade, and orderbook updates, as well as historical OHLCV data.
 *
 * The version of the OpenAPI document: 2.1.1
 * Contact: data@cryptocompare.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Observable } from 'rxjs';
import type { AjaxResponse } from 'rxjs/ajax';
import { BaseAPI, throwIfNullOrUndefined, COLLECTION_FORMATS } from '../runtime';
import type { OperationOpts, HttpHeaders, HttpQuery } from '../runtime';
import type {
    GENERICRESPONSE,
} from '../models';

export interface FuturesV1HistoricalDaysRequest {
    market: string;
    instrument: string;
    groups?: Array<string>;
    limit?: number;
    toTs?: number;
    aggregate?: number;
    fill?: boolean;
    mappingPriority?: FuturesV1HistoricalDaysMappingPriorityEnum;
    responseFormat?: FuturesV1HistoricalDaysResponseFormatEnum;
}

export interface FuturesV1HistoricalFundingRateDaysRequest {
    market: string;
    instrument: string;
    groups?: Array<string>;
    limit?: number;
    toTs?: number;
    aggregate?: number;
    fill?: boolean;
    mappingPriority?: FuturesV1HistoricalFundingRateDaysMappingPriorityEnum;
    responseFormat?: FuturesV1HistoricalFundingRateDaysResponseFormatEnum;
}

export interface FuturesV1HistoricalFundingRateHoursRequest {
    market: string;
    instrument: string;
    groups?: Array<string>;
    limit?: number;
    toTs?: number;
    aggregate?: number;
    fill?: boolean;
    mappingPriority?: FuturesV1HistoricalFundingRateHoursMappingPriorityEnum;
    responseFormat?: FuturesV1HistoricalFundingRateHoursResponseFormatEnum;
}

export interface FuturesV1HistoricalFundingRateMessagesRequest {
    market: string;
    instrument: string;
    afterTs?: number;
    lastCcseq?: number;
    limit?: number;
    mappingPriority?: FuturesV1HistoricalFundingRateMessagesMappingPriorityEnum;
    responseFormat?: FuturesV1HistoricalFundingRateMessagesResponseFormatEnum;
    return404OnEmptyResponse?: boolean;
}

export interface FuturesV1HistoricalFundingRateMessagesHourRequest {
    market: string;
    instrument: string;
    hourTs?: number;
    mappingPriority?: FuturesV1HistoricalFundingRateMessagesHourMappingPriorityEnum;
    responseFormat?: FuturesV1HistoricalFundingRateMessagesHourResponseFormatEnum;
    return404OnEmptyResponse?: boolean;
}

export interface FuturesV1HistoricalFundingRateMinutesRequest {
    market: string;
    instrument: string;
    groups?: Array<string>;
    limit?: number;
    toTs?: number;
    aggregate?: number;
    fill?: boolean;
    mappingPriority?: FuturesV1HistoricalFundingRateMinutesMappingPriorityEnum;
    responseFormat?: FuturesV1HistoricalFundingRateMinutesResponseFormatEnum;
}

export interface FuturesV1HistoricalHoursRequest {
    market: string;
    instrument: string;
    groups?: Array<string>;
    limit?: number;
    toTs?: number;
    aggregate?: number;
    fill?: boolean;
    mappingPriority?: FuturesV1HistoricalHoursMappingPriorityEnum;
    responseFormat?: FuturesV1HistoricalHoursResponseFormatEnum;
}

export interface FuturesV1HistoricalMinutesRequest {
    market: string;
    instrument: string;
    groups?: Array<string>;
    limit?: number;
    toTs?: number;
    aggregate?: number;
    fill?: boolean;
    mappingPriority?: FuturesV1HistoricalMinutesMappingPriorityEnum;
    responseFormat?: FuturesV1HistoricalMinutesResponseFormatEnum;
}

export interface FuturesV1HistoricalOpenInterestDaysRequest {
    market: string;
    instrument: string;
    groups?: Array<string>;
    limit?: number;
    toTs?: number;
    aggregate?: number;
    fill?: boolean;
    mappingPriority?: FuturesV1HistoricalOpenInterestDaysMappingPriorityEnum;
    responseFormat?: FuturesV1HistoricalOpenInterestDaysResponseFormatEnum;
}

export interface FuturesV1HistoricalOpenInterestHoursRequest {
    market: string;
    instrument: string;
    groups?: Array<string>;
    limit?: number;
    toTs?: number;
    aggregate?: number;
    fill?: boolean;
    mappingPriority?: FuturesV1HistoricalOpenInterestHoursMappingPriorityEnum;
    responseFormat?: FuturesV1HistoricalOpenInterestHoursResponseFormatEnum;
}

export interface FuturesV1HistoricalOpenInterestMessagesRequest {
    market: string;
    instrument: string;
    afterTs?: number;
    lastCcseq?: number;
    limit?: number;
    mappingPriority?: FuturesV1HistoricalOpenInterestMessagesMappingPriorityEnum;
    responseFormat?: FuturesV1HistoricalOpenInterestMessagesResponseFormatEnum;
    return404OnEmptyResponse?: boolean;
}

export interface FuturesV1HistoricalOpenInterestMessagesHourRequest {
    market: string;
    instrument: string;
    hourTs?: number;
    mappingPriority?: FuturesV1HistoricalOpenInterestMessagesHourMappingPriorityEnum;
    responseFormat?: FuturesV1HistoricalOpenInterestMessagesHourResponseFormatEnum;
    return404OnEmptyResponse?: boolean;
}

export interface FuturesV1HistoricalOpenInterestMinutesRequest {
    market: string;
    instrument: string;
    groups?: Array<string>;
    limit?: number;
    toTs?: number;
    aggregate?: number;
    fill?: boolean;
    mappingPriority?: FuturesV1HistoricalOpenInterestMinutesMappingPriorityEnum;
    responseFormat?: FuturesV1HistoricalOpenInterestMinutesResponseFormatEnum;
}

export interface FuturesV1HistoricalTradesRequest {
    market: string;
    instrument: string;
    afterTs?: number;
    lastCcseq?: number;
    limit?: number;
    mappingPriority?: FuturesV1HistoricalTradesMappingPriorityEnum;
    responseFormat?: FuturesV1HistoricalTradesResponseFormatEnum;
    return404OnEmptyResponse?: boolean;
}

export interface FuturesV1HistoricalTradesHourRequest {
    market: string;
    instrument: string;
    hourTs?: number;
    mappingPriority?: FuturesV1HistoricalTradesHourMappingPriorityEnum;
    responseFormat?: FuturesV1HistoricalTradesHourResponseFormatEnum;
    return404OnEmptyResponse?: boolean;
}

export interface FuturesV1LatestFundingRateTickRequest {
    market: string;
    instruments: Array<string>;
    groups?: Array<string>;
    mappingPriority?: FuturesV1LatestFundingRateTickMappingPriorityEnum;
}

export interface FuturesV1LatestInstrumentMetadataRequest {
    market: string;
    instruments: Array<string>;
    groups?: Array<string>;
    mappingPriority?: FuturesV1LatestInstrumentMetadataMappingPriorityEnum;
}

export interface FuturesV1LatestOpenInterestTickRequest {
    market: string;
    instruments: Array<string>;
    groups?: Array<string>;
    mappingPriority?: FuturesV1LatestOpenInterestTickMappingPriorityEnum;
}

export interface FuturesV1LatestTickRequest {
    market: string;
    instruments: Array<string>;
    groups?: Array<string>;
    mappingPriority?: FuturesV1LatestTickMappingPriorityEnum;
}

export interface FuturesV1MarketsRequest {
    market?: string;
}

export interface FuturesV1MarketsInstrumentsRequest {
    market?: string;
    instrument?: string;
    instrumentStatus?: Array<FuturesV1MarketsInstrumentsInstrumentStatusEnum>;
}

export interface FuturesV1MarketsInstrumentsUnmappedRequest {
    market?: string;
    instrument?: string;
    instrumentStatus?: Array<FuturesV1MarketsInstrumentsUnmappedInstrumentStatusEnum>;
}

export interface IndexV1HistoricalDaysRequest {
    market: string;
    instrument: string;
    groups?: Array<string>;
    limit?: number;
    toTs?: number;
    aggregate?: number;
    fill?: boolean;
    mappingPriority?: IndexV1HistoricalDaysMappingPriorityEnum;
    responseFormat?: IndexV1HistoricalDaysResponseFormatEnum;
}

export interface IndexV1HistoricalHoursRequest {
    market: string;
    instrument: string;
    groups?: Array<string>;
    limit?: number;
    toTs?: number;
    aggregate?: number;
    fill?: boolean;
    mappingPriority?: IndexV1HistoricalHoursMappingPriorityEnum;
    responseFormat?: IndexV1HistoricalHoursResponseFormatEnum;
}

export interface IndexV1HistoricalMessagesRequest {
    market: string;
    instrument: string;
    afterTs?: number;
    lastCcseq?: number;
    limit?: number;
    mappingPriority?: IndexV1HistoricalMessagesMappingPriorityEnum;
    responseFormat?: IndexV1HistoricalMessagesResponseFormatEnum;
    return404OnEmptyResponse?: boolean;
}

export interface IndexV1HistoricalMessagesHourRequest {
    market: string;
    instrument: string;
    hourTs?: number;
    mappingPriority?: IndexV1HistoricalMessagesHourMappingPriorityEnum;
    responseFormat?: IndexV1HistoricalMessagesHourResponseFormatEnum;
    return404OnEmptyResponse?: boolean;
}

export interface IndexV1HistoricalMinutesRequest {
    market: string;
    instrument: string;
    groups?: Array<string>;
    limit?: number;
    toTs?: number;
    aggregate?: number;
    fill?: boolean;
    mappingPriority?: IndexV1HistoricalMinutesMappingPriorityEnum;
    responseFormat?: IndexV1HistoricalMinutesResponseFormatEnum;
}

export interface IndexV1LatestInstrumentMetadataRequest {
    market: string;
    instruments: Array<string>;
    groups?: Array<string>;
    mappingPriority?: IndexV1LatestInstrumentMetadataMappingPriorityEnum;
}

export interface IndexV1LatestTickRequest {
    market: string;
    instruments: Array<string>;
    groups?: Array<string>;
    mappingPriority?: IndexV1LatestTickMappingPriorityEnum;
}

export interface IndexV1MarketsRequest {
    market?: string;
}

export interface IndexV1MarketsInstrumentsRequest {
    market?: string;
    instrument?: string;
    instrumentStatus?: Array<IndexV1MarketsInstrumentsInstrumentStatusEnum>;
}

export interface IndexV1MarketsInstrumentsUnmappedRequest {
    market?: string;
    instrument?: string;
    instrumentStatus?: Array<IndexV1MarketsInstrumentsUnmappedInstrumentStatusEnum>;
}

/**
 * no description
 */
export class FuturesApi extends BaseAPI {

    /**
     */
    futuresV1HistoricalDays({ market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat }: FuturesV1HistoricalDaysRequest): Observable<GENERICRESPONSE>
    futuresV1HistoricalDays({ market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat }: FuturesV1HistoricalDaysRequest, opts?: OperationOpts): Observable<AjaxResponse<GENERICRESPONSE>>
    futuresV1HistoricalDays({ market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat }: FuturesV1HistoricalDaysRequest, opts?: OperationOpts): Observable<GENERICRESPONSE | AjaxResponse<GENERICRESPONSE>> {
        throwIfNullOrUndefined(market, 'market', 'futuresV1HistoricalDays');
        throwIfNullOrUndefined(instrument, 'instrument', 'futuresV1HistoricalDays');

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'market': market,
            'instrument': instrument,
        };

        if (groups != null) { query['groups'] = groups.join(COLLECTION_FORMATS['csv']); }
        if (limit != null) { query['limit'] = limit; }
        if (toTs != null) { query['to_ts'] = toTs; }
        if (aggregate != null) { query['aggregate'] = aggregate; }
        if (fill != null) { query['fill'] = fill; }
        if (mappingPriority != null) { query['mapping_priority'] = mappingPriority; }
        if (responseFormat != null) { query['response_format'] = responseFormat; }

        return this.request<GENERICRESPONSE>({
            url: '/futures/v1/historical/days',
            method: 'GET',
            query,
        }, opts?.responseOpts);
    };

    /**
     */
    futuresV1HistoricalFundingRateDays({ market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat }: FuturesV1HistoricalFundingRateDaysRequest): Observable<GENERICRESPONSE>
    futuresV1HistoricalFundingRateDays({ market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat }: FuturesV1HistoricalFundingRateDaysRequest, opts?: OperationOpts): Observable<AjaxResponse<GENERICRESPONSE>>
    futuresV1HistoricalFundingRateDays({ market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat }: FuturesV1HistoricalFundingRateDaysRequest, opts?: OperationOpts): Observable<GENERICRESPONSE | AjaxResponse<GENERICRESPONSE>> {
        throwIfNullOrUndefined(market, 'market', 'futuresV1HistoricalFundingRateDays');
        throwIfNullOrUndefined(instrument, 'instrument', 'futuresV1HistoricalFundingRateDays');

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'market': market,
            'instrument': instrument,
        };

        if (groups != null) { query['groups'] = groups.join(COLLECTION_FORMATS['csv']); }
        if (limit != null) { query['limit'] = limit; }
        if (toTs != null) { query['to_ts'] = toTs; }
        if (aggregate != null) { query['aggregate'] = aggregate; }
        if (fill != null) { query['fill'] = fill; }
        if (mappingPriority != null) { query['mapping_priority'] = mappingPriority; }
        if (responseFormat != null) { query['response_format'] = responseFormat; }

        return this.request<GENERICRESPONSE>({
            url: '/futures/v1/historical/funding-rate/days',
            method: 'GET',
            query,
        }, opts?.responseOpts);
    };

    /**
     */
    futuresV1HistoricalFundingRateHours({ market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat }: FuturesV1HistoricalFundingRateHoursRequest): Observable<GENERICRESPONSE>
    futuresV1HistoricalFundingRateHours({ market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat }: FuturesV1HistoricalFundingRateHoursRequest, opts?: OperationOpts): Observable<AjaxResponse<GENERICRESPONSE>>
    futuresV1HistoricalFundingRateHours({ market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat }: FuturesV1HistoricalFundingRateHoursRequest, opts?: OperationOpts): Observable<GENERICRESPONSE | AjaxResponse<GENERICRESPONSE>> {
        throwIfNullOrUndefined(market, 'market', 'futuresV1HistoricalFundingRateHours');
        throwIfNullOrUndefined(instrument, 'instrument', 'futuresV1HistoricalFundingRateHours');

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'market': market,
            'instrument': instrument,
        };

        if (groups != null) { query['groups'] = groups.join(COLLECTION_FORMATS['csv']); }
        if (limit != null) { query['limit'] = limit; }
        if (toTs != null) { query['to_ts'] = toTs; }
        if (aggregate != null) { query['aggregate'] = aggregate; }
        if (fill != null) { query['fill'] = fill; }
        if (mappingPriority != null) { query['mapping_priority'] = mappingPriority; }
        if (responseFormat != null) { query['response_format'] = responseFormat; }

        return this.request<GENERICRESPONSE>({
            url: '/futures/v1/historical/funding-rate/hours',
            method: 'GET',
            query,
        }, opts?.responseOpts);
    };

    /**
     */
    futuresV1HistoricalFundingRateMessages({ market, instrument, afterTs, lastCcseq, limit, mappingPriority, responseFormat, return404OnEmptyResponse }: FuturesV1HistoricalFundingRateMessagesRequest): Observable<GENERICRESPONSE>
    futuresV1HistoricalFundingRateMessages({ market, instrument, afterTs, lastCcseq, limit, mappingPriority, responseFormat, return404OnEmptyResponse }: FuturesV1HistoricalFundingRateMessagesRequest, opts?: OperationOpts): Observable<AjaxResponse<GENERICRESPONSE>>
    futuresV1HistoricalFundingRateMessages({ market, instrument, afterTs, lastCcseq, limit, mappingPriority, responseFormat, return404OnEmptyResponse }: FuturesV1HistoricalFundingRateMessagesRequest, opts?: OperationOpts): Observable<GENERICRESPONSE | AjaxResponse<GENERICRESPONSE>> {
        throwIfNullOrUndefined(market, 'market', 'futuresV1HistoricalFundingRateMessages');
        throwIfNullOrUndefined(instrument, 'instrument', 'futuresV1HistoricalFundingRateMessages');

        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'authorization': this.configuration.apiKey('authorization') }), // api_key_header authentication
        };

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'market': market,
            'instrument': instrument,
        };

        if (afterTs != null) { query['after_ts'] = afterTs; }
        if (lastCcseq != null) { query['last_ccseq'] = lastCcseq; }
        if (limit != null) { query['limit'] = limit; }
        if (mappingPriority != null) { query['mapping_priority'] = mappingPriority; }
        if (responseFormat != null) { query['response_format'] = responseFormat; }
        if (return404OnEmptyResponse != null) { query['return_404_on_empty_response'] = return404OnEmptyResponse; }
        if (this.configuration.apiKey != null) { query['api_key'] = this.configuration.apiKey('api_key'); } // api_key_query authentication

        return this.request<GENERICRESPONSE>({
            url: '/futures/v1/historical/funding-rate-messages',
            method: 'GET',
            headers,
            query,
        }, opts?.responseOpts);
    };

    /**
     */
    futuresV1HistoricalFundingRateMessagesHour({ market, instrument, hourTs, mappingPriority, responseFormat, return404OnEmptyResponse }: FuturesV1HistoricalFundingRateMessagesHourRequest): Observable<GENERICRESPONSE>
    futuresV1HistoricalFundingRateMessagesHour({ market, instrument, hourTs, mappingPriority, responseFormat, return404OnEmptyResponse }: FuturesV1HistoricalFundingRateMessagesHourRequest, opts?: OperationOpts): Observable<AjaxResponse<GENERICRESPONSE>>
    futuresV1HistoricalFundingRateMessagesHour({ market, instrument, hourTs, mappingPriority, responseFormat, return404OnEmptyResponse }: FuturesV1HistoricalFundingRateMessagesHourRequest, opts?: OperationOpts): Observable<GENERICRESPONSE | AjaxResponse<GENERICRESPONSE>> {
        throwIfNullOrUndefined(market, 'market', 'futuresV1HistoricalFundingRateMessagesHour');
        throwIfNullOrUndefined(instrument, 'instrument', 'futuresV1HistoricalFundingRateMessagesHour');

        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'authorization': this.configuration.apiKey('authorization') }), // api_key_header authentication
        };

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'market': market,
            'instrument': instrument,
        };

        if (hourTs != null) { query['hour_ts'] = hourTs; }
        if (mappingPriority != null) { query['mapping_priority'] = mappingPriority; }
        if (responseFormat != null) { query['response_format'] = responseFormat; }
        if (return404OnEmptyResponse != null) { query['return_404_on_empty_response'] = return404OnEmptyResponse; }
        if (this.configuration.apiKey != null) { query['api_key'] = this.configuration.apiKey('api_key'); } // api_key_query authentication

        return this.request<GENERICRESPONSE>({
            url: '/futures/v1/historical/funding-rate-messages/hour',
            method: 'GET',
            headers,
            query,
        }, opts?.responseOpts);
    };

    /**
     */
    futuresV1HistoricalFundingRateMinutes({ market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat }: FuturesV1HistoricalFundingRateMinutesRequest): Observable<GENERICRESPONSE>
    futuresV1HistoricalFundingRateMinutes({ market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat }: FuturesV1HistoricalFundingRateMinutesRequest, opts?: OperationOpts): Observable<AjaxResponse<GENERICRESPONSE>>
    futuresV1HistoricalFundingRateMinutes({ market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat }: FuturesV1HistoricalFundingRateMinutesRequest, opts?: OperationOpts): Observable<GENERICRESPONSE | AjaxResponse<GENERICRESPONSE>> {
        throwIfNullOrUndefined(market, 'market', 'futuresV1HistoricalFundingRateMinutes');
        throwIfNullOrUndefined(instrument, 'instrument', 'futuresV1HistoricalFundingRateMinutes');

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'market': market,
            'instrument': instrument,
        };

        if (groups != null) { query['groups'] = groups.join(COLLECTION_FORMATS['csv']); }
        if (limit != null) { query['limit'] = limit; }
        if (toTs != null) { query['to_ts'] = toTs; }
        if (aggregate != null) { query['aggregate'] = aggregate; }
        if (fill != null) { query['fill'] = fill; }
        if (mappingPriority != null) { query['mapping_priority'] = mappingPriority; }
        if (responseFormat != null) { query['response_format'] = responseFormat; }

        return this.request<GENERICRESPONSE>({
            url: '/futures/v1/historical/funding-rate/minutes',
            method: 'GET',
            query,
        }, opts?.responseOpts);
    };

    /**
     */
    futuresV1HistoricalHours({ market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat }: FuturesV1HistoricalHoursRequest): Observable<GENERICRESPONSE>
    futuresV1HistoricalHours({ market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat }: FuturesV1HistoricalHoursRequest, opts?: OperationOpts): Observable<AjaxResponse<GENERICRESPONSE>>
    futuresV1HistoricalHours({ market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat }: FuturesV1HistoricalHoursRequest, opts?: OperationOpts): Observable<GENERICRESPONSE | AjaxResponse<GENERICRESPONSE>> {
        throwIfNullOrUndefined(market, 'market', 'futuresV1HistoricalHours');
        throwIfNullOrUndefined(instrument, 'instrument', 'futuresV1HistoricalHours');

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'market': market,
            'instrument': instrument,
        };

        if (groups != null) { query['groups'] = groups.join(COLLECTION_FORMATS['csv']); }
        if (limit != null) { query['limit'] = limit; }
        if (toTs != null) { query['to_ts'] = toTs; }
        if (aggregate != null) { query['aggregate'] = aggregate; }
        if (fill != null) { query['fill'] = fill; }
        if (mappingPriority != null) { query['mapping_priority'] = mappingPriority; }
        if (responseFormat != null) { query['response_format'] = responseFormat; }

        return this.request<GENERICRESPONSE>({
            url: '/futures/v1/historical/hours',
            method: 'GET',
            query,
        }, opts?.responseOpts);
    };

    /**
     */
    futuresV1HistoricalMinutes({ market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat }: FuturesV1HistoricalMinutesRequest): Observable<GENERICRESPONSE>
    futuresV1HistoricalMinutes({ market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat }: FuturesV1HistoricalMinutesRequest, opts?: OperationOpts): Observable<AjaxResponse<GENERICRESPONSE>>
    futuresV1HistoricalMinutes({ market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat }: FuturesV1HistoricalMinutesRequest, opts?: OperationOpts): Observable<GENERICRESPONSE | AjaxResponse<GENERICRESPONSE>> {
        throwIfNullOrUndefined(market, 'market', 'futuresV1HistoricalMinutes');
        throwIfNullOrUndefined(instrument, 'instrument', 'futuresV1HistoricalMinutes');

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'market': market,
            'instrument': instrument,
        };

        if (groups != null) { query['groups'] = groups.join(COLLECTION_FORMATS['csv']); }
        if (limit != null) { query['limit'] = limit; }
        if (toTs != null) { query['to_ts'] = toTs; }
        if (aggregate != null) { query['aggregate'] = aggregate; }
        if (fill != null) { query['fill'] = fill; }
        if (mappingPriority != null) { query['mapping_priority'] = mappingPriority; }
        if (responseFormat != null) { query['response_format'] = responseFormat; }

        return this.request<GENERICRESPONSE>({
            url: '/futures/v1/historical/minutes',
            method: 'GET',
            query,
        }, opts?.responseOpts);
    };

    /**
     */
    futuresV1HistoricalOpenInterestDays({ market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat }: FuturesV1HistoricalOpenInterestDaysRequest): Observable<GENERICRESPONSE>
    futuresV1HistoricalOpenInterestDays({ market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat }: FuturesV1HistoricalOpenInterestDaysRequest, opts?: OperationOpts): Observable<AjaxResponse<GENERICRESPONSE>>
    futuresV1HistoricalOpenInterestDays({ market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat }: FuturesV1HistoricalOpenInterestDaysRequest, opts?: OperationOpts): Observable<GENERICRESPONSE | AjaxResponse<GENERICRESPONSE>> {
        throwIfNullOrUndefined(market, 'market', 'futuresV1HistoricalOpenInterestDays');
        throwIfNullOrUndefined(instrument, 'instrument', 'futuresV1HistoricalOpenInterestDays');

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'market': market,
            'instrument': instrument,
        };

        if (groups != null) { query['groups'] = groups.join(COLLECTION_FORMATS['csv']); }
        if (limit != null) { query['limit'] = limit; }
        if (toTs != null) { query['to_ts'] = toTs; }
        if (aggregate != null) { query['aggregate'] = aggregate; }
        if (fill != null) { query['fill'] = fill; }
        if (mappingPriority != null) { query['mapping_priority'] = mappingPriority; }
        if (responseFormat != null) { query['response_format'] = responseFormat; }

        return this.request<GENERICRESPONSE>({
            url: '/futures/v1/historical/open-interest/days',
            method: 'GET',
            query,
        }, opts?.responseOpts);
    };

    /**
     */
    futuresV1HistoricalOpenInterestHours({ market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat }: FuturesV1HistoricalOpenInterestHoursRequest): Observable<GENERICRESPONSE>
    futuresV1HistoricalOpenInterestHours({ market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat }: FuturesV1HistoricalOpenInterestHoursRequest, opts?: OperationOpts): Observable<AjaxResponse<GENERICRESPONSE>>
    futuresV1HistoricalOpenInterestHours({ market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat }: FuturesV1HistoricalOpenInterestHoursRequest, opts?: OperationOpts): Observable<GENERICRESPONSE | AjaxResponse<GENERICRESPONSE>> {
        throwIfNullOrUndefined(market, 'market', 'futuresV1HistoricalOpenInterestHours');
        throwIfNullOrUndefined(instrument, 'instrument', 'futuresV1HistoricalOpenInterestHours');

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'market': market,
            'instrument': instrument,
        };

        if (groups != null) { query['groups'] = groups.join(COLLECTION_FORMATS['csv']); }
        if (limit != null) { query['limit'] = limit; }
        if (toTs != null) { query['to_ts'] = toTs; }
        if (aggregate != null) { query['aggregate'] = aggregate; }
        if (fill != null) { query['fill'] = fill; }
        if (mappingPriority != null) { query['mapping_priority'] = mappingPriority; }
        if (responseFormat != null) { query['response_format'] = responseFormat; }

        return this.request<GENERICRESPONSE>({
            url: '/futures/v1/historical/open-interest/hours',
            method: 'GET',
            query,
        }, opts?.responseOpts);
    };

    /**
     */
    futuresV1HistoricalOpenInterestMessages({ market, instrument, afterTs, lastCcseq, limit, mappingPriority, responseFormat, return404OnEmptyResponse }: FuturesV1HistoricalOpenInterestMessagesRequest): Observable<GENERICRESPONSE>
    futuresV1HistoricalOpenInterestMessages({ market, instrument, afterTs, lastCcseq, limit, mappingPriority, responseFormat, return404OnEmptyResponse }: FuturesV1HistoricalOpenInterestMessagesRequest, opts?: OperationOpts): Observable<AjaxResponse<GENERICRESPONSE>>
    futuresV1HistoricalOpenInterestMessages({ market, instrument, afterTs, lastCcseq, limit, mappingPriority, responseFormat, return404OnEmptyResponse }: FuturesV1HistoricalOpenInterestMessagesRequest, opts?: OperationOpts): Observable<GENERICRESPONSE | AjaxResponse<GENERICRESPONSE>> {
        throwIfNullOrUndefined(market, 'market', 'futuresV1HistoricalOpenInterestMessages');
        throwIfNullOrUndefined(instrument, 'instrument', 'futuresV1HistoricalOpenInterestMessages');

        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'authorization': this.configuration.apiKey('authorization') }), // api_key_header authentication
        };

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'market': market,
            'instrument': instrument,
        };

        if (afterTs != null) { query['after_ts'] = afterTs; }
        if (lastCcseq != null) { query['last_ccseq'] = lastCcseq; }
        if (limit != null) { query['limit'] = limit; }
        if (mappingPriority != null) { query['mapping_priority'] = mappingPriority; }
        if (responseFormat != null) { query['response_format'] = responseFormat; }
        if (return404OnEmptyResponse != null) { query['return_404_on_empty_response'] = return404OnEmptyResponse; }
        if (this.configuration.apiKey != null) { query['api_key'] = this.configuration.apiKey('api_key'); } // api_key_query authentication

        return this.request<GENERICRESPONSE>({
            url: '/futures/v1/historical/open-interest-messages',
            method: 'GET',
            headers,
            query,
        }, opts?.responseOpts);
    };

    /**
     */
    futuresV1HistoricalOpenInterestMessagesHour({ market, instrument, hourTs, mappingPriority, responseFormat, return404OnEmptyResponse }: FuturesV1HistoricalOpenInterestMessagesHourRequest): Observable<GENERICRESPONSE>
    futuresV1HistoricalOpenInterestMessagesHour({ market, instrument, hourTs, mappingPriority, responseFormat, return404OnEmptyResponse }: FuturesV1HistoricalOpenInterestMessagesHourRequest, opts?: OperationOpts): Observable<AjaxResponse<GENERICRESPONSE>>
    futuresV1HistoricalOpenInterestMessagesHour({ market, instrument, hourTs, mappingPriority, responseFormat, return404OnEmptyResponse }: FuturesV1HistoricalOpenInterestMessagesHourRequest, opts?: OperationOpts): Observable<GENERICRESPONSE | AjaxResponse<GENERICRESPONSE>> {
        throwIfNullOrUndefined(market, 'market', 'futuresV1HistoricalOpenInterestMessagesHour');
        throwIfNullOrUndefined(instrument, 'instrument', 'futuresV1HistoricalOpenInterestMessagesHour');

        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'authorization': this.configuration.apiKey('authorization') }), // api_key_header authentication
        };

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'market': market,
            'instrument': instrument,
        };

        if (hourTs != null) { query['hour_ts'] = hourTs; }
        if (mappingPriority != null) { query['mapping_priority'] = mappingPriority; }
        if (responseFormat != null) { query['response_format'] = responseFormat; }
        if (return404OnEmptyResponse != null) { query['return_404_on_empty_response'] = return404OnEmptyResponse; }
        if (this.configuration.apiKey != null) { query['api_key'] = this.configuration.apiKey('api_key'); } // api_key_query authentication

        return this.request<GENERICRESPONSE>({
            url: '/futures/v1/historical/open-interest-messages/hour',
            method: 'GET',
            headers,
            query,
        }, opts?.responseOpts);
    };

    /**
     */
    futuresV1HistoricalOpenInterestMinutes({ market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat }: FuturesV1HistoricalOpenInterestMinutesRequest): Observable<GENERICRESPONSE>
    futuresV1HistoricalOpenInterestMinutes({ market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat }: FuturesV1HistoricalOpenInterestMinutesRequest, opts?: OperationOpts): Observable<AjaxResponse<GENERICRESPONSE>>
    futuresV1HistoricalOpenInterestMinutes({ market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat }: FuturesV1HistoricalOpenInterestMinutesRequest, opts?: OperationOpts): Observable<GENERICRESPONSE | AjaxResponse<GENERICRESPONSE>> {
        throwIfNullOrUndefined(market, 'market', 'futuresV1HistoricalOpenInterestMinutes');
        throwIfNullOrUndefined(instrument, 'instrument', 'futuresV1HistoricalOpenInterestMinutes');

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'market': market,
            'instrument': instrument,
        };

        if (groups != null) { query['groups'] = groups.join(COLLECTION_FORMATS['csv']); }
        if (limit != null) { query['limit'] = limit; }
        if (toTs != null) { query['to_ts'] = toTs; }
        if (aggregate != null) { query['aggregate'] = aggregate; }
        if (fill != null) { query['fill'] = fill; }
        if (mappingPriority != null) { query['mapping_priority'] = mappingPriority; }
        if (responseFormat != null) { query['response_format'] = responseFormat; }

        return this.request<GENERICRESPONSE>({
            url: '/futures/v1/historical/open-interest/minutes',
            method: 'GET',
            query,
        }, opts?.responseOpts);
    };

    /**
     */
    futuresV1HistoricalTrades({ market, instrument, afterTs, lastCcseq, limit, mappingPriority, responseFormat, return404OnEmptyResponse }: FuturesV1HistoricalTradesRequest): Observable<GENERICRESPONSE>
    futuresV1HistoricalTrades({ market, instrument, afterTs, lastCcseq, limit, mappingPriority, responseFormat, return404OnEmptyResponse }: FuturesV1HistoricalTradesRequest, opts?: OperationOpts): Observable<AjaxResponse<GENERICRESPONSE>>
    futuresV1HistoricalTrades({ market, instrument, afterTs, lastCcseq, limit, mappingPriority, responseFormat, return404OnEmptyResponse }: FuturesV1HistoricalTradesRequest, opts?: OperationOpts): Observable<GENERICRESPONSE | AjaxResponse<GENERICRESPONSE>> {
        throwIfNullOrUndefined(market, 'market', 'futuresV1HistoricalTrades');
        throwIfNullOrUndefined(instrument, 'instrument', 'futuresV1HistoricalTrades');

        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'authorization': this.configuration.apiKey('authorization') }), // api_key_header authentication
        };

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'market': market,
            'instrument': instrument,
        };

        if (afterTs != null) { query['after_ts'] = afterTs; }
        if (lastCcseq != null) { query['last_ccseq'] = lastCcseq; }
        if (limit != null) { query['limit'] = limit; }
        if (mappingPriority != null) { query['mapping_priority'] = mappingPriority; }
        if (responseFormat != null) { query['response_format'] = responseFormat; }
        if (return404OnEmptyResponse != null) { query['return_404_on_empty_response'] = return404OnEmptyResponse; }
        if (this.configuration.apiKey != null) { query['api_key'] = this.configuration.apiKey('api_key'); } // api_key_query authentication

        return this.request<GENERICRESPONSE>({
            url: '/futures/v1/historical/trades',
            method: 'GET',
            headers,
            query,
        }, opts?.responseOpts);
    };

    /**
     */
    futuresV1HistoricalTradesHour({ market, instrument, hourTs, mappingPriority, responseFormat, return404OnEmptyResponse }: FuturesV1HistoricalTradesHourRequest): Observable<GENERICRESPONSE>
    futuresV1HistoricalTradesHour({ market, instrument, hourTs, mappingPriority, responseFormat, return404OnEmptyResponse }: FuturesV1HistoricalTradesHourRequest, opts?: OperationOpts): Observable<AjaxResponse<GENERICRESPONSE>>
    futuresV1HistoricalTradesHour({ market, instrument, hourTs, mappingPriority, responseFormat, return404OnEmptyResponse }: FuturesV1HistoricalTradesHourRequest, opts?: OperationOpts): Observable<GENERICRESPONSE | AjaxResponse<GENERICRESPONSE>> {
        throwIfNullOrUndefined(market, 'market', 'futuresV1HistoricalTradesHour');
        throwIfNullOrUndefined(instrument, 'instrument', 'futuresV1HistoricalTradesHour');

        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'authorization': this.configuration.apiKey('authorization') }), // api_key_header authentication
        };

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'market': market,
            'instrument': instrument,
        };

        if (hourTs != null) { query['hour_ts'] = hourTs; }
        if (mappingPriority != null) { query['mapping_priority'] = mappingPriority; }
        if (responseFormat != null) { query['response_format'] = responseFormat; }
        if (return404OnEmptyResponse != null) { query['return_404_on_empty_response'] = return404OnEmptyResponse; }
        if (this.configuration.apiKey != null) { query['api_key'] = this.configuration.apiKey('api_key'); } // api_key_query authentication

        return this.request<GENERICRESPONSE>({
            url: '/futures/v1/historical/trades/hour',
            method: 'GET',
            headers,
            query,
        }, opts?.responseOpts);
    };

    /**
     */
    futuresV1LatestFundingRateTick({ market, instruments, groups, mappingPriority }: FuturesV1LatestFundingRateTickRequest): Observable<GENERICRESPONSE>
    futuresV1LatestFundingRateTick({ market, instruments, groups, mappingPriority }: FuturesV1LatestFundingRateTickRequest, opts?: OperationOpts): Observable<AjaxResponse<GENERICRESPONSE>>
    futuresV1LatestFundingRateTick({ market, instruments, groups, mappingPriority }: FuturesV1LatestFundingRateTickRequest, opts?: OperationOpts): Observable<GENERICRESPONSE | AjaxResponse<GENERICRESPONSE>> {
        throwIfNullOrUndefined(market, 'market', 'futuresV1LatestFundingRateTick');
        throwIfNullOrUndefined(instruments, 'instruments', 'futuresV1LatestFundingRateTick');

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'market': market,
            'instruments': instruments.join(COLLECTION_FORMATS['csv']),
        };

        if (groups != null) { query['groups'] = groups.join(COLLECTION_FORMATS['csv']); }
        if (mappingPriority != null) { query['mapping_priority'] = mappingPriority; }

        return this.request<GENERICRESPONSE>({
            url: '/futures/v1/latest/funding-rate/tick',
            method: 'GET',
            query,
        }, opts?.responseOpts);
    };

    /**
     */
    futuresV1LatestInstrumentMetadata({ market, instruments, groups, mappingPriority }: FuturesV1LatestInstrumentMetadataRequest): Observable<GENERICRESPONSE>
    futuresV1LatestInstrumentMetadata({ market, instruments, groups, mappingPriority }: FuturesV1LatestInstrumentMetadataRequest, opts?: OperationOpts): Observable<AjaxResponse<GENERICRESPONSE>>
    futuresV1LatestInstrumentMetadata({ market, instruments, groups, mappingPriority }: FuturesV1LatestInstrumentMetadataRequest, opts?: OperationOpts): Observable<GENERICRESPONSE | AjaxResponse<GENERICRESPONSE>> {
        throwIfNullOrUndefined(market, 'market', 'futuresV1LatestInstrumentMetadata');
        throwIfNullOrUndefined(instruments, 'instruments', 'futuresV1LatestInstrumentMetadata');

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'market': market,
            'instruments': instruments.join(COLLECTION_FORMATS['csv']),
        };

        if (groups != null) { query['groups'] = groups.join(COLLECTION_FORMATS['csv']); }
        if (mappingPriority != null) { query['mapping_priority'] = mappingPriority; }

        return this.request<GENERICRESPONSE>({
            url: '/futures/v1/latest/instrument/metadata',
            method: 'GET',
            query,
        }, opts?.responseOpts);
    };

    /**
     */
    futuresV1LatestOpenInterestTick({ market, instruments, groups, mappingPriority }: FuturesV1LatestOpenInterestTickRequest): Observable<GENERICRESPONSE>
    futuresV1LatestOpenInterestTick({ market, instruments, groups, mappingPriority }: FuturesV1LatestOpenInterestTickRequest, opts?: OperationOpts): Observable<AjaxResponse<GENERICRESPONSE>>
    futuresV1LatestOpenInterestTick({ market, instruments, groups, mappingPriority }: FuturesV1LatestOpenInterestTickRequest, opts?: OperationOpts): Observable<GENERICRESPONSE | AjaxResponse<GENERICRESPONSE>> {
        throwIfNullOrUndefined(market, 'market', 'futuresV1LatestOpenInterestTick');
        throwIfNullOrUndefined(instruments, 'instruments', 'futuresV1LatestOpenInterestTick');

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'market': market,
            'instruments': instruments.join(COLLECTION_FORMATS['csv']),
        };

        if (groups != null) { query['groups'] = groups.join(COLLECTION_FORMATS['csv']); }
        if (mappingPriority != null) { query['mapping_priority'] = mappingPriority; }

        return this.request<GENERICRESPONSE>({
            url: '/futures/v1/latest/open-interest/tick',
            method: 'GET',
            query,
        }, opts?.responseOpts);
    };

    /**
     */
    futuresV1LatestTick({ market, instruments, groups, mappingPriority }: FuturesV1LatestTickRequest): Observable<GENERICRESPONSE>
    futuresV1LatestTick({ market, instruments, groups, mappingPriority }: FuturesV1LatestTickRequest, opts?: OperationOpts): Observable<AjaxResponse<GENERICRESPONSE>>
    futuresV1LatestTick({ market, instruments, groups, mappingPriority }: FuturesV1LatestTickRequest, opts?: OperationOpts): Observable<GENERICRESPONSE | AjaxResponse<GENERICRESPONSE>> {
        throwIfNullOrUndefined(market, 'market', 'futuresV1LatestTick');
        throwIfNullOrUndefined(instruments, 'instruments', 'futuresV1LatestTick');

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'market': market,
            'instruments': instruments.join(COLLECTION_FORMATS['csv']),
        };

        if (groups != null) { query['groups'] = groups.join(COLLECTION_FORMATS['csv']); }
        if (mappingPriority != null) { query['mapping_priority'] = mappingPriority; }

        return this.request<GENERICRESPONSE>({
            url: '/futures/v1/latest/tick',
            method: 'GET',
            query,
        }, opts?.responseOpts);
    };

    /**
     */
    futuresV1Markets({ market }: FuturesV1MarketsRequest): Observable<GENERICRESPONSE>
    futuresV1Markets({ market }: FuturesV1MarketsRequest, opts?: OperationOpts): Observable<AjaxResponse<GENERICRESPONSE>>
    futuresV1Markets({ market }: FuturesV1MarketsRequest, opts?: OperationOpts): Observable<GENERICRESPONSE | AjaxResponse<GENERICRESPONSE>> {

        const query: HttpQuery = {};

        if (market != null) { query['market'] = market; }

        return this.request<GENERICRESPONSE>({
            url: '/futures/v1/markets',
            method: 'GET',
            query,
        }, opts?.responseOpts);
    };

    /**
     */
    futuresV1MarketsInstruments({ market, instrument, instrumentStatus }: FuturesV1MarketsInstrumentsRequest): Observable<GENERICRESPONSE>
    futuresV1MarketsInstruments({ market, instrument, instrumentStatus }: FuturesV1MarketsInstrumentsRequest, opts?: OperationOpts): Observable<AjaxResponse<GENERICRESPONSE>>
    futuresV1MarketsInstruments({ market, instrument, instrumentStatus }: FuturesV1MarketsInstrumentsRequest, opts?: OperationOpts): Observable<GENERICRESPONSE | AjaxResponse<GENERICRESPONSE>> {

        const query: HttpQuery = {};

        if (market != null) { query['market'] = market; }
        if (instrument != null) { query['instrument'] = instrument; }
        if (instrumentStatus != null) { query['instrument_status'] = instrumentStatus.join(COLLECTION_FORMATS['csv']); }

        return this.request<GENERICRESPONSE>({
            url: '/futures/v1/markets/instruments',
            method: 'GET',
            query,
        }, opts?.responseOpts);
    };

    /**
     */
    futuresV1MarketsInstrumentsUnmapped({ market, instrument, instrumentStatus }: FuturesV1MarketsInstrumentsUnmappedRequest): Observable<GENERICRESPONSE>
    futuresV1MarketsInstrumentsUnmapped({ market, instrument, instrumentStatus }: FuturesV1MarketsInstrumentsUnmappedRequest, opts?: OperationOpts): Observable<AjaxResponse<GENERICRESPONSE>>
    futuresV1MarketsInstrumentsUnmapped({ market, instrument, instrumentStatus }: FuturesV1MarketsInstrumentsUnmappedRequest, opts?: OperationOpts): Observable<GENERICRESPONSE | AjaxResponse<GENERICRESPONSE>> {

        const query: HttpQuery = {};

        if (market != null) { query['market'] = market; }
        if (instrument != null) { query['instrument'] = instrument; }
        if (instrumentStatus != null) { query['instrument_status'] = instrumentStatus.join(COLLECTION_FORMATS['csv']); }

        return this.request<GENERICRESPONSE>({
            url: '/futures/v1/markets/instruments/unmapped',
            method: 'GET',
            query,
        }, opts?.responseOpts);
    };

    /**
     */
    indexV1HistoricalDays({ market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat }: IndexV1HistoricalDaysRequest): Observable<GENERICRESPONSE>
    indexV1HistoricalDays({ market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat }: IndexV1HistoricalDaysRequest, opts?: OperationOpts): Observable<AjaxResponse<GENERICRESPONSE>>
    indexV1HistoricalDays({ market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat }: IndexV1HistoricalDaysRequest, opts?: OperationOpts): Observable<GENERICRESPONSE | AjaxResponse<GENERICRESPONSE>> {
        throwIfNullOrUndefined(market, 'market', 'indexV1HistoricalDays');
        throwIfNullOrUndefined(instrument, 'instrument', 'indexV1HistoricalDays');

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'market': market,
            'instrument': instrument,
        };

        if (groups != null) { query['groups'] = groups.join(COLLECTION_FORMATS['csv']); }
        if (limit != null) { query['limit'] = limit; }
        if (toTs != null) { query['to_ts'] = toTs; }
        if (aggregate != null) { query['aggregate'] = aggregate; }
        if (fill != null) { query['fill'] = fill; }
        if (mappingPriority != null) { query['mapping_priority'] = mappingPriority; }
        if (responseFormat != null) { query['response_format'] = responseFormat; }

        return this.request<GENERICRESPONSE>({
            url: '/index/v1/historical/days',
            method: 'GET',
            query,
        }, opts?.responseOpts);
    };

    /**
     */
    indexV1HistoricalHours({ market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat }: IndexV1HistoricalHoursRequest): Observable<GENERICRESPONSE>
    indexV1HistoricalHours({ market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat }: IndexV1HistoricalHoursRequest, opts?: OperationOpts): Observable<AjaxResponse<GENERICRESPONSE>>
    indexV1HistoricalHours({ market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat }: IndexV1HistoricalHoursRequest, opts?: OperationOpts): Observable<GENERICRESPONSE | AjaxResponse<GENERICRESPONSE>> {
        throwIfNullOrUndefined(market, 'market', 'indexV1HistoricalHours');
        throwIfNullOrUndefined(instrument, 'instrument', 'indexV1HistoricalHours');

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'market': market,
            'instrument': instrument,
        };

        if (groups != null) { query['groups'] = groups.join(COLLECTION_FORMATS['csv']); }
        if (limit != null) { query['limit'] = limit; }
        if (toTs != null) { query['to_ts'] = toTs; }
        if (aggregate != null) { query['aggregate'] = aggregate; }
        if (fill != null) { query['fill'] = fill; }
        if (mappingPriority != null) { query['mapping_priority'] = mappingPriority; }
        if (responseFormat != null) { query['response_format'] = responseFormat; }

        return this.request<GENERICRESPONSE>({
            url: '/index/v1/historical/hours',
            method: 'GET',
            query,
        }, opts?.responseOpts);
    };

    /**
     */
    indexV1HistoricalMessages({ market, instrument, afterTs, lastCcseq, limit, mappingPriority, responseFormat, return404OnEmptyResponse }: IndexV1HistoricalMessagesRequest): Observable<GENERICRESPONSE>
    indexV1HistoricalMessages({ market, instrument, afterTs, lastCcseq, limit, mappingPriority, responseFormat, return404OnEmptyResponse }: IndexV1HistoricalMessagesRequest, opts?: OperationOpts): Observable<AjaxResponse<GENERICRESPONSE>>
    indexV1HistoricalMessages({ market, instrument, afterTs, lastCcseq, limit, mappingPriority, responseFormat, return404OnEmptyResponse }: IndexV1HistoricalMessagesRequest, opts?: OperationOpts): Observable<GENERICRESPONSE | AjaxResponse<GENERICRESPONSE>> {
        throwIfNullOrUndefined(market, 'market', 'indexV1HistoricalMessages');
        throwIfNullOrUndefined(instrument, 'instrument', 'indexV1HistoricalMessages');

        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'authorization': this.configuration.apiKey('authorization') }), // api_key_header authentication
        };

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'market': market,
            'instrument': instrument,
        };

        if (afterTs != null) { query['after_ts'] = afterTs; }
        if (lastCcseq != null) { query['last_ccseq'] = lastCcseq; }
        if (limit != null) { query['limit'] = limit; }
        if (mappingPriority != null) { query['mapping_priority'] = mappingPriority; }
        if (responseFormat != null) { query['response_format'] = responseFormat; }
        if (return404OnEmptyResponse != null) { query['return_404_on_empty_response'] = return404OnEmptyResponse; }
        if (this.configuration.apiKey != null) { query['api_key'] = this.configuration.apiKey('api_key'); } // api_key_query authentication

        return this.request<GENERICRESPONSE>({
            url: '/index/v1/historical/messages',
            method: 'GET',
            headers,
            query,
        }, opts?.responseOpts);
    };

    /**
     */
    indexV1HistoricalMessagesHour({ market, instrument, hourTs, mappingPriority, responseFormat, return404OnEmptyResponse }: IndexV1HistoricalMessagesHourRequest): Observable<GENERICRESPONSE>
    indexV1HistoricalMessagesHour({ market, instrument, hourTs, mappingPriority, responseFormat, return404OnEmptyResponse }: IndexV1HistoricalMessagesHourRequest, opts?: OperationOpts): Observable<AjaxResponse<GENERICRESPONSE>>
    indexV1HistoricalMessagesHour({ market, instrument, hourTs, mappingPriority, responseFormat, return404OnEmptyResponse }: IndexV1HistoricalMessagesHourRequest, opts?: OperationOpts): Observable<GENERICRESPONSE | AjaxResponse<GENERICRESPONSE>> {
        throwIfNullOrUndefined(market, 'market', 'indexV1HistoricalMessagesHour');
        throwIfNullOrUndefined(instrument, 'instrument', 'indexV1HistoricalMessagesHour');

        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'authorization': this.configuration.apiKey('authorization') }), // api_key_header authentication
        };

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'market': market,
            'instrument': instrument,
        };

        if (hourTs != null) { query['hour_ts'] = hourTs; }
        if (mappingPriority != null) { query['mapping_priority'] = mappingPriority; }
        if (responseFormat != null) { query['response_format'] = responseFormat; }
        if (return404OnEmptyResponse != null) { query['return_404_on_empty_response'] = return404OnEmptyResponse; }
        if (this.configuration.apiKey != null) { query['api_key'] = this.configuration.apiKey('api_key'); } // api_key_query authentication

        return this.request<GENERICRESPONSE>({
            url: '/index/v1/historical/messages/hour',
            method: 'GET',
            headers,
            query,
        }, opts?.responseOpts);
    };

    /**
     */
    indexV1HistoricalMinutes({ market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat }: IndexV1HistoricalMinutesRequest): Observable<GENERICRESPONSE>
    indexV1HistoricalMinutes({ market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat }: IndexV1HistoricalMinutesRequest, opts?: OperationOpts): Observable<AjaxResponse<GENERICRESPONSE>>
    indexV1HistoricalMinutes({ market, instrument, groups, limit, toTs, aggregate, fill, mappingPriority, responseFormat }: IndexV1HistoricalMinutesRequest, opts?: OperationOpts): Observable<GENERICRESPONSE | AjaxResponse<GENERICRESPONSE>> {
        throwIfNullOrUndefined(market, 'market', 'indexV1HistoricalMinutes');
        throwIfNullOrUndefined(instrument, 'instrument', 'indexV1HistoricalMinutes');

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'market': market,
            'instrument': instrument,
        };

        if (groups != null) { query['groups'] = groups.join(COLLECTION_FORMATS['csv']); }
        if (limit != null) { query['limit'] = limit; }
        if (toTs != null) { query['to_ts'] = toTs; }
        if (aggregate != null) { query['aggregate'] = aggregate; }
        if (fill != null) { query['fill'] = fill; }
        if (mappingPriority != null) { query['mapping_priority'] = mappingPriority; }
        if (responseFormat != null) { query['response_format'] = responseFormat; }

        return this.request<GENERICRESPONSE>({
            url: '/index/v1/historical/minutes',
            method: 'GET',
            query,
        }, opts?.responseOpts);
    };

    /**
     */
    indexV1LatestInstrumentMetadata({ market, instruments, groups, mappingPriority }: IndexV1LatestInstrumentMetadataRequest): Observable<GENERICRESPONSE>
    indexV1LatestInstrumentMetadata({ market, instruments, groups, mappingPriority }: IndexV1LatestInstrumentMetadataRequest, opts?: OperationOpts): Observable<AjaxResponse<GENERICRESPONSE>>
    indexV1LatestInstrumentMetadata({ market, instruments, groups, mappingPriority }: IndexV1LatestInstrumentMetadataRequest, opts?: OperationOpts): Observable<GENERICRESPONSE | AjaxResponse<GENERICRESPONSE>> {
        throwIfNullOrUndefined(market, 'market', 'indexV1LatestInstrumentMetadata');
        throwIfNullOrUndefined(instruments, 'instruments', 'indexV1LatestInstrumentMetadata');

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'market': market,
            'instruments': instruments.join(COLLECTION_FORMATS['csv']),
        };

        if (groups != null) { query['groups'] = groups.join(COLLECTION_FORMATS['csv']); }
        if (mappingPriority != null) { query['mapping_priority'] = mappingPriority; }

        return this.request<GENERICRESPONSE>({
            url: '/index/v1/latest/instrument/metadata',
            method: 'GET',
            query,
        }, opts?.responseOpts);
    };

    /**
     */
    indexV1LatestTick({ market, instruments, groups, mappingPriority }: IndexV1LatestTickRequest): Observable<GENERICRESPONSE>
    indexV1LatestTick({ market, instruments, groups, mappingPriority }: IndexV1LatestTickRequest, opts?: OperationOpts): Observable<AjaxResponse<GENERICRESPONSE>>
    indexV1LatestTick({ market, instruments, groups, mappingPriority }: IndexV1LatestTickRequest, opts?: OperationOpts): Observable<GENERICRESPONSE | AjaxResponse<GENERICRESPONSE>> {
        throwIfNullOrUndefined(market, 'market', 'indexV1LatestTick');
        throwIfNullOrUndefined(instruments, 'instruments', 'indexV1LatestTick');

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'market': market,
            'instruments': instruments.join(COLLECTION_FORMATS['csv']),
        };

        if (groups != null) { query['groups'] = groups.join(COLLECTION_FORMATS['csv']); }
        if (mappingPriority != null) { query['mapping_priority'] = mappingPriority; }

        return this.request<GENERICRESPONSE>({
            url: '/index/v1/latest/tick',
            method: 'GET',
            query,
        }, opts?.responseOpts);
    };

    /**
     */
    indexV1Markets({ market }: IndexV1MarketsRequest): Observable<GENERICRESPONSE>
    indexV1Markets({ market }: IndexV1MarketsRequest, opts?: OperationOpts): Observable<AjaxResponse<GENERICRESPONSE>>
    indexV1Markets({ market }: IndexV1MarketsRequest, opts?: OperationOpts): Observable<GENERICRESPONSE | AjaxResponse<GENERICRESPONSE>> {

        const query: HttpQuery = {};

        if (market != null) { query['market'] = market; }

        return this.request<GENERICRESPONSE>({
            url: '/index/v1/markets',
            method: 'GET',
            query,
        }, opts?.responseOpts);
    };

    /**
     */
    indexV1MarketsInstruments({ market, instrument, instrumentStatus }: IndexV1MarketsInstrumentsRequest): Observable<GENERICRESPONSE>
    indexV1MarketsInstruments({ market, instrument, instrumentStatus }: IndexV1MarketsInstrumentsRequest, opts?: OperationOpts): Observable<AjaxResponse<GENERICRESPONSE>>
    indexV1MarketsInstruments({ market, instrument, instrumentStatus }: IndexV1MarketsInstrumentsRequest, opts?: OperationOpts): Observable<GENERICRESPONSE | AjaxResponse<GENERICRESPONSE>> {

        const query: HttpQuery = {};

        if (market != null) { query['market'] = market; }
        if (instrument != null) { query['instrument'] = instrument; }
        if (instrumentStatus != null) { query['instrument_status'] = instrumentStatus.join(COLLECTION_FORMATS['csv']); }

        return this.request<GENERICRESPONSE>({
            url: '/index/v1/markets/instruments',
            method: 'GET',
            query,
        }, opts?.responseOpts);
    };

    /**
     */
    indexV1MarketsInstrumentsUnmapped({ market, instrument, instrumentStatus }: IndexV1MarketsInstrumentsUnmappedRequest): Observable<GENERICRESPONSE>
    indexV1MarketsInstrumentsUnmapped({ market, instrument, instrumentStatus }: IndexV1MarketsInstrumentsUnmappedRequest, opts?: OperationOpts): Observable<AjaxResponse<GENERICRESPONSE>>
    indexV1MarketsInstrumentsUnmapped({ market, instrument, instrumentStatus }: IndexV1MarketsInstrumentsUnmappedRequest, opts?: OperationOpts): Observable<GENERICRESPONSE | AjaxResponse<GENERICRESPONSE>> {

        const query: HttpQuery = {};

        if (market != null) { query['market'] = market; }
        if (instrument != null) { query['instrument'] = instrument; }
        if (instrumentStatus != null) { query['instrument_status'] = instrumentStatus.join(COLLECTION_FORMATS['csv']); }

        return this.request<GENERICRESPONSE>({
            url: '/index/v1/markets/instruments/unmapped',
            method: 'GET',
            query,
        }, opts?.responseOpts);
    };

}

/**
 * @export
 * @enum {string}
 */
export enum FuturesV1HistoricalDaysMappingPriorityEnum {
    MappedFirst = 'CHECK_MAPPED_FIRST',
    UnmappedFirst = 'CHECK_UNMAPPED_FIRST'
}
/**
 * @export
 * @enum {string}
 */
export enum FuturesV1HistoricalDaysResponseFormatEnum {
    Json = 'JSON',
    Csv = 'CSV'
}
/**
 * @export
 * @enum {string}
 */
export enum FuturesV1HistoricalFundingRateDaysMappingPriorityEnum {
    MappedFirst = 'CHECK_MAPPED_FIRST',
    UnmappedFirst = 'CHECK_UNMAPPED_FIRST'
}
/**
 * @export
 * @enum {string}
 */
export enum FuturesV1HistoricalFundingRateDaysResponseFormatEnum {
    Json = 'JSON',
    Csv = 'CSV'
}
/**
 * @export
 * @enum {string}
 */
export enum FuturesV1HistoricalFundingRateHoursMappingPriorityEnum {
    MappedFirst = 'CHECK_MAPPED_FIRST',
    UnmappedFirst = 'CHECK_UNMAPPED_FIRST'
}
/**
 * @export
 * @enum {string}
 */
export enum FuturesV1HistoricalFundingRateHoursResponseFormatEnum {
    Json = 'JSON',
    Csv = 'CSV'
}
/**
 * @export
 * @enum {string}
 */
export enum FuturesV1HistoricalFundingRateMessagesMappingPriorityEnum {
    MappedFirst = 'CHECK_MAPPED_FIRST',
    UnmappedFirst = 'CHECK_UNMAPPED_FIRST'
}
/**
 * @export
 * @enum {string}
 */
export enum FuturesV1HistoricalFundingRateMessagesResponseFormatEnum {
    Json = 'JSON',
    Csv = 'CSV'
}
/**
 * @export
 * @enum {string}
 */
export enum FuturesV1HistoricalFundingRateMessagesHourMappingPriorityEnum {
    MappedFirst = 'CHECK_MAPPED_FIRST',
    UnmappedFirst = 'CHECK_UNMAPPED_FIRST'
}
/**
 * @export
 * @enum {string}
 */
export enum FuturesV1HistoricalFundingRateMessagesHourResponseFormatEnum {
    Json = 'JSON',
    Csv = 'CSV'
}
/**
 * @export
 * @enum {string}
 */
export enum FuturesV1HistoricalFundingRateMinutesMappingPriorityEnum {
    MappedFirst = 'CHECK_MAPPED_FIRST',
    UnmappedFirst = 'CHECK_UNMAPPED_FIRST'
}
/**
 * @export
 * @enum {string}
 */
export enum FuturesV1HistoricalFundingRateMinutesResponseFormatEnum {
    Json = 'JSON',
    Csv = 'CSV'
}
/**
 * @export
 * @enum {string}
 */
export enum FuturesV1HistoricalHoursMappingPriorityEnum {
    MappedFirst = 'CHECK_MAPPED_FIRST',
    UnmappedFirst = 'CHECK_UNMAPPED_FIRST'
}
/**
 * @export
 * @enum {string}
 */
export enum FuturesV1HistoricalHoursResponseFormatEnum {
    Json = 'JSON',
    Csv = 'CSV'
}
/**
 * @export
 * @enum {string}
 */
export enum FuturesV1HistoricalMinutesMappingPriorityEnum {
    MappedFirst = 'CHECK_MAPPED_FIRST',
    UnmappedFirst = 'CHECK_UNMAPPED_FIRST'
}
/**
 * @export
 * @enum {string}
 */
export enum FuturesV1HistoricalMinutesResponseFormatEnum {
    Json = 'JSON',
    Csv = 'CSV'
}
/**
 * @export
 * @enum {string}
 */
export enum FuturesV1HistoricalOpenInterestDaysMappingPriorityEnum {
    MappedFirst = 'CHECK_MAPPED_FIRST',
    UnmappedFirst = 'CHECK_UNMAPPED_FIRST'
}
/**
 * @export
 * @enum {string}
 */
export enum FuturesV1HistoricalOpenInterestDaysResponseFormatEnum {
    Json = 'JSON',
    Csv = 'CSV'
}
/**
 * @export
 * @enum {string}
 */
export enum FuturesV1HistoricalOpenInterestHoursMappingPriorityEnum {
    MappedFirst = 'CHECK_MAPPED_FIRST',
    UnmappedFirst = 'CHECK_UNMAPPED_FIRST'
}
/**
 * @export
 * @enum {string}
 */
export enum FuturesV1HistoricalOpenInterestHoursResponseFormatEnum {
    Json = 'JSON',
    Csv = 'CSV'
}
/**
 * @export
 * @enum {string}
 */
export enum FuturesV1HistoricalOpenInterestMessagesMappingPriorityEnum {
    MappedFirst = 'CHECK_MAPPED_FIRST',
    UnmappedFirst = 'CHECK_UNMAPPED_FIRST'
}
/**
 * @export
 * @enum {string}
 */
export enum FuturesV1HistoricalOpenInterestMessagesResponseFormatEnum {
    Json = 'JSON',
    Csv = 'CSV'
}
/**
 * @export
 * @enum {string}
 */
export enum FuturesV1HistoricalOpenInterestMessagesHourMappingPriorityEnum {
    MappedFirst = 'CHECK_MAPPED_FIRST',
    UnmappedFirst = 'CHECK_UNMAPPED_FIRST'
}
/**
 * @export
 * @enum {string}
 */
export enum FuturesV1HistoricalOpenInterestMessagesHourResponseFormatEnum {
    Json = 'JSON',
    Csv = 'CSV'
}
/**
 * @export
 * @enum {string}
 */
export enum FuturesV1HistoricalOpenInterestMinutesMappingPriorityEnum {
    MappedFirst = 'CHECK_MAPPED_FIRST',
    UnmappedFirst = 'CHECK_UNMAPPED_FIRST'
}
/**
 * @export
 * @enum {string}
 */
export enum FuturesV1HistoricalOpenInterestMinutesResponseFormatEnum {
    Json = 'JSON',
    Csv = 'CSV'
}
/**
 * @export
 * @enum {string}
 */
export enum FuturesV1HistoricalTradesMappingPriorityEnum {
    MappedFirst = 'CHECK_MAPPED_FIRST',
    UnmappedFirst = 'CHECK_UNMAPPED_FIRST'
}
/**
 * @export
 * @enum {string}
 */
export enum FuturesV1HistoricalTradesResponseFormatEnum {
    Json = 'JSON',
    Csv = 'CSV'
}
/**
 * @export
 * @enum {string}
 */
export enum FuturesV1HistoricalTradesHourMappingPriorityEnum {
    MappedFirst = 'CHECK_MAPPED_FIRST',
    UnmappedFirst = 'CHECK_UNMAPPED_FIRST'
}
/**
 * @export
 * @enum {string}
 */
export enum FuturesV1HistoricalTradesHourResponseFormatEnum {
    Json = 'JSON',
    Csv = 'CSV'
}
/**
 * @export
 * @enum {string}
 */
export enum FuturesV1LatestFundingRateTickMappingPriorityEnum {
    MappedFirst = 'CHECK_MAPPED_FIRST',
    UnmappedFirst = 'CHECK_UNMAPPED_FIRST'
}
/**
 * @export
 * @enum {string}
 */
export enum FuturesV1LatestInstrumentMetadataMappingPriorityEnum {
    MappedFirst = 'CHECK_MAPPED_FIRST',
    UnmappedFirst = 'CHECK_UNMAPPED_FIRST'
}
/**
 * @export
 * @enum {string}
 */
export enum FuturesV1LatestOpenInterestTickMappingPriorityEnum {
    MappedFirst = 'CHECK_MAPPED_FIRST',
    UnmappedFirst = 'CHECK_UNMAPPED_FIRST'
}
/**
 * @export
 * @enum {string}
 */
export enum FuturesV1LatestTickMappingPriorityEnum {
    MappedFirst = 'CHECK_MAPPED_FIRST',
    UnmappedFirst = 'CHECK_UNMAPPED_FIRST'
}
/**
 * @export
 * @enum {string}
 */
export enum FuturesV1MarketsInstrumentsInstrumentStatusEnum {
    Active = 'ACTIVE',
    Ignored = 'IGNORED',
    Retired = 'RETIRED',
    Expired = 'EXPIRED'
}
/**
 * @export
 * @enum {string}
 */
export enum FuturesV1MarketsInstrumentsUnmappedInstrumentStatusEnum {
    Active = 'ACTIVE',
    Ignored = 'IGNORED',
    Retired = 'RETIRED',
    Expired = 'EXPIRED'
}
/**
 * @export
 * @enum {string}
 */
export enum IndexV1HistoricalDaysMappingPriorityEnum {
    MappedFirst = 'CHECK_MAPPED_FIRST',
    UnmappedFirst = 'CHECK_UNMAPPED_FIRST'
}
/**
 * @export
 * @enum {string}
 */
export enum IndexV1HistoricalDaysResponseFormatEnum {
    Json = 'JSON',
    Csv = 'CSV'
}
/**
 * @export
 * @enum {string}
 */
export enum IndexV1HistoricalHoursMappingPriorityEnum {
    MappedFirst = 'CHECK_MAPPED_FIRST',
    UnmappedFirst = 'CHECK_UNMAPPED_FIRST'
}
/**
 * @export
 * @enum {string}
 */
export enum IndexV1HistoricalHoursResponseFormatEnum {
    Json = 'JSON',
    Csv = 'CSV'
}
/**
 * @export
 * @enum {string}
 */
export enum IndexV1HistoricalMessagesMappingPriorityEnum {
    MappedFirst = 'CHECK_MAPPED_FIRST',
    UnmappedFirst = 'CHECK_UNMAPPED_FIRST'
}
/**
 * @export
 * @enum {string}
 */
export enum IndexV1HistoricalMessagesResponseFormatEnum {
    Json = 'JSON',
    Csv = 'CSV'
}
/**
 * @export
 * @enum {string}
 */
export enum IndexV1HistoricalMessagesHourMappingPriorityEnum {
    MappedFirst = 'CHECK_MAPPED_FIRST',
    UnmappedFirst = 'CHECK_UNMAPPED_FIRST'
}
/**
 * @export
 * @enum {string}
 */
export enum IndexV1HistoricalMessagesHourResponseFormatEnum {
    Json = 'JSON',
    Csv = 'CSV'
}
/**
 * @export
 * @enum {string}
 */
export enum IndexV1HistoricalMinutesMappingPriorityEnum {
    MappedFirst = 'CHECK_MAPPED_FIRST',
    UnmappedFirst = 'CHECK_UNMAPPED_FIRST'
}
/**
 * @export
 * @enum {string}
 */
export enum IndexV1HistoricalMinutesResponseFormatEnum {
    Json = 'JSON',
    Csv = 'CSV'
}
/**
 * @export
 * @enum {string}
 */
export enum IndexV1LatestInstrumentMetadataMappingPriorityEnum {
    MappedFirst = 'CHECK_MAPPED_FIRST',
    UnmappedFirst = 'CHECK_UNMAPPED_FIRST'
}
/**
 * @export
 * @enum {string}
 */
export enum IndexV1LatestTickMappingPriorityEnum {
    MappedFirst = 'CHECK_MAPPED_FIRST',
    UnmappedFirst = 'CHECK_UNMAPPED_FIRST'
}
/**
 * @export
 * @enum {string}
 */
export enum IndexV1MarketsInstrumentsInstrumentStatusEnum {
    Active = 'ACTIVE',
    Ignored = 'IGNORED',
    Retired = 'RETIRED',
    Expired = 'EXPIRED'
}
/**
 * @export
 * @enum {string}
 */
export enum IndexV1MarketsInstrumentsUnmappedInstrumentStatusEnum {
    Active = 'ACTIVE',
    Ignored = 'IGNORED',
    Retired = 'RETIRED',
    Expired = 'EXPIRED'
}
