// tslint:disable
/**
 * CryptoCompare Market, Index, Reference Data, News and Overview Metrcis API for the Cryptocurrency Industry
 * CryptoCompare is the world\'s leading digital asset data company, providing services that cater to corporate, government and retail clients. Our main reference index is widely recognized as a reliable benchmark, and we have been authorized by the Financial Conduct Authority (FCA) in the United Kingdom to operate as a benchmark administrator. In addition to catering to corporate, government, and retail clients, we offer a range of services including comprehensive market data for cryptocurrency exchanges in both the centralized and decentralized finance sectors, as well as individual asset data on custodians, supported platforms, and privacy solutions. Our offerings include price, volume, trade, and orderbook updates, as well as historical OHLCV data.
 *
 * The version of the OpenAPI document: 2.1.1
 * Contact: data@cryptocompare.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { HttpMethods, QueryConfig, ResponseBody, ResponseText } from 'redux-query';
import * as runtime from '../runtime';
import {
    GENERICRESPONSE,
    GENERICRESPONSEFromJSON,
    GENERICRESPONSEToJSON,
} from '../models';

export interface FuturesV1HistoricalDaysRequest {
    market: string;
    instrument: string;
    groups?: Array<string>;
    limit?: number;
    toTs?: number;
    aggregate?: number;
    fill?: boolean;
    mappingPriority?: FuturesV1HistoricalDaysMappingPriorityEnum;
    responseFormat?: FuturesV1HistoricalDaysResponseFormatEnum;
}

export interface FuturesV1HistoricalFundingRateDaysRequest {
    market: string;
    instrument: string;
    groups?: Array<string>;
    limit?: number;
    toTs?: number;
    aggregate?: number;
    fill?: boolean;
    mappingPriority?: FuturesV1HistoricalFundingRateDaysMappingPriorityEnum;
    responseFormat?: FuturesV1HistoricalFundingRateDaysResponseFormatEnum;
}

export interface FuturesV1HistoricalFundingRateHoursRequest {
    market: string;
    instrument: string;
    groups?: Array<string>;
    limit?: number;
    toTs?: number;
    aggregate?: number;
    fill?: boolean;
    mappingPriority?: FuturesV1HistoricalFundingRateHoursMappingPriorityEnum;
    responseFormat?: FuturesV1HistoricalFundingRateHoursResponseFormatEnum;
}

export interface FuturesV1HistoricalFundingRateMessagesRequest {
    market: string;
    instrument: string;
    afterTs?: number;
    lastCcseq?: number;
    limit?: number;
    mappingPriority?: FuturesV1HistoricalFundingRateMessagesMappingPriorityEnum;
    responseFormat?: FuturesV1HistoricalFundingRateMessagesResponseFormatEnum;
    return404OnEmptyResponse?: boolean;
}

export interface FuturesV1HistoricalFundingRateMessagesHourRequest {
    market: string;
    instrument: string;
    hourTs?: number;
    mappingPriority?: FuturesV1HistoricalFundingRateMessagesHourMappingPriorityEnum;
    responseFormat?: FuturesV1HistoricalFundingRateMessagesHourResponseFormatEnum;
    return404OnEmptyResponse?: boolean;
}

export interface FuturesV1HistoricalFundingRateMinutesRequest {
    market: string;
    instrument: string;
    groups?: Array<string>;
    limit?: number;
    toTs?: number;
    aggregate?: number;
    fill?: boolean;
    mappingPriority?: FuturesV1HistoricalFundingRateMinutesMappingPriorityEnum;
    responseFormat?: FuturesV1HistoricalFundingRateMinutesResponseFormatEnum;
}

export interface FuturesV1HistoricalHoursRequest {
    market: string;
    instrument: string;
    groups?: Array<string>;
    limit?: number;
    toTs?: number;
    aggregate?: number;
    fill?: boolean;
    mappingPriority?: FuturesV1HistoricalHoursMappingPriorityEnum;
    responseFormat?: FuturesV1HistoricalHoursResponseFormatEnum;
}

export interface FuturesV1HistoricalMinutesRequest {
    market: string;
    instrument: string;
    groups?: Array<string>;
    limit?: number;
    toTs?: number;
    aggregate?: number;
    fill?: boolean;
    mappingPriority?: FuturesV1HistoricalMinutesMappingPriorityEnum;
    responseFormat?: FuturesV1HistoricalMinutesResponseFormatEnum;
}

export interface FuturesV1HistoricalOpenInterestDaysRequest {
    market: string;
    instrument: string;
    groups?: Array<string>;
    limit?: number;
    toTs?: number;
    aggregate?: number;
    fill?: boolean;
    mappingPriority?: FuturesV1HistoricalOpenInterestDaysMappingPriorityEnum;
    responseFormat?: FuturesV1HistoricalOpenInterestDaysResponseFormatEnum;
}

export interface FuturesV1HistoricalOpenInterestHoursRequest {
    market: string;
    instrument: string;
    groups?: Array<string>;
    limit?: number;
    toTs?: number;
    aggregate?: number;
    fill?: boolean;
    mappingPriority?: FuturesV1HistoricalOpenInterestHoursMappingPriorityEnum;
    responseFormat?: FuturesV1HistoricalOpenInterestHoursResponseFormatEnum;
}

export interface FuturesV1HistoricalOpenInterestMessagesRequest {
    market: string;
    instrument: string;
    afterTs?: number;
    lastCcseq?: number;
    limit?: number;
    mappingPriority?: FuturesV1HistoricalOpenInterestMessagesMappingPriorityEnum;
    responseFormat?: FuturesV1HistoricalOpenInterestMessagesResponseFormatEnum;
    return404OnEmptyResponse?: boolean;
}

export interface FuturesV1HistoricalOpenInterestMessagesHourRequest {
    market: string;
    instrument: string;
    hourTs?: number;
    mappingPriority?: FuturesV1HistoricalOpenInterestMessagesHourMappingPriorityEnum;
    responseFormat?: FuturesV1HistoricalOpenInterestMessagesHourResponseFormatEnum;
    return404OnEmptyResponse?: boolean;
}

export interface FuturesV1HistoricalOpenInterestMinutesRequest {
    market: string;
    instrument: string;
    groups?: Array<string>;
    limit?: number;
    toTs?: number;
    aggregate?: number;
    fill?: boolean;
    mappingPriority?: FuturesV1HistoricalOpenInterestMinutesMappingPriorityEnum;
    responseFormat?: FuturesV1HistoricalOpenInterestMinutesResponseFormatEnum;
}

export interface FuturesV1HistoricalTradesRequest {
    market: string;
    instrument: string;
    afterTs?: number;
    lastCcseq?: number;
    limit?: number;
    mappingPriority?: FuturesV1HistoricalTradesMappingPriorityEnum;
    responseFormat?: FuturesV1HistoricalTradesResponseFormatEnum;
    return404OnEmptyResponse?: boolean;
}

export interface FuturesV1HistoricalTradesHourRequest {
    market: string;
    instrument: string;
    hourTs?: number;
    mappingPriority?: FuturesV1HistoricalTradesHourMappingPriorityEnum;
    responseFormat?: FuturesV1HistoricalTradesHourResponseFormatEnum;
    return404OnEmptyResponse?: boolean;
}

export interface FuturesV1LatestFundingRateTickRequest {
    market: string;
    instruments: Array<string>;
    groups?: Array<string>;
    mappingPriority?: FuturesV1LatestFundingRateTickMappingPriorityEnum;
}

export interface FuturesV1LatestInstrumentMetadataRequest {
    market: string;
    instruments: Array<string>;
    groups?: Array<string>;
    mappingPriority?: FuturesV1LatestInstrumentMetadataMappingPriorityEnum;
}

export interface FuturesV1LatestOpenInterestTickRequest {
    market: string;
    instruments: Array<string>;
    groups?: Array<string>;
    mappingPriority?: FuturesV1LatestOpenInterestTickMappingPriorityEnum;
}

export interface FuturesV1LatestTickRequest {
    market: string;
    instruments: Array<string>;
    groups?: Array<string>;
    mappingPriority?: FuturesV1LatestTickMappingPriorityEnum;
}

export interface FuturesV1MarketsRequest {
    market?: string;
}

export interface FuturesV1MarketsInstrumentsRequest {
    market?: string;
    instrument?: string;
    instrumentStatus?: Array<FuturesV1MarketsInstrumentsInstrumentStatusEnum>;
}

export interface FuturesV1MarketsInstrumentsUnmappedRequest {
    market?: string;
    instrument?: string;
    instrumentStatus?: Array<FuturesV1MarketsInstrumentsUnmappedInstrumentStatusEnum>;
}

export interface IndexV1HistoricalDaysRequest {
    market: string;
    instrument: string;
    groups?: Array<string>;
    limit?: number;
    toTs?: number;
    aggregate?: number;
    fill?: boolean;
    mappingPriority?: IndexV1HistoricalDaysMappingPriorityEnum;
    responseFormat?: IndexV1HistoricalDaysResponseFormatEnum;
}

export interface IndexV1HistoricalHoursRequest {
    market: string;
    instrument: string;
    groups?: Array<string>;
    limit?: number;
    toTs?: number;
    aggregate?: number;
    fill?: boolean;
    mappingPriority?: IndexV1HistoricalHoursMappingPriorityEnum;
    responseFormat?: IndexV1HistoricalHoursResponseFormatEnum;
}

export interface IndexV1HistoricalMessagesRequest {
    market: string;
    instrument: string;
    afterTs?: number;
    lastCcseq?: number;
    limit?: number;
    mappingPriority?: IndexV1HistoricalMessagesMappingPriorityEnum;
    responseFormat?: IndexV1HistoricalMessagesResponseFormatEnum;
    return404OnEmptyResponse?: boolean;
}

export interface IndexV1HistoricalMessagesHourRequest {
    market: string;
    instrument: string;
    hourTs?: number;
    mappingPriority?: IndexV1HistoricalMessagesHourMappingPriorityEnum;
    responseFormat?: IndexV1HistoricalMessagesHourResponseFormatEnum;
    return404OnEmptyResponse?: boolean;
}

export interface IndexV1HistoricalMinutesRequest {
    market: string;
    instrument: string;
    groups?: Array<string>;
    limit?: number;
    toTs?: number;
    aggregate?: number;
    fill?: boolean;
    mappingPriority?: IndexV1HistoricalMinutesMappingPriorityEnum;
    responseFormat?: IndexV1HistoricalMinutesResponseFormatEnum;
}

export interface IndexV1LatestInstrumentMetadataRequest {
    market: string;
    instruments: Array<string>;
    groups?: Array<string>;
    mappingPriority?: IndexV1LatestInstrumentMetadataMappingPriorityEnum;
}

export interface IndexV1LatestTickRequest {
    market: string;
    instruments: Array<string>;
    groups?: Array<string>;
    mappingPriority?: IndexV1LatestTickMappingPriorityEnum;
}

export interface IndexV1MarketsRequest {
    market?: string;
}

export interface IndexV1MarketsInstrumentsRequest {
    market?: string;
    instrument?: string;
    instrumentStatus?: Array<IndexV1MarketsInstrumentsInstrumentStatusEnum>;
}

export interface IndexV1MarketsInstrumentsUnmappedRequest {
    market?: string;
    instrument?: string;
    instrumentStatus?: Array<IndexV1MarketsInstrumentsUnmappedInstrumentStatusEnum>;
}


/**
 */
function futuresV1HistoricalDaysRaw<T>(requestParameters: FuturesV1HistoricalDaysRequest, requestConfig: runtime.TypedQueryConfig<T, GENERICRESPONSE> = {}): QueryConfig<T> {
    if (requestParameters.market === null || requestParameters.market === undefined) {
        throw new runtime.RequiredError('market','Required parameter requestParameters.market was null or undefined when calling futuresV1HistoricalDays.');
    }

    if (requestParameters.instrument === null || requestParameters.instrument === undefined) {
        throw new runtime.RequiredError('instrument','Required parameter requestParameters.instrument was null or undefined when calling futuresV1HistoricalDays.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.market !== undefined) {
        queryParameters['market'] = requestParameters.market;
    }


    if (requestParameters.instrument !== undefined) {
        queryParameters['instrument'] = requestParameters.instrument;
    }


    if (requestParameters.groups) {
        queryParameters['groups'] = requestParameters.groups?.join(runtime.COLLECTION_FORMATS["csv"]);
    }


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.toTs !== undefined) {
        queryParameters['to_ts'] = requestParameters.toTs;
    }


    if (requestParameters.aggregate !== undefined) {
        queryParameters['aggregate'] = requestParameters.aggregate;
    }


    if (requestParameters.fill !== undefined) {
        queryParameters['fill'] = requestParameters.fill;
    }


    if (requestParameters.mappingPriority !== undefined) {
        queryParameters['mapping_priority'] = requestParameters.mappingPriority;
    }


    if (requestParameters.responseFormat !== undefined) {
        queryParameters['response_format'] = requestParameters.responseFormat;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/futures/v1/historical/days`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(GENERICRESPONSEFromJSON(body), text);
    }

    return config;
}

/**
*/
export function futuresV1HistoricalDays<T>(requestParameters: FuturesV1HistoricalDaysRequest, requestConfig?: runtime.TypedQueryConfig<T, GENERICRESPONSE>): QueryConfig<T> {
    return futuresV1HistoricalDaysRaw(requestParameters, requestConfig);
}

/**
 */
function futuresV1HistoricalFundingRateDaysRaw<T>(requestParameters: FuturesV1HistoricalFundingRateDaysRequest, requestConfig: runtime.TypedQueryConfig<T, GENERICRESPONSE> = {}): QueryConfig<T> {
    if (requestParameters.market === null || requestParameters.market === undefined) {
        throw new runtime.RequiredError('market','Required parameter requestParameters.market was null or undefined when calling futuresV1HistoricalFundingRateDays.');
    }

    if (requestParameters.instrument === null || requestParameters.instrument === undefined) {
        throw new runtime.RequiredError('instrument','Required parameter requestParameters.instrument was null or undefined when calling futuresV1HistoricalFundingRateDays.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.market !== undefined) {
        queryParameters['market'] = requestParameters.market;
    }


    if (requestParameters.instrument !== undefined) {
        queryParameters['instrument'] = requestParameters.instrument;
    }


    if (requestParameters.groups) {
        queryParameters['groups'] = requestParameters.groups?.join(runtime.COLLECTION_FORMATS["csv"]);
    }


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.toTs !== undefined) {
        queryParameters['to_ts'] = requestParameters.toTs;
    }


    if (requestParameters.aggregate !== undefined) {
        queryParameters['aggregate'] = requestParameters.aggregate;
    }


    if (requestParameters.fill !== undefined) {
        queryParameters['fill'] = requestParameters.fill;
    }


    if (requestParameters.mappingPriority !== undefined) {
        queryParameters['mapping_priority'] = requestParameters.mappingPriority;
    }


    if (requestParameters.responseFormat !== undefined) {
        queryParameters['response_format'] = requestParameters.responseFormat;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/futures/v1/historical/funding-rate/days`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(GENERICRESPONSEFromJSON(body), text);
    }

    return config;
}

/**
*/
export function futuresV1HistoricalFundingRateDays<T>(requestParameters: FuturesV1HistoricalFundingRateDaysRequest, requestConfig?: runtime.TypedQueryConfig<T, GENERICRESPONSE>): QueryConfig<T> {
    return futuresV1HistoricalFundingRateDaysRaw(requestParameters, requestConfig);
}

/**
 */
function futuresV1HistoricalFundingRateHoursRaw<T>(requestParameters: FuturesV1HistoricalFundingRateHoursRequest, requestConfig: runtime.TypedQueryConfig<T, GENERICRESPONSE> = {}): QueryConfig<T> {
    if (requestParameters.market === null || requestParameters.market === undefined) {
        throw new runtime.RequiredError('market','Required parameter requestParameters.market was null or undefined when calling futuresV1HistoricalFundingRateHours.');
    }

    if (requestParameters.instrument === null || requestParameters.instrument === undefined) {
        throw new runtime.RequiredError('instrument','Required parameter requestParameters.instrument was null or undefined when calling futuresV1HistoricalFundingRateHours.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.market !== undefined) {
        queryParameters['market'] = requestParameters.market;
    }


    if (requestParameters.instrument !== undefined) {
        queryParameters['instrument'] = requestParameters.instrument;
    }


    if (requestParameters.groups) {
        queryParameters['groups'] = requestParameters.groups?.join(runtime.COLLECTION_FORMATS["csv"]);
    }


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.toTs !== undefined) {
        queryParameters['to_ts'] = requestParameters.toTs;
    }


    if (requestParameters.aggregate !== undefined) {
        queryParameters['aggregate'] = requestParameters.aggregate;
    }


    if (requestParameters.fill !== undefined) {
        queryParameters['fill'] = requestParameters.fill;
    }


    if (requestParameters.mappingPriority !== undefined) {
        queryParameters['mapping_priority'] = requestParameters.mappingPriority;
    }


    if (requestParameters.responseFormat !== undefined) {
        queryParameters['response_format'] = requestParameters.responseFormat;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/futures/v1/historical/funding-rate/hours`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(GENERICRESPONSEFromJSON(body), text);
    }

    return config;
}

/**
*/
export function futuresV1HistoricalFundingRateHours<T>(requestParameters: FuturesV1HistoricalFundingRateHoursRequest, requestConfig?: runtime.TypedQueryConfig<T, GENERICRESPONSE>): QueryConfig<T> {
    return futuresV1HistoricalFundingRateHoursRaw(requestParameters, requestConfig);
}

/**
 */
function futuresV1HistoricalFundingRateMessagesRaw<T>(requestParameters: FuturesV1HistoricalFundingRateMessagesRequest, requestConfig: runtime.TypedQueryConfig<T, GENERICRESPONSE> = {}): QueryConfig<T> {
    if (requestParameters.market === null || requestParameters.market === undefined) {
        throw new runtime.RequiredError('market','Required parameter requestParameters.market was null or undefined when calling futuresV1HistoricalFundingRateMessages.');
    }

    if (requestParameters.instrument === null || requestParameters.instrument === undefined) {
        throw new runtime.RequiredError('instrument','Required parameter requestParameters.instrument was null or undefined when calling futuresV1HistoricalFundingRateMessages.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.market !== undefined) {
        queryParameters['market'] = requestParameters.market;
    }


    if (requestParameters.instrument !== undefined) {
        queryParameters['instrument'] = requestParameters.instrument;
    }


    if (requestParameters.afterTs !== undefined) {
        queryParameters['after_ts'] = requestParameters.afterTs;
    }


    if (requestParameters.lastCcseq !== undefined) {
        queryParameters['last_ccseq'] = requestParameters.lastCcseq;
    }


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.mappingPriority !== undefined) {
        queryParameters['mapping_priority'] = requestParameters.mappingPriority;
    }


    if (requestParameters.responseFormat !== undefined) {
        queryParameters['response_format'] = requestParameters.responseFormat;
    }


    if (requestParameters.return404OnEmptyResponse !== undefined) {
        queryParameters['return_404_on_empty_response'] = requestParameters.return404OnEmptyResponse;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['api_key', 'header'];
    meta.authType = ['api_key', 'query'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/futures/v1/historical/funding-rate-messages`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(GENERICRESPONSEFromJSON(body), text);
    }

    return config;
}

/**
*/
export function futuresV1HistoricalFundingRateMessages<T>(requestParameters: FuturesV1HistoricalFundingRateMessagesRequest, requestConfig?: runtime.TypedQueryConfig<T, GENERICRESPONSE>): QueryConfig<T> {
    return futuresV1HistoricalFundingRateMessagesRaw(requestParameters, requestConfig);
}

/**
 */
function futuresV1HistoricalFundingRateMessagesHourRaw<T>(requestParameters: FuturesV1HistoricalFundingRateMessagesHourRequest, requestConfig: runtime.TypedQueryConfig<T, GENERICRESPONSE> = {}): QueryConfig<T> {
    if (requestParameters.market === null || requestParameters.market === undefined) {
        throw new runtime.RequiredError('market','Required parameter requestParameters.market was null or undefined when calling futuresV1HistoricalFundingRateMessagesHour.');
    }

    if (requestParameters.instrument === null || requestParameters.instrument === undefined) {
        throw new runtime.RequiredError('instrument','Required parameter requestParameters.instrument was null or undefined when calling futuresV1HistoricalFundingRateMessagesHour.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.market !== undefined) {
        queryParameters['market'] = requestParameters.market;
    }


    if (requestParameters.instrument !== undefined) {
        queryParameters['instrument'] = requestParameters.instrument;
    }


    if (requestParameters.hourTs !== undefined) {
        queryParameters['hour_ts'] = requestParameters.hourTs;
    }


    if (requestParameters.mappingPriority !== undefined) {
        queryParameters['mapping_priority'] = requestParameters.mappingPriority;
    }


    if (requestParameters.responseFormat !== undefined) {
        queryParameters['response_format'] = requestParameters.responseFormat;
    }


    if (requestParameters.return404OnEmptyResponse !== undefined) {
        queryParameters['return_404_on_empty_response'] = requestParameters.return404OnEmptyResponse;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['api_key', 'header'];
    meta.authType = ['api_key', 'query'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/futures/v1/historical/funding-rate-messages/hour`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(GENERICRESPONSEFromJSON(body), text);
    }

    return config;
}

/**
*/
export function futuresV1HistoricalFundingRateMessagesHour<T>(requestParameters: FuturesV1HistoricalFundingRateMessagesHourRequest, requestConfig?: runtime.TypedQueryConfig<T, GENERICRESPONSE>): QueryConfig<T> {
    return futuresV1HistoricalFundingRateMessagesHourRaw(requestParameters, requestConfig);
}

/**
 */
function futuresV1HistoricalFundingRateMinutesRaw<T>(requestParameters: FuturesV1HistoricalFundingRateMinutesRequest, requestConfig: runtime.TypedQueryConfig<T, GENERICRESPONSE> = {}): QueryConfig<T> {
    if (requestParameters.market === null || requestParameters.market === undefined) {
        throw new runtime.RequiredError('market','Required parameter requestParameters.market was null or undefined when calling futuresV1HistoricalFundingRateMinutes.');
    }

    if (requestParameters.instrument === null || requestParameters.instrument === undefined) {
        throw new runtime.RequiredError('instrument','Required parameter requestParameters.instrument was null or undefined when calling futuresV1HistoricalFundingRateMinutes.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.market !== undefined) {
        queryParameters['market'] = requestParameters.market;
    }


    if (requestParameters.instrument !== undefined) {
        queryParameters['instrument'] = requestParameters.instrument;
    }


    if (requestParameters.groups) {
        queryParameters['groups'] = requestParameters.groups?.join(runtime.COLLECTION_FORMATS["csv"]);
    }


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.toTs !== undefined) {
        queryParameters['to_ts'] = requestParameters.toTs;
    }


    if (requestParameters.aggregate !== undefined) {
        queryParameters['aggregate'] = requestParameters.aggregate;
    }


    if (requestParameters.fill !== undefined) {
        queryParameters['fill'] = requestParameters.fill;
    }


    if (requestParameters.mappingPriority !== undefined) {
        queryParameters['mapping_priority'] = requestParameters.mappingPriority;
    }


    if (requestParameters.responseFormat !== undefined) {
        queryParameters['response_format'] = requestParameters.responseFormat;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/futures/v1/historical/funding-rate/minutes`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(GENERICRESPONSEFromJSON(body), text);
    }

    return config;
}

/**
*/
export function futuresV1HistoricalFundingRateMinutes<T>(requestParameters: FuturesV1HistoricalFundingRateMinutesRequest, requestConfig?: runtime.TypedQueryConfig<T, GENERICRESPONSE>): QueryConfig<T> {
    return futuresV1HistoricalFundingRateMinutesRaw(requestParameters, requestConfig);
}

/**
 */
function futuresV1HistoricalHoursRaw<T>(requestParameters: FuturesV1HistoricalHoursRequest, requestConfig: runtime.TypedQueryConfig<T, GENERICRESPONSE> = {}): QueryConfig<T> {
    if (requestParameters.market === null || requestParameters.market === undefined) {
        throw new runtime.RequiredError('market','Required parameter requestParameters.market was null or undefined when calling futuresV1HistoricalHours.');
    }

    if (requestParameters.instrument === null || requestParameters.instrument === undefined) {
        throw new runtime.RequiredError('instrument','Required parameter requestParameters.instrument was null or undefined when calling futuresV1HistoricalHours.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.market !== undefined) {
        queryParameters['market'] = requestParameters.market;
    }


    if (requestParameters.instrument !== undefined) {
        queryParameters['instrument'] = requestParameters.instrument;
    }


    if (requestParameters.groups) {
        queryParameters['groups'] = requestParameters.groups?.join(runtime.COLLECTION_FORMATS["csv"]);
    }


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.toTs !== undefined) {
        queryParameters['to_ts'] = requestParameters.toTs;
    }


    if (requestParameters.aggregate !== undefined) {
        queryParameters['aggregate'] = requestParameters.aggregate;
    }


    if (requestParameters.fill !== undefined) {
        queryParameters['fill'] = requestParameters.fill;
    }


    if (requestParameters.mappingPriority !== undefined) {
        queryParameters['mapping_priority'] = requestParameters.mappingPriority;
    }


    if (requestParameters.responseFormat !== undefined) {
        queryParameters['response_format'] = requestParameters.responseFormat;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/futures/v1/historical/hours`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(GENERICRESPONSEFromJSON(body), text);
    }

    return config;
}

/**
*/
export function futuresV1HistoricalHours<T>(requestParameters: FuturesV1HistoricalHoursRequest, requestConfig?: runtime.TypedQueryConfig<T, GENERICRESPONSE>): QueryConfig<T> {
    return futuresV1HistoricalHoursRaw(requestParameters, requestConfig);
}

/**
 */
function futuresV1HistoricalMinutesRaw<T>(requestParameters: FuturesV1HistoricalMinutesRequest, requestConfig: runtime.TypedQueryConfig<T, GENERICRESPONSE> = {}): QueryConfig<T> {
    if (requestParameters.market === null || requestParameters.market === undefined) {
        throw new runtime.RequiredError('market','Required parameter requestParameters.market was null or undefined when calling futuresV1HistoricalMinutes.');
    }

    if (requestParameters.instrument === null || requestParameters.instrument === undefined) {
        throw new runtime.RequiredError('instrument','Required parameter requestParameters.instrument was null or undefined when calling futuresV1HistoricalMinutes.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.market !== undefined) {
        queryParameters['market'] = requestParameters.market;
    }


    if (requestParameters.instrument !== undefined) {
        queryParameters['instrument'] = requestParameters.instrument;
    }


    if (requestParameters.groups) {
        queryParameters['groups'] = requestParameters.groups?.join(runtime.COLLECTION_FORMATS["csv"]);
    }


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.toTs !== undefined) {
        queryParameters['to_ts'] = requestParameters.toTs;
    }


    if (requestParameters.aggregate !== undefined) {
        queryParameters['aggregate'] = requestParameters.aggregate;
    }


    if (requestParameters.fill !== undefined) {
        queryParameters['fill'] = requestParameters.fill;
    }


    if (requestParameters.mappingPriority !== undefined) {
        queryParameters['mapping_priority'] = requestParameters.mappingPriority;
    }


    if (requestParameters.responseFormat !== undefined) {
        queryParameters['response_format'] = requestParameters.responseFormat;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/futures/v1/historical/minutes`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(GENERICRESPONSEFromJSON(body), text);
    }

    return config;
}

/**
*/
export function futuresV1HistoricalMinutes<T>(requestParameters: FuturesV1HistoricalMinutesRequest, requestConfig?: runtime.TypedQueryConfig<T, GENERICRESPONSE>): QueryConfig<T> {
    return futuresV1HistoricalMinutesRaw(requestParameters, requestConfig);
}

/**
 */
function futuresV1HistoricalOpenInterestDaysRaw<T>(requestParameters: FuturesV1HistoricalOpenInterestDaysRequest, requestConfig: runtime.TypedQueryConfig<T, GENERICRESPONSE> = {}): QueryConfig<T> {
    if (requestParameters.market === null || requestParameters.market === undefined) {
        throw new runtime.RequiredError('market','Required parameter requestParameters.market was null or undefined when calling futuresV1HistoricalOpenInterestDays.');
    }

    if (requestParameters.instrument === null || requestParameters.instrument === undefined) {
        throw new runtime.RequiredError('instrument','Required parameter requestParameters.instrument was null or undefined when calling futuresV1HistoricalOpenInterestDays.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.market !== undefined) {
        queryParameters['market'] = requestParameters.market;
    }


    if (requestParameters.instrument !== undefined) {
        queryParameters['instrument'] = requestParameters.instrument;
    }


    if (requestParameters.groups) {
        queryParameters['groups'] = requestParameters.groups?.join(runtime.COLLECTION_FORMATS["csv"]);
    }


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.toTs !== undefined) {
        queryParameters['to_ts'] = requestParameters.toTs;
    }


    if (requestParameters.aggregate !== undefined) {
        queryParameters['aggregate'] = requestParameters.aggregate;
    }


    if (requestParameters.fill !== undefined) {
        queryParameters['fill'] = requestParameters.fill;
    }


    if (requestParameters.mappingPriority !== undefined) {
        queryParameters['mapping_priority'] = requestParameters.mappingPriority;
    }


    if (requestParameters.responseFormat !== undefined) {
        queryParameters['response_format'] = requestParameters.responseFormat;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/futures/v1/historical/open-interest/days`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(GENERICRESPONSEFromJSON(body), text);
    }

    return config;
}

/**
*/
export function futuresV1HistoricalOpenInterestDays<T>(requestParameters: FuturesV1HistoricalOpenInterestDaysRequest, requestConfig?: runtime.TypedQueryConfig<T, GENERICRESPONSE>): QueryConfig<T> {
    return futuresV1HistoricalOpenInterestDaysRaw(requestParameters, requestConfig);
}

/**
 */
function futuresV1HistoricalOpenInterestHoursRaw<T>(requestParameters: FuturesV1HistoricalOpenInterestHoursRequest, requestConfig: runtime.TypedQueryConfig<T, GENERICRESPONSE> = {}): QueryConfig<T> {
    if (requestParameters.market === null || requestParameters.market === undefined) {
        throw new runtime.RequiredError('market','Required parameter requestParameters.market was null or undefined when calling futuresV1HistoricalOpenInterestHours.');
    }

    if (requestParameters.instrument === null || requestParameters.instrument === undefined) {
        throw new runtime.RequiredError('instrument','Required parameter requestParameters.instrument was null or undefined when calling futuresV1HistoricalOpenInterestHours.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.market !== undefined) {
        queryParameters['market'] = requestParameters.market;
    }


    if (requestParameters.instrument !== undefined) {
        queryParameters['instrument'] = requestParameters.instrument;
    }


    if (requestParameters.groups) {
        queryParameters['groups'] = requestParameters.groups?.join(runtime.COLLECTION_FORMATS["csv"]);
    }


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.toTs !== undefined) {
        queryParameters['to_ts'] = requestParameters.toTs;
    }


    if (requestParameters.aggregate !== undefined) {
        queryParameters['aggregate'] = requestParameters.aggregate;
    }


    if (requestParameters.fill !== undefined) {
        queryParameters['fill'] = requestParameters.fill;
    }


    if (requestParameters.mappingPriority !== undefined) {
        queryParameters['mapping_priority'] = requestParameters.mappingPriority;
    }


    if (requestParameters.responseFormat !== undefined) {
        queryParameters['response_format'] = requestParameters.responseFormat;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/futures/v1/historical/open-interest/hours`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(GENERICRESPONSEFromJSON(body), text);
    }

    return config;
}

/**
*/
export function futuresV1HistoricalOpenInterestHours<T>(requestParameters: FuturesV1HistoricalOpenInterestHoursRequest, requestConfig?: runtime.TypedQueryConfig<T, GENERICRESPONSE>): QueryConfig<T> {
    return futuresV1HistoricalOpenInterestHoursRaw(requestParameters, requestConfig);
}

/**
 */
function futuresV1HistoricalOpenInterestMessagesRaw<T>(requestParameters: FuturesV1HistoricalOpenInterestMessagesRequest, requestConfig: runtime.TypedQueryConfig<T, GENERICRESPONSE> = {}): QueryConfig<T> {
    if (requestParameters.market === null || requestParameters.market === undefined) {
        throw new runtime.RequiredError('market','Required parameter requestParameters.market was null or undefined when calling futuresV1HistoricalOpenInterestMessages.');
    }

    if (requestParameters.instrument === null || requestParameters.instrument === undefined) {
        throw new runtime.RequiredError('instrument','Required parameter requestParameters.instrument was null or undefined when calling futuresV1HistoricalOpenInterestMessages.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.market !== undefined) {
        queryParameters['market'] = requestParameters.market;
    }


    if (requestParameters.instrument !== undefined) {
        queryParameters['instrument'] = requestParameters.instrument;
    }


    if (requestParameters.afterTs !== undefined) {
        queryParameters['after_ts'] = requestParameters.afterTs;
    }


    if (requestParameters.lastCcseq !== undefined) {
        queryParameters['last_ccseq'] = requestParameters.lastCcseq;
    }


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.mappingPriority !== undefined) {
        queryParameters['mapping_priority'] = requestParameters.mappingPriority;
    }


    if (requestParameters.responseFormat !== undefined) {
        queryParameters['response_format'] = requestParameters.responseFormat;
    }


    if (requestParameters.return404OnEmptyResponse !== undefined) {
        queryParameters['return_404_on_empty_response'] = requestParameters.return404OnEmptyResponse;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['api_key', 'header'];
    meta.authType = ['api_key', 'query'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/futures/v1/historical/open-interest-messages`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(GENERICRESPONSEFromJSON(body), text);
    }

    return config;
}

/**
*/
export function futuresV1HistoricalOpenInterestMessages<T>(requestParameters: FuturesV1HistoricalOpenInterestMessagesRequest, requestConfig?: runtime.TypedQueryConfig<T, GENERICRESPONSE>): QueryConfig<T> {
    return futuresV1HistoricalOpenInterestMessagesRaw(requestParameters, requestConfig);
}

/**
 */
function futuresV1HistoricalOpenInterestMessagesHourRaw<T>(requestParameters: FuturesV1HistoricalOpenInterestMessagesHourRequest, requestConfig: runtime.TypedQueryConfig<T, GENERICRESPONSE> = {}): QueryConfig<T> {
    if (requestParameters.market === null || requestParameters.market === undefined) {
        throw new runtime.RequiredError('market','Required parameter requestParameters.market was null or undefined when calling futuresV1HistoricalOpenInterestMessagesHour.');
    }

    if (requestParameters.instrument === null || requestParameters.instrument === undefined) {
        throw new runtime.RequiredError('instrument','Required parameter requestParameters.instrument was null or undefined when calling futuresV1HistoricalOpenInterestMessagesHour.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.market !== undefined) {
        queryParameters['market'] = requestParameters.market;
    }


    if (requestParameters.instrument !== undefined) {
        queryParameters['instrument'] = requestParameters.instrument;
    }


    if (requestParameters.hourTs !== undefined) {
        queryParameters['hour_ts'] = requestParameters.hourTs;
    }


    if (requestParameters.mappingPriority !== undefined) {
        queryParameters['mapping_priority'] = requestParameters.mappingPriority;
    }


    if (requestParameters.responseFormat !== undefined) {
        queryParameters['response_format'] = requestParameters.responseFormat;
    }


    if (requestParameters.return404OnEmptyResponse !== undefined) {
        queryParameters['return_404_on_empty_response'] = requestParameters.return404OnEmptyResponse;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['api_key', 'header'];
    meta.authType = ['api_key', 'query'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/futures/v1/historical/open-interest-messages/hour`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(GENERICRESPONSEFromJSON(body), text);
    }

    return config;
}

/**
*/
export function futuresV1HistoricalOpenInterestMessagesHour<T>(requestParameters: FuturesV1HistoricalOpenInterestMessagesHourRequest, requestConfig?: runtime.TypedQueryConfig<T, GENERICRESPONSE>): QueryConfig<T> {
    return futuresV1HistoricalOpenInterestMessagesHourRaw(requestParameters, requestConfig);
}

/**
 */
function futuresV1HistoricalOpenInterestMinutesRaw<T>(requestParameters: FuturesV1HistoricalOpenInterestMinutesRequest, requestConfig: runtime.TypedQueryConfig<T, GENERICRESPONSE> = {}): QueryConfig<T> {
    if (requestParameters.market === null || requestParameters.market === undefined) {
        throw new runtime.RequiredError('market','Required parameter requestParameters.market was null or undefined when calling futuresV1HistoricalOpenInterestMinutes.');
    }

    if (requestParameters.instrument === null || requestParameters.instrument === undefined) {
        throw new runtime.RequiredError('instrument','Required parameter requestParameters.instrument was null or undefined when calling futuresV1HistoricalOpenInterestMinutes.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.market !== undefined) {
        queryParameters['market'] = requestParameters.market;
    }


    if (requestParameters.instrument !== undefined) {
        queryParameters['instrument'] = requestParameters.instrument;
    }


    if (requestParameters.groups) {
        queryParameters['groups'] = requestParameters.groups?.join(runtime.COLLECTION_FORMATS["csv"]);
    }


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.toTs !== undefined) {
        queryParameters['to_ts'] = requestParameters.toTs;
    }


    if (requestParameters.aggregate !== undefined) {
        queryParameters['aggregate'] = requestParameters.aggregate;
    }


    if (requestParameters.fill !== undefined) {
        queryParameters['fill'] = requestParameters.fill;
    }


    if (requestParameters.mappingPriority !== undefined) {
        queryParameters['mapping_priority'] = requestParameters.mappingPriority;
    }


    if (requestParameters.responseFormat !== undefined) {
        queryParameters['response_format'] = requestParameters.responseFormat;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/futures/v1/historical/open-interest/minutes`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(GENERICRESPONSEFromJSON(body), text);
    }

    return config;
}

/**
*/
export function futuresV1HistoricalOpenInterestMinutes<T>(requestParameters: FuturesV1HistoricalOpenInterestMinutesRequest, requestConfig?: runtime.TypedQueryConfig<T, GENERICRESPONSE>): QueryConfig<T> {
    return futuresV1HistoricalOpenInterestMinutesRaw(requestParameters, requestConfig);
}

/**
 */
function futuresV1HistoricalTradesRaw<T>(requestParameters: FuturesV1HistoricalTradesRequest, requestConfig: runtime.TypedQueryConfig<T, GENERICRESPONSE> = {}): QueryConfig<T> {
    if (requestParameters.market === null || requestParameters.market === undefined) {
        throw new runtime.RequiredError('market','Required parameter requestParameters.market was null or undefined when calling futuresV1HistoricalTrades.');
    }

    if (requestParameters.instrument === null || requestParameters.instrument === undefined) {
        throw new runtime.RequiredError('instrument','Required parameter requestParameters.instrument was null or undefined when calling futuresV1HistoricalTrades.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.market !== undefined) {
        queryParameters['market'] = requestParameters.market;
    }


    if (requestParameters.instrument !== undefined) {
        queryParameters['instrument'] = requestParameters.instrument;
    }


    if (requestParameters.afterTs !== undefined) {
        queryParameters['after_ts'] = requestParameters.afterTs;
    }


    if (requestParameters.lastCcseq !== undefined) {
        queryParameters['last_ccseq'] = requestParameters.lastCcseq;
    }


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.mappingPriority !== undefined) {
        queryParameters['mapping_priority'] = requestParameters.mappingPriority;
    }


    if (requestParameters.responseFormat !== undefined) {
        queryParameters['response_format'] = requestParameters.responseFormat;
    }


    if (requestParameters.return404OnEmptyResponse !== undefined) {
        queryParameters['return_404_on_empty_response'] = requestParameters.return404OnEmptyResponse;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['api_key', 'header'];
    meta.authType = ['api_key', 'query'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/futures/v1/historical/trades`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(GENERICRESPONSEFromJSON(body), text);
    }

    return config;
}

/**
*/
export function futuresV1HistoricalTrades<T>(requestParameters: FuturesV1HistoricalTradesRequest, requestConfig?: runtime.TypedQueryConfig<T, GENERICRESPONSE>): QueryConfig<T> {
    return futuresV1HistoricalTradesRaw(requestParameters, requestConfig);
}

/**
 */
function futuresV1HistoricalTradesHourRaw<T>(requestParameters: FuturesV1HistoricalTradesHourRequest, requestConfig: runtime.TypedQueryConfig<T, GENERICRESPONSE> = {}): QueryConfig<T> {
    if (requestParameters.market === null || requestParameters.market === undefined) {
        throw new runtime.RequiredError('market','Required parameter requestParameters.market was null or undefined when calling futuresV1HistoricalTradesHour.');
    }

    if (requestParameters.instrument === null || requestParameters.instrument === undefined) {
        throw new runtime.RequiredError('instrument','Required parameter requestParameters.instrument was null or undefined when calling futuresV1HistoricalTradesHour.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.market !== undefined) {
        queryParameters['market'] = requestParameters.market;
    }


    if (requestParameters.instrument !== undefined) {
        queryParameters['instrument'] = requestParameters.instrument;
    }


    if (requestParameters.hourTs !== undefined) {
        queryParameters['hour_ts'] = requestParameters.hourTs;
    }


    if (requestParameters.mappingPriority !== undefined) {
        queryParameters['mapping_priority'] = requestParameters.mappingPriority;
    }


    if (requestParameters.responseFormat !== undefined) {
        queryParameters['response_format'] = requestParameters.responseFormat;
    }


    if (requestParameters.return404OnEmptyResponse !== undefined) {
        queryParameters['return_404_on_empty_response'] = requestParameters.return404OnEmptyResponse;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['api_key', 'header'];
    meta.authType = ['api_key', 'query'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/futures/v1/historical/trades/hour`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(GENERICRESPONSEFromJSON(body), text);
    }

    return config;
}

/**
*/
export function futuresV1HistoricalTradesHour<T>(requestParameters: FuturesV1HistoricalTradesHourRequest, requestConfig?: runtime.TypedQueryConfig<T, GENERICRESPONSE>): QueryConfig<T> {
    return futuresV1HistoricalTradesHourRaw(requestParameters, requestConfig);
}

/**
 */
function futuresV1LatestFundingRateTickRaw<T>(requestParameters: FuturesV1LatestFundingRateTickRequest, requestConfig: runtime.TypedQueryConfig<T, GENERICRESPONSE> = {}): QueryConfig<T> {
    if (requestParameters.market === null || requestParameters.market === undefined) {
        throw new runtime.RequiredError('market','Required parameter requestParameters.market was null or undefined when calling futuresV1LatestFundingRateTick.');
    }

    if (requestParameters.instruments === null || requestParameters.instruments === undefined) {
        throw new runtime.RequiredError('instruments','Required parameter requestParameters.instruments was null or undefined when calling futuresV1LatestFundingRateTick.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.market !== undefined) {
        queryParameters['market'] = requestParameters.market;
    }


    if (requestParameters.instruments) {
        queryParameters['instruments'] = requestParameters.instruments?.join(runtime.COLLECTION_FORMATS["csv"]);
    }


    if (requestParameters.groups) {
        queryParameters['groups'] = requestParameters.groups?.join(runtime.COLLECTION_FORMATS["csv"]);
    }


    if (requestParameters.mappingPriority !== undefined) {
        queryParameters['mapping_priority'] = requestParameters.mappingPriority;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/futures/v1/latest/funding-rate/tick`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(GENERICRESPONSEFromJSON(body), text);
    }

    return config;
}

/**
*/
export function futuresV1LatestFundingRateTick<T>(requestParameters: FuturesV1LatestFundingRateTickRequest, requestConfig?: runtime.TypedQueryConfig<T, GENERICRESPONSE>): QueryConfig<T> {
    return futuresV1LatestFundingRateTickRaw(requestParameters, requestConfig);
}

/**
 */
function futuresV1LatestInstrumentMetadataRaw<T>(requestParameters: FuturesV1LatestInstrumentMetadataRequest, requestConfig: runtime.TypedQueryConfig<T, GENERICRESPONSE> = {}): QueryConfig<T> {
    if (requestParameters.market === null || requestParameters.market === undefined) {
        throw new runtime.RequiredError('market','Required parameter requestParameters.market was null or undefined when calling futuresV1LatestInstrumentMetadata.');
    }

    if (requestParameters.instruments === null || requestParameters.instruments === undefined) {
        throw new runtime.RequiredError('instruments','Required parameter requestParameters.instruments was null or undefined when calling futuresV1LatestInstrumentMetadata.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.market !== undefined) {
        queryParameters['market'] = requestParameters.market;
    }


    if (requestParameters.instruments) {
        queryParameters['instruments'] = requestParameters.instruments?.join(runtime.COLLECTION_FORMATS["csv"]);
    }


    if (requestParameters.groups) {
        queryParameters['groups'] = requestParameters.groups?.join(runtime.COLLECTION_FORMATS["csv"]);
    }


    if (requestParameters.mappingPriority !== undefined) {
        queryParameters['mapping_priority'] = requestParameters.mappingPriority;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/futures/v1/latest/instrument/metadata`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(GENERICRESPONSEFromJSON(body), text);
    }

    return config;
}

/**
*/
export function futuresV1LatestInstrumentMetadata<T>(requestParameters: FuturesV1LatestInstrumentMetadataRequest, requestConfig?: runtime.TypedQueryConfig<T, GENERICRESPONSE>): QueryConfig<T> {
    return futuresV1LatestInstrumentMetadataRaw(requestParameters, requestConfig);
}

/**
 */
function futuresV1LatestOpenInterestTickRaw<T>(requestParameters: FuturesV1LatestOpenInterestTickRequest, requestConfig: runtime.TypedQueryConfig<T, GENERICRESPONSE> = {}): QueryConfig<T> {
    if (requestParameters.market === null || requestParameters.market === undefined) {
        throw new runtime.RequiredError('market','Required parameter requestParameters.market was null or undefined when calling futuresV1LatestOpenInterestTick.');
    }

    if (requestParameters.instruments === null || requestParameters.instruments === undefined) {
        throw new runtime.RequiredError('instruments','Required parameter requestParameters.instruments was null or undefined when calling futuresV1LatestOpenInterestTick.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.market !== undefined) {
        queryParameters['market'] = requestParameters.market;
    }


    if (requestParameters.instruments) {
        queryParameters['instruments'] = requestParameters.instruments?.join(runtime.COLLECTION_FORMATS["csv"]);
    }


    if (requestParameters.groups) {
        queryParameters['groups'] = requestParameters.groups?.join(runtime.COLLECTION_FORMATS["csv"]);
    }


    if (requestParameters.mappingPriority !== undefined) {
        queryParameters['mapping_priority'] = requestParameters.mappingPriority;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/futures/v1/latest/open-interest/tick`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(GENERICRESPONSEFromJSON(body), text);
    }

    return config;
}

/**
*/
export function futuresV1LatestOpenInterestTick<T>(requestParameters: FuturesV1LatestOpenInterestTickRequest, requestConfig?: runtime.TypedQueryConfig<T, GENERICRESPONSE>): QueryConfig<T> {
    return futuresV1LatestOpenInterestTickRaw(requestParameters, requestConfig);
}

/**
 */
function futuresV1LatestTickRaw<T>(requestParameters: FuturesV1LatestTickRequest, requestConfig: runtime.TypedQueryConfig<T, GENERICRESPONSE> = {}): QueryConfig<T> {
    if (requestParameters.market === null || requestParameters.market === undefined) {
        throw new runtime.RequiredError('market','Required parameter requestParameters.market was null or undefined when calling futuresV1LatestTick.');
    }

    if (requestParameters.instruments === null || requestParameters.instruments === undefined) {
        throw new runtime.RequiredError('instruments','Required parameter requestParameters.instruments was null or undefined when calling futuresV1LatestTick.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.market !== undefined) {
        queryParameters['market'] = requestParameters.market;
    }


    if (requestParameters.instruments) {
        queryParameters['instruments'] = requestParameters.instruments?.join(runtime.COLLECTION_FORMATS["csv"]);
    }


    if (requestParameters.groups) {
        queryParameters['groups'] = requestParameters.groups?.join(runtime.COLLECTION_FORMATS["csv"]);
    }


    if (requestParameters.mappingPriority !== undefined) {
        queryParameters['mapping_priority'] = requestParameters.mappingPriority;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/futures/v1/latest/tick`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(GENERICRESPONSEFromJSON(body), text);
    }

    return config;
}

/**
*/
export function futuresV1LatestTick<T>(requestParameters: FuturesV1LatestTickRequest, requestConfig?: runtime.TypedQueryConfig<T, GENERICRESPONSE>): QueryConfig<T> {
    return futuresV1LatestTickRaw(requestParameters, requestConfig);
}

/**
 */
function futuresV1MarketsRaw<T>(requestParameters: FuturesV1MarketsRequest, requestConfig: runtime.TypedQueryConfig<T, GENERICRESPONSE> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.market !== undefined) {
        queryParameters['market'] = requestParameters.market;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/futures/v1/markets`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(GENERICRESPONSEFromJSON(body), text);
    }

    return config;
}

/**
*/
export function futuresV1Markets<T>(requestParameters: FuturesV1MarketsRequest, requestConfig?: runtime.TypedQueryConfig<T, GENERICRESPONSE>): QueryConfig<T> {
    return futuresV1MarketsRaw(requestParameters, requestConfig);
}

/**
 */
function futuresV1MarketsInstrumentsRaw<T>(requestParameters: FuturesV1MarketsInstrumentsRequest, requestConfig: runtime.TypedQueryConfig<T, GENERICRESPONSE> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.market !== undefined) {
        queryParameters['market'] = requestParameters.market;
    }


    if (requestParameters.instrument !== undefined) {
        queryParameters['instrument'] = requestParameters.instrument;
    }


    if (requestParameters.instrumentStatus) {
        queryParameters['instrument_status'] = requestParameters.instrumentStatus?.join(runtime.COLLECTION_FORMATS["csv"]);
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/futures/v1/markets/instruments`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(GENERICRESPONSEFromJSON(body), text);
    }

    return config;
}

/**
*/
export function futuresV1MarketsInstruments<T>(requestParameters: FuturesV1MarketsInstrumentsRequest, requestConfig?: runtime.TypedQueryConfig<T, GENERICRESPONSE>): QueryConfig<T> {
    return futuresV1MarketsInstrumentsRaw(requestParameters, requestConfig);
}

/**
 */
function futuresV1MarketsInstrumentsUnmappedRaw<T>(requestParameters: FuturesV1MarketsInstrumentsUnmappedRequest, requestConfig: runtime.TypedQueryConfig<T, GENERICRESPONSE> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.market !== undefined) {
        queryParameters['market'] = requestParameters.market;
    }


    if (requestParameters.instrument !== undefined) {
        queryParameters['instrument'] = requestParameters.instrument;
    }


    if (requestParameters.instrumentStatus) {
        queryParameters['instrument_status'] = requestParameters.instrumentStatus?.join(runtime.COLLECTION_FORMATS["csv"]);
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/futures/v1/markets/instruments/unmapped`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(GENERICRESPONSEFromJSON(body), text);
    }

    return config;
}

/**
*/
export function futuresV1MarketsInstrumentsUnmapped<T>(requestParameters: FuturesV1MarketsInstrumentsUnmappedRequest, requestConfig?: runtime.TypedQueryConfig<T, GENERICRESPONSE>): QueryConfig<T> {
    return futuresV1MarketsInstrumentsUnmappedRaw(requestParameters, requestConfig);
}

/**
 */
function indexV1HistoricalDaysRaw<T>(requestParameters: IndexV1HistoricalDaysRequest, requestConfig: runtime.TypedQueryConfig<T, GENERICRESPONSE> = {}): QueryConfig<T> {
    if (requestParameters.market === null || requestParameters.market === undefined) {
        throw new runtime.RequiredError('market','Required parameter requestParameters.market was null or undefined when calling indexV1HistoricalDays.');
    }

    if (requestParameters.instrument === null || requestParameters.instrument === undefined) {
        throw new runtime.RequiredError('instrument','Required parameter requestParameters.instrument was null or undefined when calling indexV1HistoricalDays.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.market !== undefined) {
        queryParameters['market'] = requestParameters.market;
    }


    if (requestParameters.instrument !== undefined) {
        queryParameters['instrument'] = requestParameters.instrument;
    }


    if (requestParameters.groups) {
        queryParameters['groups'] = requestParameters.groups?.join(runtime.COLLECTION_FORMATS["csv"]);
    }


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.toTs !== undefined) {
        queryParameters['to_ts'] = requestParameters.toTs;
    }


    if (requestParameters.aggregate !== undefined) {
        queryParameters['aggregate'] = requestParameters.aggregate;
    }


    if (requestParameters.fill !== undefined) {
        queryParameters['fill'] = requestParameters.fill;
    }


    if (requestParameters.mappingPriority !== undefined) {
        queryParameters['mapping_priority'] = requestParameters.mappingPriority;
    }


    if (requestParameters.responseFormat !== undefined) {
        queryParameters['response_format'] = requestParameters.responseFormat;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/index/v1/historical/days`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(GENERICRESPONSEFromJSON(body), text);
    }

    return config;
}

/**
*/
export function indexV1HistoricalDays<T>(requestParameters: IndexV1HistoricalDaysRequest, requestConfig?: runtime.TypedQueryConfig<T, GENERICRESPONSE>): QueryConfig<T> {
    return indexV1HistoricalDaysRaw(requestParameters, requestConfig);
}

/**
 */
function indexV1HistoricalHoursRaw<T>(requestParameters: IndexV1HistoricalHoursRequest, requestConfig: runtime.TypedQueryConfig<T, GENERICRESPONSE> = {}): QueryConfig<T> {
    if (requestParameters.market === null || requestParameters.market === undefined) {
        throw new runtime.RequiredError('market','Required parameter requestParameters.market was null or undefined when calling indexV1HistoricalHours.');
    }

    if (requestParameters.instrument === null || requestParameters.instrument === undefined) {
        throw new runtime.RequiredError('instrument','Required parameter requestParameters.instrument was null or undefined when calling indexV1HistoricalHours.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.market !== undefined) {
        queryParameters['market'] = requestParameters.market;
    }


    if (requestParameters.instrument !== undefined) {
        queryParameters['instrument'] = requestParameters.instrument;
    }


    if (requestParameters.groups) {
        queryParameters['groups'] = requestParameters.groups?.join(runtime.COLLECTION_FORMATS["csv"]);
    }


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.toTs !== undefined) {
        queryParameters['to_ts'] = requestParameters.toTs;
    }


    if (requestParameters.aggregate !== undefined) {
        queryParameters['aggregate'] = requestParameters.aggregate;
    }


    if (requestParameters.fill !== undefined) {
        queryParameters['fill'] = requestParameters.fill;
    }


    if (requestParameters.mappingPriority !== undefined) {
        queryParameters['mapping_priority'] = requestParameters.mappingPriority;
    }


    if (requestParameters.responseFormat !== undefined) {
        queryParameters['response_format'] = requestParameters.responseFormat;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/index/v1/historical/hours`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(GENERICRESPONSEFromJSON(body), text);
    }

    return config;
}

/**
*/
export function indexV1HistoricalHours<T>(requestParameters: IndexV1HistoricalHoursRequest, requestConfig?: runtime.TypedQueryConfig<T, GENERICRESPONSE>): QueryConfig<T> {
    return indexV1HistoricalHoursRaw(requestParameters, requestConfig);
}

/**
 */
function indexV1HistoricalMessagesRaw<T>(requestParameters: IndexV1HistoricalMessagesRequest, requestConfig: runtime.TypedQueryConfig<T, GENERICRESPONSE> = {}): QueryConfig<T> {
    if (requestParameters.market === null || requestParameters.market === undefined) {
        throw new runtime.RequiredError('market','Required parameter requestParameters.market was null or undefined when calling indexV1HistoricalMessages.');
    }

    if (requestParameters.instrument === null || requestParameters.instrument === undefined) {
        throw new runtime.RequiredError('instrument','Required parameter requestParameters.instrument was null or undefined when calling indexV1HistoricalMessages.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.market !== undefined) {
        queryParameters['market'] = requestParameters.market;
    }


    if (requestParameters.instrument !== undefined) {
        queryParameters['instrument'] = requestParameters.instrument;
    }


    if (requestParameters.afterTs !== undefined) {
        queryParameters['after_ts'] = requestParameters.afterTs;
    }


    if (requestParameters.lastCcseq !== undefined) {
        queryParameters['last_ccseq'] = requestParameters.lastCcseq;
    }


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.mappingPriority !== undefined) {
        queryParameters['mapping_priority'] = requestParameters.mappingPriority;
    }


    if (requestParameters.responseFormat !== undefined) {
        queryParameters['response_format'] = requestParameters.responseFormat;
    }


    if (requestParameters.return404OnEmptyResponse !== undefined) {
        queryParameters['return_404_on_empty_response'] = requestParameters.return404OnEmptyResponse;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['api_key', 'header'];
    meta.authType = ['api_key', 'query'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/index/v1/historical/messages`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(GENERICRESPONSEFromJSON(body), text);
    }

    return config;
}

/**
*/
export function indexV1HistoricalMessages<T>(requestParameters: IndexV1HistoricalMessagesRequest, requestConfig?: runtime.TypedQueryConfig<T, GENERICRESPONSE>): QueryConfig<T> {
    return indexV1HistoricalMessagesRaw(requestParameters, requestConfig);
}

/**
 */
function indexV1HistoricalMessagesHourRaw<T>(requestParameters: IndexV1HistoricalMessagesHourRequest, requestConfig: runtime.TypedQueryConfig<T, GENERICRESPONSE> = {}): QueryConfig<T> {
    if (requestParameters.market === null || requestParameters.market === undefined) {
        throw new runtime.RequiredError('market','Required parameter requestParameters.market was null or undefined when calling indexV1HistoricalMessagesHour.');
    }

    if (requestParameters.instrument === null || requestParameters.instrument === undefined) {
        throw new runtime.RequiredError('instrument','Required parameter requestParameters.instrument was null or undefined when calling indexV1HistoricalMessagesHour.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.market !== undefined) {
        queryParameters['market'] = requestParameters.market;
    }


    if (requestParameters.instrument !== undefined) {
        queryParameters['instrument'] = requestParameters.instrument;
    }


    if (requestParameters.hourTs !== undefined) {
        queryParameters['hour_ts'] = requestParameters.hourTs;
    }


    if (requestParameters.mappingPriority !== undefined) {
        queryParameters['mapping_priority'] = requestParameters.mappingPriority;
    }


    if (requestParameters.responseFormat !== undefined) {
        queryParameters['response_format'] = requestParameters.responseFormat;
    }


    if (requestParameters.return404OnEmptyResponse !== undefined) {
        queryParameters['return_404_on_empty_response'] = requestParameters.return404OnEmptyResponse;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['api_key', 'header'];
    meta.authType = ['api_key', 'query'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/index/v1/historical/messages/hour`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(GENERICRESPONSEFromJSON(body), text);
    }

    return config;
}

/**
*/
export function indexV1HistoricalMessagesHour<T>(requestParameters: IndexV1HistoricalMessagesHourRequest, requestConfig?: runtime.TypedQueryConfig<T, GENERICRESPONSE>): QueryConfig<T> {
    return indexV1HistoricalMessagesHourRaw(requestParameters, requestConfig);
}

/**
 */
function indexV1HistoricalMinutesRaw<T>(requestParameters: IndexV1HistoricalMinutesRequest, requestConfig: runtime.TypedQueryConfig<T, GENERICRESPONSE> = {}): QueryConfig<T> {
    if (requestParameters.market === null || requestParameters.market === undefined) {
        throw new runtime.RequiredError('market','Required parameter requestParameters.market was null or undefined when calling indexV1HistoricalMinutes.');
    }

    if (requestParameters.instrument === null || requestParameters.instrument === undefined) {
        throw new runtime.RequiredError('instrument','Required parameter requestParameters.instrument was null or undefined when calling indexV1HistoricalMinutes.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.market !== undefined) {
        queryParameters['market'] = requestParameters.market;
    }


    if (requestParameters.instrument !== undefined) {
        queryParameters['instrument'] = requestParameters.instrument;
    }


    if (requestParameters.groups) {
        queryParameters['groups'] = requestParameters.groups?.join(runtime.COLLECTION_FORMATS["csv"]);
    }


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.toTs !== undefined) {
        queryParameters['to_ts'] = requestParameters.toTs;
    }


    if (requestParameters.aggregate !== undefined) {
        queryParameters['aggregate'] = requestParameters.aggregate;
    }


    if (requestParameters.fill !== undefined) {
        queryParameters['fill'] = requestParameters.fill;
    }


    if (requestParameters.mappingPriority !== undefined) {
        queryParameters['mapping_priority'] = requestParameters.mappingPriority;
    }


    if (requestParameters.responseFormat !== undefined) {
        queryParameters['response_format'] = requestParameters.responseFormat;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/index/v1/historical/minutes`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(GENERICRESPONSEFromJSON(body), text);
    }

    return config;
}

/**
*/
export function indexV1HistoricalMinutes<T>(requestParameters: IndexV1HistoricalMinutesRequest, requestConfig?: runtime.TypedQueryConfig<T, GENERICRESPONSE>): QueryConfig<T> {
    return indexV1HistoricalMinutesRaw(requestParameters, requestConfig);
}

/**
 */
function indexV1LatestInstrumentMetadataRaw<T>(requestParameters: IndexV1LatestInstrumentMetadataRequest, requestConfig: runtime.TypedQueryConfig<T, GENERICRESPONSE> = {}): QueryConfig<T> {
    if (requestParameters.market === null || requestParameters.market === undefined) {
        throw new runtime.RequiredError('market','Required parameter requestParameters.market was null or undefined when calling indexV1LatestInstrumentMetadata.');
    }

    if (requestParameters.instruments === null || requestParameters.instruments === undefined) {
        throw new runtime.RequiredError('instruments','Required parameter requestParameters.instruments was null or undefined when calling indexV1LatestInstrumentMetadata.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.market !== undefined) {
        queryParameters['market'] = requestParameters.market;
    }


    if (requestParameters.instruments) {
        queryParameters['instruments'] = requestParameters.instruments?.join(runtime.COLLECTION_FORMATS["csv"]);
    }


    if (requestParameters.groups) {
        queryParameters['groups'] = requestParameters.groups?.join(runtime.COLLECTION_FORMATS["csv"]);
    }


    if (requestParameters.mappingPriority !== undefined) {
        queryParameters['mapping_priority'] = requestParameters.mappingPriority;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/index/v1/latest/instrument/metadata`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(GENERICRESPONSEFromJSON(body), text);
    }

    return config;
}

/**
*/
export function indexV1LatestInstrumentMetadata<T>(requestParameters: IndexV1LatestInstrumentMetadataRequest, requestConfig?: runtime.TypedQueryConfig<T, GENERICRESPONSE>): QueryConfig<T> {
    return indexV1LatestInstrumentMetadataRaw(requestParameters, requestConfig);
}

/**
 */
function indexV1LatestTickRaw<T>(requestParameters: IndexV1LatestTickRequest, requestConfig: runtime.TypedQueryConfig<T, GENERICRESPONSE> = {}): QueryConfig<T> {
    if (requestParameters.market === null || requestParameters.market === undefined) {
        throw new runtime.RequiredError('market','Required parameter requestParameters.market was null or undefined when calling indexV1LatestTick.');
    }

    if (requestParameters.instruments === null || requestParameters.instruments === undefined) {
        throw new runtime.RequiredError('instruments','Required parameter requestParameters.instruments was null or undefined when calling indexV1LatestTick.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.market !== undefined) {
        queryParameters['market'] = requestParameters.market;
    }


    if (requestParameters.instruments) {
        queryParameters['instruments'] = requestParameters.instruments?.join(runtime.COLLECTION_FORMATS["csv"]);
    }


    if (requestParameters.groups) {
        queryParameters['groups'] = requestParameters.groups?.join(runtime.COLLECTION_FORMATS["csv"]);
    }


    if (requestParameters.mappingPriority !== undefined) {
        queryParameters['mapping_priority'] = requestParameters.mappingPriority;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/index/v1/latest/tick`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(GENERICRESPONSEFromJSON(body), text);
    }

    return config;
}

/**
*/
export function indexV1LatestTick<T>(requestParameters: IndexV1LatestTickRequest, requestConfig?: runtime.TypedQueryConfig<T, GENERICRESPONSE>): QueryConfig<T> {
    return indexV1LatestTickRaw(requestParameters, requestConfig);
}

/**
 */
function indexV1MarketsRaw<T>(requestParameters: IndexV1MarketsRequest, requestConfig: runtime.TypedQueryConfig<T, GENERICRESPONSE> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.market !== undefined) {
        queryParameters['market'] = requestParameters.market;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/index/v1/markets`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(GENERICRESPONSEFromJSON(body), text);
    }

    return config;
}

/**
*/
export function indexV1Markets<T>(requestParameters: IndexV1MarketsRequest, requestConfig?: runtime.TypedQueryConfig<T, GENERICRESPONSE>): QueryConfig<T> {
    return indexV1MarketsRaw(requestParameters, requestConfig);
}

/**
 */
function indexV1MarketsInstrumentsRaw<T>(requestParameters: IndexV1MarketsInstrumentsRequest, requestConfig: runtime.TypedQueryConfig<T, GENERICRESPONSE> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.market !== undefined) {
        queryParameters['market'] = requestParameters.market;
    }


    if (requestParameters.instrument !== undefined) {
        queryParameters['instrument'] = requestParameters.instrument;
    }


    if (requestParameters.instrumentStatus) {
        queryParameters['instrument_status'] = requestParameters.instrumentStatus?.join(runtime.COLLECTION_FORMATS["csv"]);
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/index/v1/markets/instruments`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(GENERICRESPONSEFromJSON(body), text);
    }

    return config;
}

/**
*/
export function indexV1MarketsInstruments<T>(requestParameters: IndexV1MarketsInstrumentsRequest, requestConfig?: runtime.TypedQueryConfig<T, GENERICRESPONSE>): QueryConfig<T> {
    return indexV1MarketsInstrumentsRaw(requestParameters, requestConfig);
}

/**
 */
function indexV1MarketsInstrumentsUnmappedRaw<T>(requestParameters: IndexV1MarketsInstrumentsUnmappedRequest, requestConfig: runtime.TypedQueryConfig<T, GENERICRESPONSE> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.market !== undefined) {
        queryParameters['market'] = requestParameters.market;
    }


    if (requestParameters.instrument !== undefined) {
        queryParameters['instrument'] = requestParameters.instrument;
    }


    if (requestParameters.instrumentStatus) {
        queryParameters['instrument_status'] = requestParameters.instrumentStatus?.join(runtime.COLLECTION_FORMATS["csv"]);
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/index/v1/markets/instruments/unmapped`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(GENERICRESPONSEFromJSON(body), text);
    }

    return config;
}

/**
*/
export function indexV1MarketsInstrumentsUnmapped<T>(requestParameters: IndexV1MarketsInstrumentsUnmappedRequest, requestConfig?: runtime.TypedQueryConfig<T, GENERICRESPONSE>): QueryConfig<T> {
    return indexV1MarketsInstrumentsUnmappedRaw(requestParameters, requestConfig);
}


/**
    * @export
    * @enum {string}
    */
export enum FuturesV1HistoricalDaysMappingPriorityEnum {
    MappedFirst = 'CHECK_MAPPED_FIRST',
    UnmappedFirst = 'CHECK_UNMAPPED_FIRST'
}
/**
    * @export
    * @enum {string}
    */
export enum FuturesV1HistoricalDaysResponseFormatEnum {
    Json = 'JSON',
    Csv = 'CSV'
}
/**
    * @export
    * @enum {string}
    */
export enum FuturesV1HistoricalFundingRateDaysMappingPriorityEnum {
    MappedFirst = 'CHECK_MAPPED_FIRST',
    UnmappedFirst = 'CHECK_UNMAPPED_FIRST'
}
/**
    * @export
    * @enum {string}
    */
export enum FuturesV1HistoricalFundingRateDaysResponseFormatEnum {
    Json = 'JSON',
    Csv = 'CSV'
}
/**
    * @export
    * @enum {string}
    */
export enum FuturesV1HistoricalFundingRateHoursMappingPriorityEnum {
    MappedFirst = 'CHECK_MAPPED_FIRST',
    UnmappedFirst = 'CHECK_UNMAPPED_FIRST'
}
/**
    * @export
    * @enum {string}
    */
export enum FuturesV1HistoricalFundingRateHoursResponseFormatEnum {
    Json = 'JSON',
    Csv = 'CSV'
}
/**
    * @export
    * @enum {string}
    */
export enum FuturesV1HistoricalFundingRateMessagesMappingPriorityEnum {
    MappedFirst = 'CHECK_MAPPED_FIRST',
    UnmappedFirst = 'CHECK_UNMAPPED_FIRST'
}
/**
    * @export
    * @enum {string}
    */
export enum FuturesV1HistoricalFundingRateMessagesResponseFormatEnum {
    Json = 'JSON',
    Csv = 'CSV'
}
/**
    * @export
    * @enum {string}
    */
export enum FuturesV1HistoricalFundingRateMessagesHourMappingPriorityEnum {
    MappedFirst = 'CHECK_MAPPED_FIRST',
    UnmappedFirst = 'CHECK_UNMAPPED_FIRST'
}
/**
    * @export
    * @enum {string}
    */
export enum FuturesV1HistoricalFundingRateMessagesHourResponseFormatEnum {
    Json = 'JSON',
    Csv = 'CSV'
}
/**
    * @export
    * @enum {string}
    */
export enum FuturesV1HistoricalFundingRateMinutesMappingPriorityEnum {
    MappedFirst = 'CHECK_MAPPED_FIRST',
    UnmappedFirst = 'CHECK_UNMAPPED_FIRST'
}
/**
    * @export
    * @enum {string}
    */
export enum FuturesV1HistoricalFundingRateMinutesResponseFormatEnum {
    Json = 'JSON',
    Csv = 'CSV'
}
/**
    * @export
    * @enum {string}
    */
export enum FuturesV1HistoricalHoursMappingPriorityEnum {
    MappedFirst = 'CHECK_MAPPED_FIRST',
    UnmappedFirst = 'CHECK_UNMAPPED_FIRST'
}
/**
    * @export
    * @enum {string}
    */
export enum FuturesV1HistoricalHoursResponseFormatEnum {
    Json = 'JSON',
    Csv = 'CSV'
}
/**
    * @export
    * @enum {string}
    */
export enum FuturesV1HistoricalMinutesMappingPriorityEnum {
    MappedFirst = 'CHECK_MAPPED_FIRST',
    UnmappedFirst = 'CHECK_UNMAPPED_FIRST'
}
/**
    * @export
    * @enum {string}
    */
export enum FuturesV1HistoricalMinutesResponseFormatEnum {
    Json = 'JSON',
    Csv = 'CSV'
}
/**
    * @export
    * @enum {string}
    */
export enum FuturesV1HistoricalOpenInterestDaysMappingPriorityEnum {
    MappedFirst = 'CHECK_MAPPED_FIRST',
    UnmappedFirst = 'CHECK_UNMAPPED_FIRST'
}
/**
    * @export
    * @enum {string}
    */
export enum FuturesV1HistoricalOpenInterestDaysResponseFormatEnum {
    Json = 'JSON',
    Csv = 'CSV'
}
/**
    * @export
    * @enum {string}
    */
export enum FuturesV1HistoricalOpenInterestHoursMappingPriorityEnum {
    MappedFirst = 'CHECK_MAPPED_FIRST',
    UnmappedFirst = 'CHECK_UNMAPPED_FIRST'
}
/**
    * @export
    * @enum {string}
    */
export enum FuturesV1HistoricalOpenInterestHoursResponseFormatEnum {
    Json = 'JSON',
    Csv = 'CSV'
}
/**
    * @export
    * @enum {string}
    */
export enum FuturesV1HistoricalOpenInterestMessagesMappingPriorityEnum {
    MappedFirst = 'CHECK_MAPPED_FIRST',
    UnmappedFirst = 'CHECK_UNMAPPED_FIRST'
}
/**
    * @export
    * @enum {string}
    */
export enum FuturesV1HistoricalOpenInterestMessagesResponseFormatEnum {
    Json = 'JSON',
    Csv = 'CSV'
}
/**
    * @export
    * @enum {string}
    */
export enum FuturesV1HistoricalOpenInterestMessagesHourMappingPriorityEnum {
    MappedFirst = 'CHECK_MAPPED_FIRST',
    UnmappedFirst = 'CHECK_UNMAPPED_FIRST'
}
/**
    * @export
    * @enum {string}
    */
export enum FuturesV1HistoricalOpenInterestMessagesHourResponseFormatEnum {
    Json = 'JSON',
    Csv = 'CSV'
}
/**
    * @export
    * @enum {string}
    */
export enum FuturesV1HistoricalOpenInterestMinutesMappingPriorityEnum {
    MappedFirst = 'CHECK_MAPPED_FIRST',
    UnmappedFirst = 'CHECK_UNMAPPED_FIRST'
}
/**
    * @export
    * @enum {string}
    */
export enum FuturesV1HistoricalOpenInterestMinutesResponseFormatEnum {
    Json = 'JSON',
    Csv = 'CSV'
}
/**
    * @export
    * @enum {string}
    */
export enum FuturesV1HistoricalTradesMappingPriorityEnum {
    MappedFirst = 'CHECK_MAPPED_FIRST',
    UnmappedFirst = 'CHECK_UNMAPPED_FIRST'
}
/**
    * @export
    * @enum {string}
    */
export enum FuturesV1HistoricalTradesResponseFormatEnum {
    Json = 'JSON',
    Csv = 'CSV'
}
/**
    * @export
    * @enum {string}
    */
export enum FuturesV1HistoricalTradesHourMappingPriorityEnum {
    MappedFirst = 'CHECK_MAPPED_FIRST',
    UnmappedFirst = 'CHECK_UNMAPPED_FIRST'
}
/**
    * @export
    * @enum {string}
    */
export enum FuturesV1HistoricalTradesHourResponseFormatEnum {
    Json = 'JSON',
    Csv = 'CSV'
}
/**
    * @export
    * @enum {string}
    */
export enum FuturesV1LatestFundingRateTickMappingPriorityEnum {
    MappedFirst = 'CHECK_MAPPED_FIRST',
    UnmappedFirst = 'CHECK_UNMAPPED_FIRST'
}
/**
    * @export
    * @enum {string}
    */
export enum FuturesV1LatestInstrumentMetadataMappingPriorityEnum {
    MappedFirst = 'CHECK_MAPPED_FIRST',
    UnmappedFirst = 'CHECK_UNMAPPED_FIRST'
}
/**
    * @export
    * @enum {string}
    */
export enum FuturesV1LatestOpenInterestTickMappingPriorityEnum {
    MappedFirst = 'CHECK_MAPPED_FIRST',
    UnmappedFirst = 'CHECK_UNMAPPED_FIRST'
}
/**
    * @export
    * @enum {string}
    */
export enum FuturesV1LatestTickMappingPriorityEnum {
    MappedFirst = 'CHECK_MAPPED_FIRST',
    UnmappedFirst = 'CHECK_UNMAPPED_FIRST'
}
/**
    * @export
    * @enum {string}
    */
export enum FuturesV1MarketsInstrumentsInstrumentStatusEnum {
    Active = 'ACTIVE',
    Ignored = 'IGNORED',
    Retired = 'RETIRED',
    Expired = 'EXPIRED'
}
/**
    * @export
    * @enum {string}
    */
export enum FuturesV1MarketsInstrumentsUnmappedInstrumentStatusEnum {
    Active = 'ACTIVE',
    Ignored = 'IGNORED',
    Retired = 'RETIRED',
    Expired = 'EXPIRED'
}
/**
    * @export
    * @enum {string}
    */
export enum IndexV1HistoricalDaysMappingPriorityEnum {
    MappedFirst = 'CHECK_MAPPED_FIRST',
    UnmappedFirst = 'CHECK_UNMAPPED_FIRST'
}
/**
    * @export
    * @enum {string}
    */
export enum IndexV1HistoricalDaysResponseFormatEnum {
    Json = 'JSON',
    Csv = 'CSV'
}
/**
    * @export
    * @enum {string}
    */
export enum IndexV1HistoricalHoursMappingPriorityEnum {
    MappedFirst = 'CHECK_MAPPED_FIRST',
    UnmappedFirst = 'CHECK_UNMAPPED_FIRST'
}
/**
    * @export
    * @enum {string}
    */
export enum IndexV1HistoricalHoursResponseFormatEnum {
    Json = 'JSON',
    Csv = 'CSV'
}
/**
    * @export
    * @enum {string}
    */
export enum IndexV1HistoricalMessagesMappingPriorityEnum {
    MappedFirst = 'CHECK_MAPPED_FIRST',
    UnmappedFirst = 'CHECK_UNMAPPED_FIRST'
}
/**
    * @export
    * @enum {string}
    */
export enum IndexV1HistoricalMessagesResponseFormatEnum {
    Json = 'JSON',
    Csv = 'CSV'
}
/**
    * @export
    * @enum {string}
    */
export enum IndexV1HistoricalMessagesHourMappingPriorityEnum {
    MappedFirst = 'CHECK_MAPPED_FIRST',
    UnmappedFirst = 'CHECK_UNMAPPED_FIRST'
}
/**
    * @export
    * @enum {string}
    */
export enum IndexV1HistoricalMessagesHourResponseFormatEnum {
    Json = 'JSON',
    Csv = 'CSV'
}
/**
    * @export
    * @enum {string}
    */
export enum IndexV1HistoricalMinutesMappingPriorityEnum {
    MappedFirst = 'CHECK_MAPPED_FIRST',
    UnmappedFirst = 'CHECK_UNMAPPED_FIRST'
}
/**
    * @export
    * @enum {string}
    */
export enum IndexV1HistoricalMinutesResponseFormatEnum {
    Json = 'JSON',
    Csv = 'CSV'
}
/**
    * @export
    * @enum {string}
    */
export enum IndexV1LatestInstrumentMetadataMappingPriorityEnum {
    MappedFirst = 'CHECK_MAPPED_FIRST',
    UnmappedFirst = 'CHECK_UNMAPPED_FIRST'
}
/**
    * @export
    * @enum {string}
    */
export enum IndexV1LatestTickMappingPriorityEnum {
    MappedFirst = 'CHECK_MAPPED_FIRST',
    UnmappedFirst = 'CHECK_UNMAPPED_FIRST'
}
/**
    * @export
    * @enum {string}
    */
export enum IndexV1MarketsInstrumentsInstrumentStatusEnum {
    Active = 'ACTIVE',
    Ignored = 'IGNORED',
    Retired = 'RETIRED',
    Expired = 'EXPIRED'
}
/**
    * @export
    * @enum {string}
    */
export enum IndexV1MarketsInstrumentsUnmappedInstrumentStatusEnum {
    Active = 'ACTIVE',
    Ignored = 'IGNORED',
    Retired = 'RETIRED',
    Expired = 'EXPIRED'
}
