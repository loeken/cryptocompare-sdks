{-
   CryptoCompare Market, Index, Reference Data, News and Overview Metrcis API for the Cryptocurrency Industry

   CryptoCompare is the world's leading digital asset data company, providing services that cater to corporate, government and retail clients. Our main reference index is widely recognized as a reliable benchmark, and we have been authorized by the Financial Conduct Authority (FCA) in the United Kingdom to operate as a benchmark administrator. In addition to catering to corporate, government, and retail clients, we offer a range of services including comprehensive market data for cryptocurrency exchanges in both the centralized and decentralized finance sectors, as well as individual asset data on custodians, supported platforms, and privacy solutions. Our offerings include price, volume, trade, and orderbook updates, as well as historical OHLCV data.

   OpenAPI Version: 3.0.3
   CryptoCompare Market, Index, Reference Data, News and Overview Metrcis API for the Cryptocurrency Industry API version: 2.1.1
   Contact: data@cryptocompare.com
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : CryptoCompareMarket,Index,ReferenceData,NewsAndOverviewMetrcisAPIForTheCryptocurrencyIndustry.API.Spot
-}

{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MonoLocalBinds #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing -fno-warn-unused-binds -fno-warn-unused-imports #-}

module CryptoCompareMarket,Index,ReferenceData,NewsAndOverviewMetrcisAPIForTheCryptocurrencyIndustry.API.Spot where

import CryptoCompareMarket,Index,ReferenceData,NewsAndOverviewMetrcisAPIForTheCryptocurrencyIndustry.Core
import CryptoCompareMarket,Index,ReferenceData,NewsAndOverviewMetrcisAPIForTheCryptocurrencyIndustry.MimeTypes
import CryptoCompareMarket,Index,ReferenceData,NewsAndOverviewMetrcisAPIForTheCryptocurrencyIndustry.Model as M

import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Proxy as P (Proxy(..))
import qualified Data.Set as Set
import qualified Data.String as P
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Text.Lazy as TL
import qualified Data.Text.Lazy.Encoding as TL
import qualified Data.Time as TI
import qualified Network.HTTP.Client.MultipartFormData as NH
import qualified Network.HTTP.Media as ME
import qualified Network.HTTP.Types as NH
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Data.Text (Text)
import GHC.Base ((<|>))

import Prelude ((==),(/=),($), (.),(<$>),(<*>),(>>=),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)
import qualified Prelude as P

-- * Operations


-- ** Spot

-- *** spotV1HistoricalDays

-- | @GET \/spot\/v1\/historical\/days@
-- 
spotV1HistoricalDays
  :: Market -- ^ "market" -  The exchange to obtain data from
  -> Instrument -- ^ "instrument" -  The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
  -> CryptoCompareMarket,Index,ReferenceData,NewsAndOverviewMetrcisAPIForTheCryptocurrencyIndustryRequest SpotV1HistoricalDays MimeNoContent SPOTINSTRUMENTHISTODATARESPONSE MimeJSON
spotV1HistoricalDays (Market market) (Instrument instrument) =
  _mkRequest "GET" ["/spot/v1/historical/days"]
    `addQuery` toQuery ("market", Just market)
    `addQuery` toQuery ("instrument", Just instrument)

data SpotV1HistoricalDays  

-- | /Optional Param/ "groups" - When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,OHLC,OHLC_TRADE,TRADE,VOLUME
instance HasOptionalParam SpotV1HistoricalDays GroupsText where
  applyOptionalParam req (GroupsText xs) =
    req `addQuery` toQueryColl CommaSeparated ("groups", Just xs)

-- | /Optional Param/ "limit" - The number of data points to return
instance HasOptionalParam SpotV1HistoricalDays Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "to_ts" - Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit=2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &limit=2000&to_ts={the earliest unix timestamp received}
instance HasOptionalParam SpotV1HistoricalDays ToTs where
  applyOptionalParam req (ToTs xs) =
    req `addQuery` toQuery ("to_ts", Just xs)

-- | /Optional Param/ "aggregate" - The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
instance HasOptionalParam SpotV1HistoricalDays Aggregate where
  applyOptionalParam req (Aggregate xs) =
    req `addQuery` toQuery ("aggregate", Just xs)

-- | /Optional Param/ "fill" - Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
instance HasOptionalParam SpotV1HistoricalDays Fill where
  applyOptionalParam req (Fill xs) =
    req `addQuery` toQuery ("fill", Just xs)

-- | /Optional Param/ "mapping_priority" - The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
instance HasOptionalParam SpotV1HistoricalDays MappingPriority where
  applyOptionalParam req (MappingPriority xs) =
    req `addQuery` toQuery ("mapping_priority", Just xs)

-- | /Optional Param/ "response_format" - The format of the data response in uppercase. It can be one of the following: JSON,CSV
instance HasOptionalParam SpotV1HistoricalDays ResponseFormat where
  applyOptionalParam req (ResponseFormat xs) =
    req `addQuery` toQuery ("response_format", Just xs)
-- | @application/json@
instance Produces SpotV1HistoricalDays MimeJSON


-- *** spotV1HistoricalHours

-- | @GET \/spot\/v1\/historical\/hours@
-- 
spotV1HistoricalHours
  :: Market -- ^ "market" -  The exchange to obtain data from
  -> Instrument -- ^ "instrument" -  The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
  -> CryptoCompareMarket,Index,ReferenceData,NewsAndOverviewMetrcisAPIForTheCryptocurrencyIndustryRequest SpotV1HistoricalHours MimeNoContent SPOTINSTRUMENTHISTODATARESPONSE MimeJSON
spotV1HistoricalHours (Market market) (Instrument instrument) =
  _mkRequest "GET" ["/spot/v1/historical/hours"]
    `addQuery` toQuery ("market", Just market)
    `addQuery` toQuery ("instrument", Just instrument)

data SpotV1HistoricalHours  

-- | /Optional Param/ "groups" - When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,OHLC,OHLC_TRADE,TRADE,VOLUME
instance HasOptionalParam SpotV1HistoricalHours GroupsText where
  applyOptionalParam req (GroupsText xs) =
    req `addQuery` toQueryColl CommaSeparated ("groups", Just xs)

-- | /Optional Param/ "limit" - The number of data points to return
instance HasOptionalParam SpotV1HistoricalHours Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "to_ts" - Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit=2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &limit=2000&to_ts={the earliest unix timestamp received}
instance HasOptionalParam SpotV1HistoricalHours ToTs where
  applyOptionalParam req (ToTs xs) =
    req `addQuery` toQuery ("to_ts", Just xs)

-- | /Optional Param/ "aggregate" - The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
instance HasOptionalParam SpotV1HistoricalHours Aggregate where
  applyOptionalParam req (Aggregate xs) =
    req `addQuery` toQuery ("aggregate", Just xs)

-- | /Optional Param/ "fill" - Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
instance HasOptionalParam SpotV1HistoricalHours Fill where
  applyOptionalParam req (Fill xs) =
    req `addQuery` toQuery ("fill", Just xs)

-- | /Optional Param/ "mapping_priority" - The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
instance HasOptionalParam SpotV1HistoricalHours MappingPriority where
  applyOptionalParam req (MappingPriority xs) =
    req `addQuery` toQuery ("mapping_priority", Just xs)

-- | /Optional Param/ "response_format" - The format of the data response in uppercase. It can be one of the following: JSON,CSV
instance HasOptionalParam SpotV1HistoricalHours ResponseFormat where
  applyOptionalParam req (ResponseFormat xs) =
    req `addQuery` toQuery ("response_format", Just xs)
-- | @application/json@
instance Produces SpotV1HistoricalHours MimeJSON


-- *** spotV1HistoricalMinutes

-- | @GET \/spot\/v1\/historical\/minutes@
-- 
spotV1HistoricalMinutes
  :: Market -- ^ "market" -  The exchange to obtain data from
  -> Instrument -- ^ "instrument" -  The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
  -> CryptoCompareMarket,Index,ReferenceData,NewsAndOverviewMetrcisAPIForTheCryptocurrencyIndustryRequest SpotV1HistoricalMinutes MimeNoContent SPOTINSTRUMENTHISTODATARESPONSE MimeJSON
spotV1HistoricalMinutes (Market market) (Instrument instrument) =
  _mkRequest "GET" ["/spot/v1/historical/minutes"]
    `addQuery` toQuery ("market", Just market)
    `addQuery` toQuery ("instrument", Just instrument)

data SpotV1HistoricalMinutes  

-- | /Optional Param/ "groups" - When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,OHLC,OHLC_TRADE,TRADE,VOLUME
instance HasOptionalParam SpotV1HistoricalMinutes GroupsText where
  applyOptionalParam req (GroupsText xs) =
    req `addQuery` toQueryColl CommaSeparated ("groups", Just xs)

-- | /Optional Param/ "limit" - The number of data points to return
instance HasOptionalParam SpotV1HistoricalMinutes Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "to_ts" - Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit=2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &limit=2000&to_ts={the earliest unix timestamp received}
instance HasOptionalParam SpotV1HistoricalMinutes ToTs where
  applyOptionalParam req (ToTs xs) =
    req `addQuery` toQuery ("to_ts", Just xs)

-- | /Optional Param/ "aggregate" - The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
instance HasOptionalParam SpotV1HistoricalMinutes Aggregate where
  applyOptionalParam req (Aggregate xs) =
    req `addQuery` toQuery ("aggregate", Just xs)

-- | /Optional Param/ "fill" - Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
instance HasOptionalParam SpotV1HistoricalMinutes Fill where
  applyOptionalParam req (Fill xs) =
    req `addQuery` toQuery ("fill", Just xs)

-- | /Optional Param/ "mapping_priority" - The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
instance HasOptionalParam SpotV1HistoricalMinutes MappingPriority where
  applyOptionalParam req (MappingPriority xs) =
    req `addQuery` toQuery ("mapping_priority", Just xs)

-- | /Optional Param/ "response_format" - The format of the data response in uppercase. It can be one of the following: JSON,CSV
instance HasOptionalParam SpotV1HistoricalMinutes ResponseFormat where
  applyOptionalParam req (ResponseFormat xs) =
    req `addQuery` toQuery ("response_format", Just xs)
-- | @application/json@
instance Produces SpotV1HistoricalMinutes MimeJSON


-- *** spotV1HistoricalOrderbookL2SnapshotMinute

-- | @GET \/spot\/v1\/historical\/orderbook\/l2\/snapshot\/minute@
-- 
-- AuthMethod: 'AuthApiKeyApiKeyHeader', 'AuthApiKeyApiKeyQuery'
-- 
spotV1HistoricalOrderbookL2SnapshotMinute
  :: Market -- ^ "market" -  The exchange to obtain data from
  -> Instrument -- ^ "instrument" -  The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
  -> MinuteTs -- ^ "minuteTs" -  Unix timestamp in seconds for the minute of the orderbook snapshot you are interested in. You can pass any timestamp within a minute but we will round it down the the full minute timestmap and return the orderbook l2 snapshot at that minute.
  -> CryptoCompareMarket,Index,ReferenceData,NewsAndOverviewMetrcisAPIForTheCryptocurrencyIndustryRequest SpotV1HistoricalOrderbookL2SnapshotMinute MimeNoContent GENERICRESPONSE MimeJSON
spotV1HistoricalOrderbookL2SnapshotMinute (Market market) (Instrument instrument) (MinuteTs minuteTs) =
  _mkRequest "GET" ["/spot/v1/historical/orderbook/l2/snapshot/minute"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiKeyHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiKeyQuery)
    `addQuery` toQuery ("market", Just market)
    `addQuery` toQuery ("instrument", Just instrument)
    `addQuery` toQuery ("minute_ts", Just minuteTs)

data SpotV1HistoricalOrderbookL2SnapshotMinute  

-- | /Optional Param/ "depth" - The number of top bids and asks to return.
instance HasOptionalParam SpotV1HistoricalOrderbookL2SnapshotMinute Depth where
  applyOptionalParam req (Depth xs) =
    req `addQuery` toQuery ("depth", Just xs)

-- | /Optional Param/ "mapping_priority" - The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
instance HasOptionalParam SpotV1HistoricalOrderbookL2SnapshotMinute MappingPriority where
  applyOptionalParam req (MappingPriority xs) =
    req `addQuery` toQuery ("mapping_priority", Just xs)

-- | /Optional Param/ "response_format" - The format of the data response in uppercase. It can be one of the following: JSON,CSV
instance HasOptionalParam SpotV1HistoricalOrderbookL2SnapshotMinute ResponseFormat where
  applyOptionalParam req (ResponseFormat xs) =
    req `addQuery` toQuery ("response_format", Just xs)
-- | @application/json@
instance Produces SpotV1HistoricalOrderbookL2SnapshotMinute MimeJSON


-- *** spotV1HistoricalTrades

-- | @GET \/spot\/v1\/historical\/trades@
-- 
-- AuthMethod: 'AuthApiKeyApiKeyHeader', 'AuthApiKeyApiKeyQuery'
-- 
spotV1HistoricalTrades
  :: Market -- ^ "market" -  The exchange to obtain data from
  -> Instrument -- ^ "instrument" -  The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
  -> CryptoCompareMarket,Index,ReferenceData,NewsAndOverviewMetrcisAPIForTheCryptocurrencyIndustryRequest SpotV1HistoricalTrades MimeNoContent SPOTINSTRUMENTTRADERESPONSE MimeJSON
spotV1HistoricalTrades (Market market) (Instrument instrument) =
  _mkRequest "GET" ["/spot/v1/historical/trades"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiKeyHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiKeyQuery)
    `addQuery` toQuery ("market", Just market)
    `addQuery` toQuery ("instrument", Just instrument)

data SpotV1HistoricalTrades  

-- | /Optional Param/ "after_ts" - Unix timestamp in seconds of the earliest trade in the response.
instance HasOptionalParam SpotV1HistoricalTrades AfterTs where
  applyOptionalParam req (AfterTs xs) =
    req `addQuery` toQuery ("after_ts", Just xs)

-- | /Optional Param/ "last_ccseq" - The CCSEQ of the last message seen in the previous request. Useful for pagination within messages that happened in the same second. It will look though the messages in the same second and discard all messages until it reaches the CCSEQ from the last_ccseq parameter. If the CCSEQ is not part of that second, it will discard all messages in the second and only return messages starting from the next second onwards. When starting an integration with our API, on the first request, you should either not send a value for this paramater (defaults to 0 and does not discard any messages) or send 0. After you get a response use the TIMESTAMP and CCSEQ from the last message in the response. Pass the TIMESTAMP in the after_ts parameter and the CCSEQ in the last_ccseq parameter on your next request.
instance HasOptionalParam SpotV1HistoricalTrades LastCcseq where
  applyOptionalParam req (LastCcseq xs) =
    req `addQuery` toQuery ("last_ccseq", Just xs)

-- | /Optional Param/ "limit" - The maximum number of trades to return
instance HasOptionalParam SpotV1HistoricalTrades Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "mapping_priority" - The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
instance HasOptionalParam SpotV1HistoricalTrades MappingPriority where
  applyOptionalParam req (MappingPriority xs) =
    req `addQuery` toQuery ("mapping_priority", Just xs)

-- | /Optional Param/ "response_format" - The format of the data response in uppercase. It can be one of the following: JSON,CSV
instance HasOptionalParam SpotV1HistoricalTrades ResponseFormat where
  applyOptionalParam req (ResponseFormat xs) =
    req `addQuery` toQuery ("response_format", Just xs)

-- | /Optional Param/ "return_404_on_empty_response" - If set to false (default) then when there are no items to return, you will get a response status code of 200 and an empty JSON array or a CSV file with just the header. If set to true then when there are no items you will get a 404 status code for both JSON and CSV response_formats.
instance HasOptionalParam SpotV1HistoricalTrades Return404OnEmptyResponse where
  applyOptionalParam req (Return404OnEmptyResponse xs) =
    req `addQuery` toQuery ("return_404_on_empty_response", Just xs)
-- | @application/json@
instance Produces SpotV1HistoricalTrades MimeJSON


-- *** spotV1HistoricalTradesHour

-- | @GET \/spot\/v1\/historical\/trades\/hour@
-- 
-- AuthMethod: 'AuthApiKeyApiKeyHeader', 'AuthApiKeyApiKeyQuery'
-- 
spotV1HistoricalTradesHour
  :: Market -- ^ "market" -  The exchange to obtain data from
  -> Instrument -- ^ "instrument" -  The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
  -> CryptoCompareMarket,Index,ReferenceData,NewsAndOverviewMetrcisAPIForTheCryptocurrencyIndustryRequest SpotV1HistoricalTradesHour MimeNoContent SPOTINSTRUMENTTRADERESPONSE MimeJSON
spotV1HistoricalTradesHour (Market market) (Instrument instrument) =
  _mkRequest "GET" ["/spot/v1/historical/trades/hour"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiKeyHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiKeyQuery)
    `addQuery` toQuery ("market", Just market)
    `addQuery` toQuery ("instrument", Just instrument)

data SpotV1HistoricalTradesHour  

-- | /Optional Param/ "hour_ts" - Unix timestamp in seconds for the hour containing the trades you are interested in. You can pass any timestamp within an hour but we will round it down the the full hour timestmap and return all trades in that hour.
instance HasOptionalParam SpotV1HistoricalTradesHour HourTs where
  applyOptionalParam req (HourTs xs) =
    req `addQuery` toQuery ("hour_ts", Just xs)

-- | /Optional Param/ "mapping_priority" - The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
instance HasOptionalParam SpotV1HistoricalTradesHour MappingPriority where
  applyOptionalParam req (MappingPriority xs) =
    req `addQuery` toQuery ("mapping_priority", Just xs)

-- | /Optional Param/ "response_format" - The format of the data response in uppercase. It can be one of the following: JSON,CSV
instance HasOptionalParam SpotV1HistoricalTradesHour ResponseFormat where
  applyOptionalParam req (ResponseFormat xs) =
    req `addQuery` toQuery ("response_format", Just xs)

-- | /Optional Param/ "return_404_on_empty_response" - If set to false (default) then when there are no items to return, you will get a response status code of 200 and an empty JSON array or a CSV file with just the header. If set to true then when there are no items you will get a 404 status code for both JSON and CSV response_formats.
instance HasOptionalParam SpotV1HistoricalTradesHour Return404OnEmptyResponse where
  applyOptionalParam req (Return404OnEmptyResponse xs) =
    req `addQuery` toQuery ("return_404_on_empty_response", Just xs)
-- | @application/json@
instance Produces SpotV1HistoricalTradesHour MimeJSON


-- *** spotV1LatestInstrumentMetadata

-- | @GET \/spot\/v1\/latest\/instrument\/metadata@
-- 
spotV1LatestInstrumentMetadata
  :: Market -- ^ "market" -  The exchange to obtain data from
  -> Instruments -- ^ "instruments" -  A comma separated array of mapped and/or unmapped instruments to retrieve for a specific market (you can use either the instrument XXBTZUSD or mapped instrument (base - quote) BTC-USD on kraken as an example). We first check each instrument against the mapped list and then against the unmapped list but you can use the mapping_priority param to check the unmapped list first.
  -> CryptoCompareMarket,Index,ReferenceData,NewsAndOverviewMetrcisAPIForTheCryptocurrencyIndustryRequest SpotV1LatestInstrumentMetadata MimeNoContent SPOTINSTRUMENTMETADATARESPONSE MimeJSON
spotV1LatestInstrumentMetadata (Market market) (Instruments instruments) =
  _mkRequest "GET" ["/spot/v1/latest/instrument/metadata"]
    `addQuery` toQuery ("market", Just market)
    `addQuery` toQueryColl CommaSeparated ("instruments", Just instruments)

data SpotV1LatestInstrumentMetadata  

-- | /Optional Param/ "groups" - When requesting metadata entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: STATUS,INTERNAL,GENERAL,MIGRATION,SOURCE
instance HasOptionalParam SpotV1LatestInstrumentMetadata GroupsText where
  applyOptionalParam req (GroupsText xs) =
    req `addQuery` toQueryColl CommaSeparated ("groups", Just xs)

-- | /Optional Param/ "mapping_priority" - The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
instance HasOptionalParam SpotV1LatestInstrumentMetadata MappingPriority where
  applyOptionalParam req (MappingPriority xs) =
    req `addQuery` toQuery ("mapping_priority", Just xs)
-- | @application/json@
instance Produces SpotV1LatestInstrumentMetadata MimeJSON


-- *** spotV1LatestTick

-- | @GET \/spot\/v1\/latest\/tick@
-- 
spotV1LatestTick
  :: Market -- ^ "market" -  The exchange to obtain data from
  -> Instruments -- ^ "instruments" -  A comma separated array of mapped and/or unmapped instruments to retrieve for a specific market (you can use either the instrument XXBTZUSD or mapped instrument (base - quote) BTC-USD on kraken as an example). We first check each instrument against the mapped list and then against the unmapped list but you can use the mapping_priority param to check the unmapped list first.
  -> CryptoCompareMarket,Index,ReferenceData,NewsAndOverviewMetrcisAPIForTheCryptocurrencyIndustryRequest SpotV1LatestTick MimeNoContent SPOTINSTRUMENTMARKETDATARESPONSE MimeJSON
spotV1LatestTick (Market market) (Instruments instruments) =
  _mkRequest "GET" ["/spot/v1/latest/tick"]
    `addQuery` toQuery ("market", Just market)
    `addQuery` toQueryColl CommaSeparated ("instruments", Just instruments)

data SpotV1LatestTick  

-- | /Optional Param/ "groups" - When requesting tick data you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,VALUE,LAST_UPDATE,LAST_PROCESSED,TOP_OF_BOOK,CURRENT_HOUR,CURRENT_DAY,CURRENT_WEEK,CURRENT_MONTH,CURRENT_YEAR,MOVING_24_HOUR,MOVING_7_DAY,MOVING_30_DAY,MOVING_90_DAY,MOVING_180_DAY,MOVING_365_DAY,LIFETIME
instance HasOptionalParam SpotV1LatestTick GroupsText where
  applyOptionalParam req (GroupsText xs) =
    req `addQuery` toQueryColl CommaSeparated ("groups", Just xs)

-- | /Optional Param/ "mapping_priority" - The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
instance HasOptionalParam SpotV1LatestTick MappingPriority where
  applyOptionalParam req (MappingPriority xs) =
    req `addQuery` toQuery ("mapping_priority", Just xs)
-- | @application/json@
instance Produces SpotV1LatestTick MimeJSON


-- *** spotV1Markets

-- | @GET \/spot\/v1\/markets@
-- 
spotV1Markets
  :: CryptoCompareMarket,Index,ReferenceData,NewsAndOverviewMetrcisAPIForTheCryptocurrencyIndustryRequest SpotV1Markets MimeNoContent GENERICRESPONSE MimeJSON
spotV1Markets =
  _mkRequest "GET" ["/spot/v1/markets"]

data SpotV1Markets  

-- | /Optional Param/ "market" - The exchange to obtain data from
instance HasOptionalParam SpotV1Markets Market where
  applyOptionalParam req (Market xs) =
    req `addQuery` toQuery ("market", Just xs)
-- | @application/json@
instance Produces SpotV1Markets MimeJSON


-- *** spotV1MarketsInstruments

-- | @GET \/spot\/v1\/markets\/instruments@
-- 
spotV1MarketsInstruments
  :: CryptoCompareMarket,Index,ReferenceData,NewsAndOverviewMetrcisAPIForTheCryptocurrencyIndustryRequest SpotV1MarketsInstruments MimeNoContent GENERICRESPONSE MimeJSON
spotV1MarketsInstruments =
  _mkRequest "GET" ["/spot/v1/markets/instruments"]

data SpotV1MarketsInstruments  

-- | /Optional Param/ "market" - The exchange to obtain data from
instance HasOptionalParam SpotV1MarketsInstruments Market where
  applyOptionalParam req (Market xs) =
    req `addQuery` toQuery ("market", Just xs)

-- | /Optional Param/ "instrument" - The mapped instrument to retrieve on a specific market.
instance HasOptionalParam SpotV1MarketsInstruments Instrument where
  applyOptionalParam req (Instrument xs) =
    req `addQuery` toQuery ("instrument", Just xs)

-- | /Optional Param/ "instrument_status" - The status of the instrument, can be one of the following: ACTIVE, IGNORED, RETIRED, EXPIRED
instance HasOptionalParam SpotV1MarketsInstruments InstrumentStatus where
  applyOptionalParam req (InstrumentStatus xs) =
    req `addQuery` toQueryColl CommaSeparated ("instrument_status", Just xs)
-- | @application/json@
instance Produces SpotV1MarketsInstruments MimeJSON


-- *** spotV1MarketsInstrumentsUnmapped

-- | @GET \/spot\/v1\/markets\/instruments\/unmapped@
-- 
spotV1MarketsInstrumentsUnmapped
  :: CryptoCompareMarket,Index,ReferenceData,NewsAndOverviewMetrcisAPIForTheCryptocurrencyIndustryRequest SpotV1MarketsInstrumentsUnmapped MimeNoContent GENERICRESPONSE MimeJSON
spotV1MarketsInstrumentsUnmapped =
  _mkRequest "GET" ["/spot/v1/markets/instruments/unmapped"]

data SpotV1MarketsInstrumentsUnmapped  

-- | /Optional Param/ "market" - The exchange to obtain data from
instance HasOptionalParam SpotV1MarketsInstrumentsUnmapped Market where
  applyOptionalParam req (Market xs) =
    req `addQuery` toQuery ("market", Just xs)

-- | /Optional Param/ "instrument" - The unmapped instrument to retrieve on a specific market.
instance HasOptionalParam SpotV1MarketsInstrumentsUnmapped Instrument where
  applyOptionalParam req (Instrument xs) =
    req `addQuery` toQuery ("instrument", Just xs)

-- | /Optional Param/ "instrument_status" - The status of the instrument, can be one of the following: ACTIVE, IGNORED, RETIRED, EXPIRED
instance HasOptionalParam SpotV1MarketsInstrumentsUnmapped InstrumentStatus where
  applyOptionalParam req (InstrumentStatus xs) =
    req `addQuery` toQueryColl CommaSeparated ("instrument_status", Just xs)
-- | @application/json@
instance Produces SpotV1MarketsInstrumentsUnmapped MimeJSON

