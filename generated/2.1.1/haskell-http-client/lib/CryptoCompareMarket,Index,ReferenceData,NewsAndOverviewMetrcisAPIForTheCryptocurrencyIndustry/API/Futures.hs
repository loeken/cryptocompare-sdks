{-
   CryptoCompare Market, Index, Reference Data, News and Overview Metrcis API for the Cryptocurrency Industry

   CryptoCompare is the world's leading digital asset data company, providing services that cater to corporate, government and retail clients. Our main reference index is widely recognized as a reliable benchmark, and we have been authorized by the Financial Conduct Authority (FCA) in the United Kingdom to operate as a benchmark administrator. In addition to catering to corporate, government, and retail clients, we offer a range of services including comprehensive market data for cryptocurrency exchanges in both the centralized and decentralized finance sectors, as well as individual asset data on custodians, supported platforms, and privacy solutions. Our offerings include price, volume, trade, and orderbook updates, as well as historical OHLCV data.

   OpenAPI Version: 3.0.3
   CryptoCompare Market, Index, Reference Data, News and Overview Metrcis API for the Cryptocurrency Industry API version: 2.1.1
   Contact: data@cryptocompare.com
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : CryptoCompareMarket,Index,ReferenceData,NewsAndOverviewMetrcisAPIForTheCryptocurrencyIndustry.API.Futures
-}

{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MonoLocalBinds #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing -fno-warn-unused-binds -fno-warn-unused-imports #-}

module CryptoCompareMarket,Index,ReferenceData,NewsAndOverviewMetrcisAPIForTheCryptocurrencyIndustry.API.Futures where

import CryptoCompareMarket,Index,ReferenceData,NewsAndOverviewMetrcisAPIForTheCryptocurrencyIndustry.Core
import CryptoCompareMarket,Index,ReferenceData,NewsAndOverviewMetrcisAPIForTheCryptocurrencyIndustry.MimeTypes
import CryptoCompareMarket,Index,ReferenceData,NewsAndOverviewMetrcisAPIForTheCryptocurrencyIndustry.Model as M

import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Proxy as P (Proxy(..))
import qualified Data.Set as Set
import qualified Data.String as P
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Text.Lazy as TL
import qualified Data.Text.Lazy.Encoding as TL
import qualified Data.Time as TI
import qualified Network.HTTP.Client.MultipartFormData as NH
import qualified Network.HTTP.Media as ME
import qualified Network.HTTP.Types as NH
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Data.Text (Text)
import GHC.Base ((<|>))

import Prelude ((==),(/=),($), (.),(<$>),(<*>),(>>=),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)
import qualified Prelude as P

-- * Operations


-- ** Futures

-- *** futuresV1HistoricalDays

-- | @GET \/futures\/v1\/historical\/days@
-- 
futuresV1HistoricalDays
  :: Market -- ^ "market" -  The exchange to obtain data from
  -> Instrument -- ^ "instrument" -  The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
  -> CryptoCompareMarket,Index,ReferenceData,NewsAndOverviewMetrcisAPIForTheCryptocurrencyIndustryRequest FuturesV1HistoricalDays MimeNoContent GENERICRESPONSE MimeJSON
futuresV1HistoricalDays (Market market) (Instrument instrument) =
  _mkRequest "GET" ["/futures/v1/historical/days"]
    `addQuery` toQuery ("market", Just market)
    `addQuery` toQuery ("instrument", Just instrument)

data FuturesV1HistoricalDays  

-- | /Optional Param/ "groups" - When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,OHLC,OHLC_TRADE,TRADE,VOLUME
instance HasOptionalParam FuturesV1HistoricalDays GroupsText where
  applyOptionalParam req (GroupsText xs) =
    req `addQuery` toQueryColl CommaSeparated ("groups", Just xs)

-- | /Optional Param/ "limit" - The number of data points to return
instance HasOptionalParam FuturesV1HistoricalDays Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "to_ts" - Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit=2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &limit=2000&to_ts={the earliest unix timestamp received}
instance HasOptionalParam FuturesV1HistoricalDays ToTs where
  applyOptionalParam req (ToTs xs) =
    req `addQuery` toQuery ("to_ts", Just xs)

-- | /Optional Param/ "aggregate" - The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
instance HasOptionalParam FuturesV1HistoricalDays Aggregate where
  applyOptionalParam req (Aggregate xs) =
    req `addQuery` toQuery ("aggregate", Just xs)

-- | /Optional Param/ "fill" - Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
instance HasOptionalParam FuturesV1HistoricalDays Fill where
  applyOptionalParam req (Fill xs) =
    req `addQuery` toQuery ("fill", Just xs)

-- | /Optional Param/ "mapping_priority" - The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
instance HasOptionalParam FuturesV1HistoricalDays MappingPriority where
  applyOptionalParam req (MappingPriority xs) =
    req `addQuery` toQuery ("mapping_priority", Just xs)

-- | /Optional Param/ "response_format" - The format of the data response in uppercase. It can be one of the following: JSON,CSV
instance HasOptionalParam FuturesV1HistoricalDays ResponseFormat where
  applyOptionalParam req (ResponseFormat xs) =
    req `addQuery` toQuery ("response_format", Just xs)
-- | @application/json@
instance Produces FuturesV1HistoricalDays MimeJSON


-- *** futuresV1HistoricalFundingRateDays

-- | @GET \/futures\/v1\/historical\/funding-rate\/days@
-- 
futuresV1HistoricalFundingRateDays
  :: Market -- ^ "market" -  The exchange to obtain data from
  -> Instrument -- ^ "instrument" -  The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
  -> CryptoCompareMarket,Index,ReferenceData,NewsAndOverviewMetrcisAPIForTheCryptocurrencyIndustryRequest FuturesV1HistoricalFundingRateDays MimeNoContent GENERICRESPONSE MimeJSON
futuresV1HistoricalFundingRateDays (Market market) (Instrument instrument) =
  _mkRequest "GET" ["/futures/v1/historical/funding-rate/days"]
    `addQuery` toQuery ("market", Just market)
    `addQuery` toQuery ("instrument", Just instrument)

data FuturesV1HistoricalFundingRateDays  

-- | /Optional Param/ "groups" - When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,VALUE,OHLC,OHLC_MESSAGE,MESSAGE
instance HasOptionalParam FuturesV1HistoricalFundingRateDays GroupsText where
  applyOptionalParam req (GroupsText xs) =
    req `addQuery` toQueryColl CommaSeparated ("groups", Just xs)

-- | /Optional Param/ "limit" - The number of data points to return
instance HasOptionalParam FuturesV1HistoricalFundingRateDays Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "to_ts" - Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit=2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &limit=2000&to_ts={the earliest unix timestamp received}
instance HasOptionalParam FuturesV1HistoricalFundingRateDays ToTs where
  applyOptionalParam req (ToTs xs) =
    req `addQuery` toQuery ("to_ts", Just xs)

-- | /Optional Param/ "aggregate" - The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
instance HasOptionalParam FuturesV1HistoricalFundingRateDays Aggregate where
  applyOptionalParam req (Aggregate xs) =
    req `addQuery` toQuery ("aggregate", Just xs)

-- | /Optional Param/ "fill" - Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
instance HasOptionalParam FuturesV1HistoricalFundingRateDays Fill where
  applyOptionalParam req (Fill xs) =
    req `addQuery` toQuery ("fill", Just xs)

-- | /Optional Param/ "mapping_priority" - The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
instance HasOptionalParam FuturesV1HistoricalFundingRateDays MappingPriority where
  applyOptionalParam req (MappingPriority xs) =
    req `addQuery` toQuery ("mapping_priority", Just xs)

-- | /Optional Param/ "response_format" - The format of the data response in uppercase. It can be one of the following: JSON,CSV
instance HasOptionalParam FuturesV1HistoricalFundingRateDays ResponseFormat where
  applyOptionalParam req (ResponseFormat xs) =
    req `addQuery` toQuery ("response_format", Just xs)
-- | @application/json@
instance Produces FuturesV1HistoricalFundingRateDays MimeJSON


-- *** futuresV1HistoricalFundingRateHours

-- | @GET \/futures\/v1\/historical\/funding-rate\/hours@
-- 
futuresV1HistoricalFundingRateHours
  :: Market -- ^ "market" -  The exchange to obtain data from
  -> Instrument -- ^ "instrument" -  The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
  -> CryptoCompareMarket,Index,ReferenceData,NewsAndOverviewMetrcisAPIForTheCryptocurrencyIndustryRequest FuturesV1HistoricalFundingRateHours MimeNoContent GENERICRESPONSE MimeJSON
futuresV1HistoricalFundingRateHours (Market market) (Instrument instrument) =
  _mkRequest "GET" ["/futures/v1/historical/funding-rate/hours"]
    `addQuery` toQuery ("market", Just market)
    `addQuery` toQuery ("instrument", Just instrument)

data FuturesV1HistoricalFundingRateHours  

-- | /Optional Param/ "groups" - When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,VALUE,OHLC,OHLC_MESSAGE,MESSAGE
instance HasOptionalParam FuturesV1HistoricalFundingRateHours GroupsText where
  applyOptionalParam req (GroupsText xs) =
    req `addQuery` toQueryColl CommaSeparated ("groups", Just xs)

-- | /Optional Param/ "limit" - The number of data points to return
instance HasOptionalParam FuturesV1HistoricalFundingRateHours Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "to_ts" - Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit=2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &limit=2000&to_ts={the earliest unix timestamp received}
instance HasOptionalParam FuturesV1HistoricalFundingRateHours ToTs where
  applyOptionalParam req (ToTs xs) =
    req `addQuery` toQuery ("to_ts", Just xs)

-- | /Optional Param/ "aggregate" - The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
instance HasOptionalParam FuturesV1HistoricalFundingRateHours Aggregate where
  applyOptionalParam req (Aggregate xs) =
    req `addQuery` toQuery ("aggregate", Just xs)

-- | /Optional Param/ "fill" - Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
instance HasOptionalParam FuturesV1HistoricalFundingRateHours Fill where
  applyOptionalParam req (Fill xs) =
    req `addQuery` toQuery ("fill", Just xs)

-- | /Optional Param/ "mapping_priority" - The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
instance HasOptionalParam FuturesV1HistoricalFundingRateHours MappingPriority where
  applyOptionalParam req (MappingPriority xs) =
    req `addQuery` toQuery ("mapping_priority", Just xs)

-- | /Optional Param/ "response_format" - The format of the data response in uppercase. It can be one of the following: JSON,CSV
instance HasOptionalParam FuturesV1HistoricalFundingRateHours ResponseFormat where
  applyOptionalParam req (ResponseFormat xs) =
    req `addQuery` toQuery ("response_format", Just xs)
-- | @application/json@
instance Produces FuturesV1HistoricalFundingRateHours MimeJSON


-- *** futuresV1HistoricalFundingRateMessages

-- | @GET \/futures\/v1\/historical\/funding-rate-messages@
-- 
-- AuthMethod: 'AuthApiKeyApiKeyHeader', 'AuthApiKeyApiKeyQuery'
-- 
futuresV1HistoricalFundingRateMessages
  :: Market -- ^ "market" -  The exchange to obtain data from
  -> Instrument -- ^ "instrument" -  The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
  -> CryptoCompareMarket,Index,ReferenceData,NewsAndOverviewMetrcisAPIForTheCryptocurrencyIndustryRequest FuturesV1HistoricalFundingRateMessages MimeNoContent GENERICRESPONSE MimeJSON
futuresV1HistoricalFundingRateMessages (Market market) (Instrument instrument) =
  _mkRequest "GET" ["/futures/v1/historical/funding-rate-messages"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiKeyHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiKeyQuery)
    `addQuery` toQuery ("market", Just market)
    `addQuery` toQuery ("instrument", Just instrument)

data FuturesV1HistoricalFundingRateMessages  

-- | /Optional Param/ "after_ts" - Unix timestamp in seconds of the earliest funding rate message in the response
instance HasOptionalParam FuturesV1HistoricalFundingRateMessages AfterTs where
  applyOptionalParam req (AfterTs xs) =
    req `addQuery` toQuery ("after_ts", Just xs)

-- | /Optional Param/ "last_ccseq" - The CCSEQ of the last message seen in the previous request. Useful for pagination within messages that happened in the same second. It will look though the messages in the same second and discard all messages until it reaches the CCSEQ from the last_ccseq parameter. If the CCSEQ is not part of that second, it will discard all messages in the second and only return messages starting from the next second onwards. When starting an integration with our API, on the first request, you should either not send a value for this paramater (defaults to 0 and does not discard any messages) or send 0. After you get a response use the TIMESTAMP and CCSEQ from the last message in the response. Pass the TIMESTAMP in the after_ts parameter and the CCSEQ in the last_ccseq parameter on your next request.
instance HasOptionalParam FuturesV1HistoricalFundingRateMessages LastCcseq where
  applyOptionalParam req (LastCcseq xs) =
    req `addQuery` toQuery ("last_ccseq", Just xs)

-- | /Optional Param/ "limit" - The maximum number of funding rate messages to return
instance HasOptionalParam FuturesV1HistoricalFundingRateMessages Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "mapping_priority" - The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
instance HasOptionalParam FuturesV1HistoricalFundingRateMessages MappingPriority where
  applyOptionalParam req (MappingPriority xs) =
    req `addQuery` toQuery ("mapping_priority", Just xs)

-- | /Optional Param/ "response_format" - The format of the data response in uppercase. It can be one of the following: JSON,CSV
instance HasOptionalParam FuturesV1HistoricalFundingRateMessages ResponseFormat where
  applyOptionalParam req (ResponseFormat xs) =
    req `addQuery` toQuery ("response_format", Just xs)

-- | /Optional Param/ "return_404_on_empty_response" - If set to false (default) then when there are no items to return, you will get a response status code of 200 and an empty JSON array or a CSV file with just the header. If set to true then when there are no items you will get a 404 status code for both JSON and CSV response_formats.
instance HasOptionalParam FuturesV1HistoricalFundingRateMessages Return404OnEmptyResponse where
  applyOptionalParam req (Return404OnEmptyResponse xs) =
    req `addQuery` toQuery ("return_404_on_empty_response", Just xs)
-- | @application/json@
instance Produces FuturesV1HistoricalFundingRateMessages MimeJSON


-- *** futuresV1HistoricalFundingRateMessagesHour

-- | @GET \/futures\/v1\/historical\/funding-rate-messages\/hour@
-- 
-- AuthMethod: 'AuthApiKeyApiKeyHeader', 'AuthApiKeyApiKeyQuery'
-- 
futuresV1HistoricalFundingRateMessagesHour
  :: Market -- ^ "market" -  The exchange to obtain data from
  -> Instrument -- ^ "instrument" -  The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
  -> CryptoCompareMarket,Index,ReferenceData,NewsAndOverviewMetrcisAPIForTheCryptocurrencyIndustryRequest FuturesV1HistoricalFundingRateMessagesHour MimeNoContent GENERICRESPONSE MimeJSON
futuresV1HistoricalFundingRateMessagesHour (Market market) (Instrument instrument) =
  _mkRequest "GET" ["/futures/v1/historical/funding-rate-messages/hour"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiKeyHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiKeyQuery)
    `addQuery` toQuery ("market", Just market)
    `addQuery` toQuery ("instrument", Just instrument)

data FuturesV1HistoricalFundingRateMessagesHour  

-- | /Optional Param/ "hour_ts" - Unix timestamp in seconds for the hour containing the funding rate updates you are interested in. You can pass any timestamp in the hour but we will round it down the the full hour timestmap and return all funding rate updates in that hour.
instance HasOptionalParam FuturesV1HistoricalFundingRateMessagesHour HourTs where
  applyOptionalParam req (HourTs xs) =
    req `addQuery` toQuery ("hour_ts", Just xs)

-- | /Optional Param/ "mapping_priority" - The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
instance HasOptionalParam FuturesV1HistoricalFundingRateMessagesHour MappingPriority where
  applyOptionalParam req (MappingPriority xs) =
    req `addQuery` toQuery ("mapping_priority", Just xs)

-- | /Optional Param/ "response_format" - The format of the data response in uppercase. It can be one of the following: JSON,CSV
instance HasOptionalParam FuturesV1HistoricalFundingRateMessagesHour ResponseFormat where
  applyOptionalParam req (ResponseFormat xs) =
    req `addQuery` toQuery ("response_format", Just xs)

-- | /Optional Param/ "return_404_on_empty_response" - If set to false (default) then when there are no items to return, you will get a response status code of 200 and an empty JSON array or a CSV file with just the header. If set to true then when there are no items you will get a 404 status code for both JSON and CSV response_formats.
instance HasOptionalParam FuturesV1HistoricalFundingRateMessagesHour Return404OnEmptyResponse where
  applyOptionalParam req (Return404OnEmptyResponse xs) =
    req `addQuery` toQuery ("return_404_on_empty_response", Just xs)
-- | @application/json@
instance Produces FuturesV1HistoricalFundingRateMessagesHour MimeJSON


-- *** futuresV1HistoricalFundingRateMinutes

-- | @GET \/futures\/v1\/historical\/funding-rate\/minutes@
-- 
futuresV1HistoricalFundingRateMinutes
  :: Market -- ^ "market" -  The exchange to obtain data from
  -> Instrument -- ^ "instrument" -  The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
  -> CryptoCompareMarket,Index,ReferenceData,NewsAndOverviewMetrcisAPIForTheCryptocurrencyIndustryRequest FuturesV1HistoricalFundingRateMinutes MimeNoContent GENERICRESPONSE MimeJSON
futuresV1HistoricalFundingRateMinutes (Market market) (Instrument instrument) =
  _mkRequest "GET" ["/futures/v1/historical/funding-rate/minutes"]
    `addQuery` toQuery ("market", Just market)
    `addQuery` toQuery ("instrument", Just instrument)

data FuturesV1HistoricalFundingRateMinutes  

-- | /Optional Param/ "groups" - When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,VALUE,OHLC,OHLC_MESSAGE,MESSAGE
instance HasOptionalParam FuturesV1HistoricalFundingRateMinutes GroupsText where
  applyOptionalParam req (GroupsText xs) =
    req `addQuery` toQueryColl CommaSeparated ("groups", Just xs)

-- | /Optional Param/ "limit" - The number of data points to return
instance HasOptionalParam FuturesV1HistoricalFundingRateMinutes Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "to_ts" - Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit=2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &limit=2000&to_ts={the earliest unix timestamp received}
instance HasOptionalParam FuturesV1HistoricalFundingRateMinutes ToTs where
  applyOptionalParam req (ToTs xs) =
    req `addQuery` toQuery ("to_ts", Just xs)

-- | /Optional Param/ "aggregate" - The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
instance HasOptionalParam FuturesV1HistoricalFundingRateMinutes Aggregate where
  applyOptionalParam req (Aggregate xs) =
    req `addQuery` toQuery ("aggregate", Just xs)

-- | /Optional Param/ "fill" - Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
instance HasOptionalParam FuturesV1HistoricalFundingRateMinutes Fill where
  applyOptionalParam req (Fill xs) =
    req `addQuery` toQuery ("fill", Just xs)

-- | /Optional Param/ "mapping_priority" - The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
instance HasOptionalParam FuturesV1HistoricalFundingRateMinutes MappingPriority where
  applyOptionalParam req (MappingPriority xs) =
    req `addQuery` toQuery ("mapping_priority", Just xs)

-- | /Optional Param/ "response_format" - The format of the data response in uppercase. It can be one of the following: JSON,CSV
instance HasOptionalParam FuturesV1HistoricalFundingRateMinutes ResponseFormat where
  applyOptionalParam req (ResponseFormat xs) =
    req `addQuery` toQuery ("response_format", Just xs)
-- | @application/json@
instance Produces FuturesV1HistoricalFundingRateMinutes MimeJSON


-- *** futuresV1HistoricalHours

-- | @GET \/futures\/v1\/historical\/hours@
-- 
futuresV1HistoricalHours
  :: Market -- ^ "market" -  The exchange to obtain data from
  -> Instrument -- ^ "instrument" -  The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
  -> CryptoCompareMarket,Index,ReferenceData,NewsAndOverviewMetrcisAPIForTheCryptocurrencyIndustryRequest FuturesV1HistoricalHours MimeNoContent GENERICRESPONSE MimeJSON
futuresV1HistoricalHours (Market market) (Instrument instrument) =
  _mkRequest "GET" ["/futures/v1/historical/hours"]
    `addQuery` toQuery ("market", Just market)
    `addQuery` toQuery ("instrument", Just instrument)

data FuturesV1HistoricalHours  

-- | /Optional Param/ "groups" - When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,OHLC,OHLC_TRADE,TRADE,VOLUME
instance HasOptionalParam FuturesV1HistoricalHours GroupsText where
  applyOptionalParam req (GroupsText xs) =
    req `addQuery` toQueryColl CommaSeparated ("groups", Just xs)

-- | /Optional Param/ "limit" - The number of data points to return
instance HasOptionalParam FuturesV1HistoricalHours Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "to_ts" - Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit=2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &limit=2000&to_ts={the earliest unix timestamp received}
instance HasOptionalParam FuturesV1HistoricalHours ToTs where
  applyOptionalParam req (ToTs xs) =
    req `addQuery` toQuery ("to_ts", Just xs)

-- | /Optional Param/ "aggregate" - The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
instance HasOptionalParam FuturesV1HistoricalHours Aggregate where
  applyOptionalParam req (Aggregate xs) =
    req `addQuery` toQuery ("aggregate", Just xs)

-- | /Optional Param/ "fill" - Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
instance HasOptionalParam FuturesV1HistoricalHours Fill where
  applyOptionalParam req (Fill xs) =
    req `addQuery` toQuery ("fill", Just xs)

-- | /Optional Param/ "mapping_priority" - The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
instance HasOptionalParam FuturesV1HistoricalHours MappingPriority where
  applyOptionalParam req (MappingPriority xs) =
    req `addQuery` toQuery ("mapping_priority", Just xs)

-- | /Optional Param/ "response_format" - The format of the data response in uppercase. It can be one of the following: JSON,CSV
instance HasOptionalParam FuturesV1HistoricalHours ResponseFormat where
  applyOptionalParam req (ResponseFormat xs) =
    req `addQuery` toQuery ("response_format", Just xs)
-- | @application/json@
instance Produces FuturesV1HistoricalHours MimeJSON


-- *** futuresV1HistoricalMinutes

-- | @GET \/futures\/v1\/historical\/minutes@
-- 
futuresV1HistoricalMinutes
  :: Market -- ^ "market" -  The exchange to obtain data from
  -> Instrument -- ^ "instrument" -  The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
  -> CryptoCompareMarket,Index,ReferenceData,NewsAndOverviewMetrcisAPIForTheCryptocurrencyIndustryRequest FuturesV1HistoricalMinutes MimeNoContent GENERICRESPONSE MimeJSON
futuresV1HistoricalMinutes (Market market) (Instrument instrument) =
  _mkRequest "GET" ["/futures/v1/historical/minutes"]
    `addQuery` toQuery ("market", Just market)
    `addQuery` toQuery ("instrument", Just instrument)

data FuturesV1HistoricalMinutes  

-- | /Optional Param/ "groups" - When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,OHLC,OHLC_TRADE,TRADE,VOLUME
instance HasOptionalParam FuturesV1HistoricalMinutes GroupsText where
  applyOptionalParam req (GroupsText xs) =
    req `addQuery` toQueryColl CommaSeparated ("groups", Just xs)

-- | /Optional Param/ "limit" - The number of data points to return
instance HasOptionalParam FuturesV1HistoricalMinutes Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "to_ts" - Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit=2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &limit=2000&to_ts={the earliest unix timestamp received}
instance HasOptionalParam FuturesV1HistoricalMinutes ToTs where
  applyOptionalParam req (ToTs xs) =
    req `addQuery` toQuery ("to_ts", Just xs)

-- | /Optional Param/ "aggregate" - The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
instance HasOptionalParam FuturesV1HistoricalMinutes Aggregate where
  applyOptionalParam req (Aggregate xs) =
    req `addQuery` toQuery ("aggregate", Just xs)

-- | /Optional Param/ "fill" - Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
instance HasOptionalParam FuturesV1HistoricalMinutes Fill where
  applyOptionalParam req (Fill xs) =
    req `addQuery` toQuery ("fill", Just xs)

-- | /Optional Param/ "mapping_priority" - The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
instance HasOptionalParam FuturesV1HistoricalMinutes MappingPriority where
  applyOptionalParam req (MappingPriority xs) =
    req `addQuery` toQuery ("mapping_priority", Just xs)

-- | /Optional Param/ "response_format" - The format of the data response in uppercase. It can be one of the following: JSON,CSV
instance HasOptionalParam FuturesV1HistoricalMinutes ResponseFormat where
  applyOptionalParam req (ResponseFormat xs) =
    req `addQuery` toQuery ("response_format", Just xs)
-- | @application/json@
instance Produces FuturesV1HistoricalMinutes MimeJSON


-- *** futuresV1HistoricalOpenInterestDays

-- | @GET \/futures\/v1\/historical\/open-interest\/days@
-- 
futuresV1HistoricalOpenInterestDays
  :: Market -- ^ "market" -  The exchange to obtain data from
  -> Instrument -- ^ "instrument" -  The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
  -> CryptoCompareMarket,Index,ReferenceData,NewsAndOverviewMetrcisAPIForTheCryptocurrencyIndustryRequest FuturesV1HistoricalOpenInterestDays MimeNoContent GENERICRESPONSE MimeJSON
futuresV1HistoricalOpenInterestDays (Market market) (Instrument instrument) =
  _mkRequest "GET" ["/futures/v1/historical/open-interest/days"]
    `addQuery` toQuery ("market", Just market)
    `addQuery` toQuery ("instrument", Just instrument)

data FuturesV1HistoricalOpenInterestDays  

-- | /Optional Param/ "groups" - When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,OHLC,OHLC_MESSAGE,MESSAGE
instance HasOptionalParam FuturesV1HistoricalOpenInterestDays GroupsText where
  applyOptionalParam req (GroupsText xs) =
    req `addQuery` toQueryColl CommaSeparated ("groups", Just xs)

-- | /Optional Param/ "limit" - The number of data points to return
instance HasOptionalParam FuturesV1HistoricalOpenInterestDays Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "to_ts" - Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit=2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &limit=2000&to_ts={the earliest unix timestamp received}
instance HasOptionalParam FuturesV1HistoricalOpenInterestDays ToTs where
  applyOptionalParam req (ToTs xs) =
    req `addQuery` toQuery ("to_ts", Just xs)

-- | /Optional Param/ "aggregate" - The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
instance HasOptionalParam FuturesV1HistoricalOpenInterestDays Aggregate where
  applyOptionalParam req (Aggregate xs) =
    req `addQuery` toQuery ("aggregate", Just xs)

-- | /Optional Param/ "fill" - Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
instance HasOptionalParam FuturesV1HistoricalOpenInterestDays Fill where
  applyOptionalParam req (Fill xs) =
    req `addQuery` toQuery ("fill", Just xs)

-- | /Optional Param/ "mapping_priority" - The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
instance HasOptionalParam FuturesV1HistoricalOpenInterestDays MappingPriority where
  applyOptionalParam req (MappingPriority xs) =
    req `addQuery` toQuery ("mapping_priority", Just xs)

-- | /Optional Param/ "response_format" - The format of the data response in uppercase. It can be one of the following: JSON,CSV
instance HasOptionalParam FuturesV1HistoricalOpenInterestDays ResponseFormat where
  applyOptionalParam req (ResponseFormat xs) =
    req `addQuery` toQuery ("response_format", Just xs)
-- | @application/json@
instance Produces FuturesV1HistoricalOpenInterestDays MimeJSON


-- *** futuresV1HistoricalOpenInterestHours

-- | @GET \/futures\/v1\/historical\/open-interest\/hours@
-- 
futuresV1HistoricalOpenInterestHours
  :: Market -- ^ "market" -  The exchange to obtain data from
  -> Instrument -- ^ "instrument" -  The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
  -> CryptoCompareMarket,Index,ReferenceData,NewsAndOverviewMetrcisAPIForTheCryptocurrencyIndustryRequest FuturesV1HistoricalOpenInterestHours MimeNoContent GENERICRESPONSE MimeJSON
futuresV1HistoricalOpenInterestHours (Market market) (Instrument instrument) =
  _mkRequest "GET" ["/futures/v1/historical/open-interest/hours"]
    `addQuery` toQuery ("market", Just market)
    `addQuery` toQuery ("instrument", Just instrument)

data FuturesV1HistoricalOpenInterestHours  

-- | /Optional Param/ "groups" - When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,OHLC,OHLC_MESSAGE,MESSAGE
instance HasOptionalParam FuturesV1HistoricalOpenInterestHours GroupsText where
  applyOptionalParam req (GroupsText xs) =
    req `addQuery` toQueryColl CommaSeparated ("groups", Just xs)

-- | /Optional Param/ "limit" - The number of data points to return
instance HasOptionalParam FuturesV1HistoricalOpenInterestHours Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "to_ts" - Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit=2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &limit=2000&to_ts={the earliest unix timestamp received}
instance HasOptionalParam FuturesV1HistoricalOpenInterestHours ToTs where
  applyOptionalParam req (ToTs xs) =
    req `addQuery` toQuery ("to_ts", Just xs)

-- | /Optional Param/ "aggregate" - The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
instance HasOptionalParam FuturesV1HistoricalOpenInterestHours Aggregate where
  applyOptionalParam req (Aggregate xs) =
    req `addQuery` toQuery ("aggregate", Just xs)

-- | /Optional Param/ "fill" - Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
instance HasOptionalParam FuturesV1HistoricalOpenInterestHours Fill where
  applyOptionalParam req (Fill xs) =
    req `addQuery` toQuery ("fill", Just xs)

-- | /Optional Param/ "mapping_priority" - The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
instance HasOptionalParam FuturesV1HistoricalOpenInterestHours MappingPriority where
  applyOptionalParam req (MappingPriority xs) =
    req `addQuery` toQuery ("mapping_priority", Just xs)

-- | /Optional Param/ "response_format" - The format of the data response in uppercase. It can be one of the following: JSON,CSV
instance HasOptionalParam FuturesV1HistoricalOpenInterestHours ResponseFormat where
  applyOptionalParam req (ResponseFormat xs) =
    req `addQuery` toQuery ("response_format", Just xs)
-- | @application/json@
instance Produces FuturesV1HistoricalOpenInterestHours MimeJSON


-- *** futuresV1HistoricalOpenInterestMessages

-- | @GET \/futures\/v1\/historical\/open-interest-messages@
-- 
-- AuthMethod: 'AuthApiKeyApiKeyHeader', 'AuthApiKeyApiKeyQuery'
-- 
futuresV1HistoricalOpenInterestMessages
  :: Market -- ^ "market" -  The exchange to obtain data from
  -> Instrument -- ^ "instrument" -  The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
  -> CryptoCompareMarket,Index,ReferenceData,NewsAndOverviewMetrcisAPIForTheCryptocurrencyIndustryRequest FuturesV1HistoricalOpenInterestMessages MimeNoContent GENERICRESPONSE MimeJSON
futuresV1HistoricalOpenInterestMessages (Market market) (Instrument instrument) =
  _mkRequest "GET" ["/futures/v1/historical/open-interest-messages"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiKeyHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiKeyQuery)
    `addQuery` toQuery ("market", Just market)
    `addQuery` toQuery ("instrument", Just instrument)

data FuturesV1HistoricalOpenInterestMessages  

-- | /Optional Param/ "after_ts" - Unix timestamp in seconds of the earliest open interest message in the response
instance HasOptionalParam FuturesV1HistoricalOpenInterestMessages AfterTs where
  applyOptionalParam req (AfterTs xs) =
    req `addQuery` toQuery ("after_ts", Just xs)

-- | /Optional Param/ "last_ccseq" - The CCSEQ of the last message seen in the previous request. Useful for pagination within messages that happened in the same second. It will look though the messages in the same second and discard all messages until it reaches the CCSEQ from the last_ccseq parameter. If the CCSEQ is not part of that second, it will discard all messages in the second and only return messages starting from the next second onwards. When starting an integration with our API, on the first request, you should either not send a value for this paramater (defaults to 0 and does not discard any messages) or send 0. After you get a response use the TIMESTAMP and CCSEQ from the last message in the response. Pass the TIMESTAMP in the after_ts parameter and the CCSEQ in the last_ccseq parameter on your next request.
instance HasOptionalParam FuturesV1HistoricalOpenInterestMessages LastCcseq where
  applyOptionalParam req (LastCcseq xs) =
    req `addQuery` toQuery ("last_ccseq", Just xs)

-- | /Optional Param/ "limit" - The maximum number of open interest messages to return
instance HasOptionalParam FuturesV1HistoricalOpenInterestMessages Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "mapping_priority" - The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
instance HasOptionalParam FuturesV1HistoricalOpenInterestMessages MappingPriority where
  applyOptionalParam req (MappingPriority xs) =
    req `addQuery` toQuery ("mapping_priority", Just xs)

-- | /Optional Param/ "response_format" - The format of the data response in uppercase. It can be one of the following: JSON,CSV
instance HasOptionalParam FuturesV1HistoricalOpenInterestMessages ResponseFormat where
  applyOptionalParam req (ResponseFormat xs) =
    req `addQuery` toQuery ("response_format", Just xs)

-- | /Optional Param/ "return_404_on_empty_response" - If set to false (default) then when there are no items to return, you will get a response status code of 200 and an empty JSON array or a CSV file with just the header. If set to true then when there are no items you will get a 404 status code for both JSON and CSV response_formats.
instance HasOptionalParam FuturesV1HistoricalOpenInterestMessages Return404OnEmptyResponse where
  applyOptionalParam req (Return404OnEmptyResponse xs) =
    req `addQuery` toQuery ("return_404_on_empty_response", Just xs)
-- | @application/json@
instance Produces FuturesV1HistoricalOpenInterestMessages MimeJSON


-- *** futuresV1HistoricalOpenInterestMessagesHour

-- | @GET \/futures\/v1\/historical\/open-interest-messages\/hour@
-- 
-- AuthMethod: 'AuthApiKeyApiKeyHeader', 'AuthApiKeyApiKeyQuery'
-- 
futuresV1HistoricalOpenInterestMessagesHour
  :: Market -- ^ "market" -  The exchange to obtain data from
  -> Instrument -- ^ "instrument" -  The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
  -> CryptoCompareMarket,Index,ReferenceData,NewsAndOverviewMetrcisAPIForTheCryptocurrencyIndustryRequest FuturesV1HistoricalOpenInterestMessagesHour MimeNoContent GENERICRESPONSE MimeJSON
futuresV1HistoricalOpenInterestMessagesHour (Market market) (Instrument instrument) =
  _mkRequest "GET" ["/futures/v1/historical/open-interest-messages/hour"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiKeyHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiKeyQuery)
    `addQuery` toQuery ("market", Just market)
    `addQuery` toQuery ("instrument", Just instrument)

data FuturesV1HistoricalOpenInterestMessagesHour  

-- | /Optional Param/ "hour_ts" - Unix timestamp in seconds for the hour containing the open interest updates you are interested in. You can pass any timestamp in the hour but we will round it down the the full hour timestmap and return all open interest updates in that hour.
instance HasOptionalParam FuturesV1HistoricalOpenInterestMessagesHour HourTs where
  applyOptionalParam req (HourTs xs) =
    req `addQuery` toQuery ("hour_ts", Just xs)

-- | /Optional Param/ "mapping_priority" - The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
instance HasOptionalParam FuturesV1HistoricalOpenInterestMessagesHour MappingPriority where
  applyOptionalParam req (MappingPriority xs) =
    req `addQuery` toQuery ("mapping_priority", Just xs)

-- | /Optional Param/ "response_format" - The format of the data response in uppercase. It can be one of the following: JSON,CSV
instance HasOptionalParam FuturesV1HistoricalOpenInterestMessagesHour ResponseFormat where
  applyOptionalParam req (ResponseFormat xs) =
    req `addQuery` toQuery ("response_format", Just xs)

-- | /Optional Param/ "return_404_on_empty_response" - If set to false (default) then when there are no items to return, you will get a response status code of 200 and an empty JSON array or a CSV file with just the header. If set to true then when there are no items you will get a 404 status code for both JSON and CSV response_formats.
instance HasOptionalParam FuturesV1HistoricalOpenInterestMessagesHour Return404OnEmptyResponse where
  applyOptionalParam req (Return404OnEmptyResponse xs) =
    req `addQuery` toQuery ("return_404_on_empty_response", Just xs)
-- | @application/json@
instance Produces FuturesV1HistoricalOpenInterestMessagesHour MimeJSON


-- *** futuresV1HistoricalOpenInterestMinutes

-- | @GET \/futures\/v1\/historical\/open-interest\/minutes@
-- 
futuresV1HistoricalOpenInterestMinutes
  :: Market -- ^ "market" -  The exchange to obtain data from
  -> Instrument -- ^ "instrument" -  The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
  -> CryptoCompareMarket,Index,ReferenceData,NewsAndOverviewMetrcisAPIForTheCryptocurrencyIndustryRequest FuturesV1HistoricalOpenInterestMinutes MimeNoContent GENERICRESPONSE MimeJSON
futuresV1HistoricalOpenInterestMinutes (Market market) (Instrument instrument) =
  _mkRequest "GET" ["/futures/v1/historical/open-interest/minutes"]
    `addQuery` toQuery ("market", Just market)
    `addQuery` toQuery ("instrument", Just instrument)

data FuturesV1HistoricalOpenInterestMinutes  

-- | /Optional Param/ "groups" - When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,OHLC,OHLC_MESSAGE,MESSAGE
instance HasOptionalParam FuturesV1HistoricalOpenInterestMinutes GroupsText where
  applyOptionalParam req (GroupsText xs) =
    req `addQuery` toQueryColl CommaSeparated ("groups", Just xs)

-- | /Optional Param/ "limit" - The number of data points to return
instance HasOptionalParam FuturesV1HistoricalOpenInterestMinutes Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "to_ts" - Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit=2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &limit=2000&to_ts={the earliest unix timestamp received}
instance HasOptionalParam FuturesV1HistoricalOpenInterestMinutes ToTs where
  applyOptionalParam req (ToTs xs) =
    req `addQuery` toQuery ("to_ts", Just xs)

-- | /Optional Param/ "aggregate" - The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
instance HasOptionalParam FuturesV1HistoricalOpenInterestMinutes Aggregate where
  applyOptionalParam req (Aggregate xs) =
    req `addQuery` toQuery ("aggregate", Just xs)

-- | /Optional Param/ "fill" - Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
instance HasOptionalParam FuturesV1HistoricalOpenInterestMinutes Fill where
  applyOptionalParam req (Fill xs) =
    req `addQuery` toQuery ("fill", Just xs)

-- | /Optional Param/ "mapping_priority" - The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
instance HasOptionalParam FuturesV1HistoricalOpenInterestMinutes MappingPriority where
  applyOptionalParam req (MappingPriority xs) =
    req `addQuery` toQuery ("mapping_priority", Just xs)

-- | /Optional Param/ "response_format" - The format of the data response in uppercase. It can be one of the following: JSON,CSV
instance HasOptionalParam FuturesV1HistoricalOpenInterestMinutes ResponseFormat where
  applyOptionalParam req (ResponseFormat xs) =
    req `addQuery` toQuery ("response_format", Just xs)
-- | @application/json@
instance Produces FuturesV1HistoricalOpenInterestMinutes MimeJSON


-- *** futuresV1HistoricalTrades

-- | @GET \/futures\/v1\/historical\/trades@
-- 
-- AuthMethod: 'AuthApiKeyApiKeyHeader', 'AuthApiKeyApiKeyQuery'
-- 
futuresV1HistoricalTrades
  :: Market -- ^ "market" -  The exchange to obtain data from
  -> Instrument -- ^ "instrument" -  The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
  -> CryptoCompareMarket,Index,ReferenceData,NewsAndOverviewMetrcisAPIForTheCryptocurrencyIndustryRequest FuturesV1HistoricalTrades MimeNoContent GENERICRESPONSE MimeJSON
futuresV1HistoricalTrades (Market market) (Instrument instrument) =
  _mkRequest "GET" ["/futures/v1/historical/trades"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiKeyHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiKeyQuery)
    `addQuery` toQuery ("market", Just market)
    `addQuery` toQuery ("instrument", Just instrument)

data FuturesV1HistoricalTrades  

-- | /Optional Param/ "after_ts" - Unix timestamp in seconds of the earliest trade in the response.
instance HasOptionalParam FuturesV1HistoricalTrades AfterTs where
  applyOptionalParam req (AfterTs xs) =
    req `addQuery` toQuery ("after_ts", Just xs)

-- | /Optional Param/ "last_ccseq" - The CCSEQ of the last message seen in the previous request. Useful for pagination within messages that happened in the same second. It will look though the messages in the same second and discard all messages until it reaches the CCSEQ from the last_ccseq parameter. If the CCSEQ is not part of that second, it will discard all messages in the second and only return messages starting from the next second onwards. When starting an integration with our API, on the first request, you should either not send a value for this paramater (defaults to 0 and does not discard any messages) or send 0. After you get a response use the TIMESTAMP and CCSEQ from the last message in the response. Pass the TIMESTAMP in the after_ts parameter and the CCSEQ in the last_ccseq parameter on your next request.
instance HasOptionalParam FuturesV1HistoricalTrades LastCcseq where
  applyOptionalParam req (LastCcseq xs) =
    req `addQuery` toQuery ("last_ccseq", Just xs)

-- | /Optional Param/ "limit" - The maximum number of trades to return
instance HasOptionalParam FuturesV1HistoricalTrades Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "mapping_priority" - The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
instance HasOptionalParam FuturesV1HistoricalTrades MappingPriority where
  applyOptionalParam req (MappingPriority xs) =
    req `addQuery` toQuery ("mapping_priority", Just xs)

-- | /Optional Param/ "response_format" - The format of the data response in uppercase. It can be one of the following: JSON,CSV
instance HasOptionalParam FuturesV1HistoricalTrades ResponseFormat where
  applyOptionalParam req (ResponseFormat xs) =
    req `addQuery` toQuery ("response_format", Just xs)

-- | /Optional Param/ "return_404_on_empty_response" - If set to false (default) then when there are no items to return, you will get a response status code of 200 and an empty JSON array or a CSV file with just the header. If set to true then when there are no items you will get a 404 status code for both JSON and CSV response_formats.
instance HasOptionalParam FuturesV1HistoricalTrades Return404OnEmptyResponse where
  applyOptionalParam req (Return404OnEmptyResponse xs) =
    req `addQuery` toQuery ("return_404_on_empty_response", Just xs)
-- | @application/json@
instance Produces FuturesV1HistoricalTrades MimeJSON


-- *** futuresV1HistoricalTradesHour

-- | @GET \/futures\/v1\/historical\/trades\/hour@
-- 
-- AuthMethod: 'AuthApiKeyApiKeyHeader', 'AuthApiKeyApiKeyQuery'
-- 
futuresV1HistoricalTradesHour
  :: Market -- ^ "market" -  The exchange to obtain data from
  -> Instrument -- ^ "instrument" -  The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
  -> CryptoCompareMarket,Index,ReferenceData,NewsAndOverviewMetrcisAPIForTheCryptocurrencyIndustryRequest FuturesV1HistoricalTradesHour MimeNoContent GENERICRESPONSE MimeJSON
futuresV1HistoricalTradesHour (Market market) (Instrument instrument) =
  _mkRequest "GET" ["/futures/v1/historical/trades/hour"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiKeyHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiKeyQuery)
    `addQuery` toQuery ("market", Just market)
    `addQuery` toQuery ("instrument", Just instrument)

data FuturesV1HistoricalTradesHour  

-- | /Optional Param/ "hour_ts" - Unix timestamp in seconds for the hour containing the trades you are interested in. You can pass any timestamp within an hour but we will round it down the the full hour timestmap and return all trades in that hour.
instance HasOptionalParam FuturesV1HistoricalTradesHour HourTs where
  applyOptionalParam req (HourTs xs) =
    req `addQuery` toQuery ("hour_ts", Just xs)

-- | /Optional Param/ "mapping_priority" - The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
instance HasOptionalParam FuturesV1HistoricalTradesHour MappingPriority where
  applyOptionalParam req (MappingPriority xs) =
    req `addQuery` toQuery ("mapping_priority", Just xs)

-- | /Optional Param/ "response_format" - The format of the data response in uppercase. It can be one of the following: JSON,CSV
instance HasOptionalParam FuturesV1HistoricalTradesHour ResponseFormat where
  applyOptionalParam req (ResponseFormat xs) =
    req `addQuery` toQuery ("response_format", Just xs)

-- | /Optional Param/ "return_404_on_empty_response" - If set to false (default) then when there are no items to return, you will get a response status code of 200 and an empty JSON array or a CSV file with just the header. If set to true then when there are no items you will get a 404 status code for both JSON and CSV response_formats.
instance HasOptionalParam FuturesV1HistoricalTradesHour Return404OnEmptyResponse where
  applyOptionalParam req (Return404OnEmptyResponse xs) =
    req `addQuery` toQuery ("return_404_on_empty_response", Just xs)
-- | @application/json@
instance Produces FuturesV1HistoricalTradesHour MimeJSON


-- *** futuresV1LatestFundingRateTick

-- | @GET \/futures\/v1\/latest\/funding-rate\/tick@
-- 
futuresV1LatestFundingRateTick
  :: Market -- ^ "market" -  The exchange to obtain data from
  -> Instruments -- ^ "instruments" -  A comma separated array of mapped and/or unmapped instruments to retrieve for a specific market (you can use either the instrument XXBTZUSD or mapped instrument (base - quote) BTC-USD on kraken as an example). We first check each instrument against the mapped list and then against the unmapped list but you can use the mapping_priority param to check the unmapped list first.
  -> CryptoCompareMarket,Index,ReferenceData,NewsAndOverviewMetrcisAPIForTheCryptocurrencyIndustryRequest FuturesV1LatestFundingRateTick MimeNoContent GENERICRESPONSE MimeJSON
futuresV1LatestFundingRateTick (Market market) (Instruments instruments) =
  _mkRequest "GET" ["/futures/v1/latest/funding-rate/tick"]
    `addQuery` toQuery ("market", Just market)
    `addQuery` toQueryColl CommaSeparated ("instruments", Just instruments)

data FuturesV1LatestFundingRateTick  

-- | /Optional Param/ "groups" - When requesting tick data you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,VALUE,LAST_UPDATE,CURRENT_HOUR,CURRENT_DAY,CURRENT_WEEK,CURRENT_MONTH,CURRENT_YEAR,MOVING_24_HOUR,MOVING_7_DAY,MOVING_30_DAY,MOVING_90_DAY,MOVING_180_DAY,MOVING_365_DAY,LIFETIME
instance HasOptionalParam FuturesV1LatestFundingRateTick GroupsText where
  applyOptionalParam req (GroupsText xs) =
    req `addQuery` toQueryColl CommaSeparated ("groups", Just xs)

-- | /Optional Param/ "mapping_priority" - The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
instance HasOptionalParam FuturesV1LatestFundingRateTick MappingPriority where
  applyOptionalParam req (MappingPriority xs) =
    req `addQuery` toQuery ("mapping_priority", Just xs)
-- | @application/json@
instance Produces FuturesV1LatestFundingRateTick MimeJSON


-- *** futuresV1LatestInstrumentMetadata

-- | @GET \/futures\/v1\/latest\/instrument\/metadata@
-- 
futuresV1LatestInstrumentMetadata
  :: Market -- ^ "market" -  The exchange to obtain data from
  -> Instruments -- ^ "instruments" -  A comma separated array of mapped and/or unmapped instruments to retrieve for a specific market (you can use either the instrument XXBTZUSD or mapped instrument (base - quote) BTC-USD on kraken as an example). We first check each instrument against the mapped list and then against the unmapped list but you can use the mapping_priority param to check the unmapped list first.
  -> CryptoCompareMarket,Index,ReferenceData,NewsAndOverviewMetrcisAPIForTheCryptocurrencyIndustryRequest FuturesV1LatestInstrumentMetadata MimeNoContent GENERICRESPONSE MimeJSON
futuresV1LatestInstrumentMetadata (Market market) (Instruments instruments) =
  _mkRequest "GET" ["/futures/v1/latest/instrument/metadata"]
    `addQuery` toQuery ("market", Just market)
    `addQuery` toQueryColl CommaSeparated ("instruments", Just instruments)

data FuturesV1LatestInstrumentMetadata  

-- | /Optional Param/ "groups" - When requesting metadata entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: STATUS,INTERNAL,GENERAL,MIGRATION,SOURCE
instance HasOptionalParam FuturesV1LatestInstrumentMetadata GroupsText where
  applyOptionalParam req (GroupsText xs) =
    req `addQuery` toQueryColl CommaSeparated ("groups", Just xs)

-- | /Optional Param/ "mapping_priority" - The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
instance HasOptionalParam FuturesV1LatestInstrumentMetadata MappingPriority where
  applyOptionalParam req (MappingPriority xs) =
    req `addQuery` toQuery ("mapping_priority", Just xs)
-- | @application/json@
instance Produces FuturesV1LatestInstrumentMetadata MimeJSON


-- *** futuresV1LatestOpenInterestTick

-- | @GET \/futures\/v1\/latest\/open-interest\/tick@
-- 
futuresV1LatestOpenInterestTick
  :: Market -- ^ "market" -  The exchange to obtain data from
  -> Instruments -- ^ "instruments" -  A comma separated array of mapped and/or unmapped instruments to retrieve for a specific market (you can use either the instrument XXBTZUSD or mapped instrument (base - quote) BTC-USD on kraken as an example). We first check each instrument against the mapped list and then against the unmapped list but you can use the mapping_priority param to check the unmapped list first.
  -> CryptoCompareMarket,Index,ReferenceData,NewsAndOverviewMetrcisAPIForTheCryptocurrencyIndustryRequest FuturesV1LatestOpenInterestTick MimeNoContent GENERICRESPONSE MimeJSON
futuresV1LatestOpenInterestTick (Market market) (Instruments instruments) =
  _mkRequest "GET" ["/futures/v1/latest/open-interest/tick"]
    `addQuery` toQuery ("market", Just market)
    `addQuery` toQueryColl CommaSeparated ("instruments", Just instruments)

data FuturesV1LatestOpenInterestTick  

-- | /Optional Param/ "groups" - When requesting tick data you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,VALUE,LAST_UPDATE,CURRENT_HOUR,CURRENT_DAY,CURRENT_WEEK,CURRENT_MONTH,CURRENT_YEAR,MOVING_24_HOUR,MOVING_7_DAY,MOVING_30_DAY,MOVING_90_DAY,MOVING_180_DAY,MOVING_365_DAY,LIFETIME
instance HasOptionalParam FuturesV1LatestOpenInterestTick GroupsText where
  applyOptionalParam req (GroupsText xs) =
    req `addQuery` toQueryColl CommaSeparated ("groups", Just xs)

-- | /Optional Param/ "mapping_priority" - The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
instance HasOptionalParam FuturesV1LatestOpenInterestTick MappingPriority where
  applyOptionalParam req (MappingPriority xs) =
    req `addQuery` toQuery ("mapping_priority", Just xs)
-- | @application/json@
instance Produces FuturesV1LatestOpenInterestTick MimeJSON


-- *** futuresV1LatestTick

-- | @GET \/futures\/v1\/latest\/tick@
-- 
futuresV1LatestTick
  :: Market -- ^ "market" -  The exchange to obtain data from
  -> Instruments -- ^ "instruments" -  A comma separated array of mapped and/or unmapped instruments to retrieve for a specific market (you can use either the instrument XXBTZUSD or mapped instrument (base - quote) BTC-USD on kraken as an example). We first check each instrument against the mapped list and then against the unmapped list but you can use the mapping_priority param to check the unmapped list first.
  -> CryptoCompareMarket,Index,ReferenceData,NewsAndOverviewMetrcisAPIForTheCryptocurrencyIndustryRequest FuturesV1LatestTick MimeNoContent GENERICRESPONSE MimeJSON
futuresV1LatestTick (Market market) (Instruments instruments) =
  _mkRequest "GET" ["/futures/v1/latest/tick"]
    `addQuery` toQuery ("market", Just market)
    `addQuery` toQueryColl CommaSeparated ("instruments", Just instruments)

data FuturesV1LatestTick  

-- | /Optional Param/ "groups" - When requesting tick data you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,MAPPING,VALUE,LAST_UPDATE,TOP_OF_BOOK,CURRENT_HOUR,CURRENT_DAY,CURRENT_WEEK,CURRENT_MONTH,CURRENT_YEAR,MOVING_24_HOUR,MOVING_7_DAY,MOVING_30_DAY,MOVING_90_DAY,MOVING_180_DAY,MOVING_365_DAY,LIFETIME
instance HasOptionalParam FuturesV1LatestTick GroupsText where
  applyOptionalParam req (GroupsText xs) =
    req `addQuery` toQueryColl CommaSeparated ("groups", Just xs)

-- | /Optional Param/ "mapping_priority" - The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
instance HasOptionalParam FuturesV1LatestTick MappingPriority where
  applyOptionalParam req (MappingPriority xs) =
    req `addQuery` toQuery ("mapping_priority", Just xs)
-- | @application/json@
instance Produces FuturesV1LatestTick MimeJSON


-- *** futuresV1Markets

-- | @GET \/futures\/v1\/markets@
-- 
futuresV1Markets
  :: CryptoCompareMarket,Index,ReferenceData,NewsAndOverviewMetrcisAPIForTheCryptocurrencyIndustryRequest FuturesV1Markets MimeNoContent GENERICRESPONSE MimeJSON
futuresV1Markets =
  _mkRequest "GET" ["/futures/v1/markets"]

data FuturesV1Markets  

-- | /Optional Param/ "market" - The exchange to obtain data from
instance HasOptionalParam FuturesV1Markets Market where
  applyOptionalParam req (Market xs) =
    req `addQuery` toQuery ("market", Just xs)
-- | @application/json@
instance Produces FuturesV1Markets MimeJSON


-- *** futuresV1MarketsInstruments

-- | @GET \/futures\/v1\/markets\/instruments@
-- 
futuresV1MarketsInstruments
  :: CryptoCompareMarket,Index,ReferenceData,NewsAndOverviewMetrcisAPIForTheCryptocurrencyIndustryRequest FuturesV1MarketsInstruments MimeNoContent GENERICRESPONSE MimeJSON
futuresV1MarketsInstruments =
  _mkRequest "GET" ["/futures/v1/markets/instruments"]

data FuturesV1MarketsInstruments  

-- | /Optional Param/ "market" - The exchange to obtain data from
instance HasOptionalParam FuturesV1MarketsInstruments Market where
  applyOptionalParam req (Market xs) =
    req `addQuery` toQuery ("market", Just xs)

-- | /Optional Param/ "instrument" - The mapped instrument to retrieve on a specific market.
instance HasOptionalParam FuturesV1MarketsInstruments Instrument where
  applyOptionalParam req (Instrument xs) =
    req `addQuery` toQuery ("instrument", Just xs)

-- | /Optional Param/ "instrument_status" - The status of the instrument, can be one of the following: ACTIVE, IGNORED, RETIRED, EXPIRED
instance HasOptionalParam FuturesV1MarketsInstruments InstrumentStatus where
  applyOptionalParam req (InstrumentStatus xs) =
    req `addQuery` toQueryColl CommaSeparated ("instrument_status", Just xs)
-- | @application/json@
instance Produces FuturesV1MarketsInstruments MimeJSON


-- *** futuresV1MarketsInstrumentsUnmapped

-- | @GET \/futures\/v1\/markets\/instruments\/unmapped@
-- 
futuresV1MarketsInstrumentsUnmapped
  :: CryptoCompareMarket,Index,ReferenceData,NewsAndOverviewMetrcisAPIForTheCryptocurrencyIndustryRequest FuturesV1MarketsInstrumentsUnmapped MimeNoContent GENERICRESPONSE MimeJSON
futuresV1MarketsInstrumentsUnmapped =
  _mkRequest "GET" ["/futures/v1/markets/instruments/unmapped"]

data FuturesV1MarketsInstrumentsUnmapped  

-- | /Optional Param/ "market" - The exchange to obtain data from
instance HasOptionalParam FuturesV1MarketsInstrumentsUnmapped Market where
  applyOptionalParam req (Market xs) =
    req `addQuery` toQuery ("market", Just xs)

-- | /Optional Param/ "instrument" - The unmapped instrument to retrieve on a specific market.
instance HasOptionalParam FuturesV1MarketsInstrumentsUnmapped Instrument where
  applyOptionalParam req (Instrument xs) =
    req `addQuery` toQuery ("instrument", Just xs)

-- | /Optional Param/ "instrument_status" - The status of the instrument, can be one of the following: ACTIVE, IGNORED, RETIRED, EXPIRED
instance HasOptionalParam FuturesV1MarketsInstrumentsUnmapped InstrumentStatus where
  applyOptionalParam req (InstrumentStatus xs) =
    req `addQuery` toQueryColl CommaSeparated ("instrument_status", Just xs)
-- | @application/json@
instance Produces FuturesV1MarketsInstrumentsUnmapped MimeJSON


-- *** indexV1HistoricalDays

-- | @GET \/index\/v1\/historical\/days@
-- 
indexV1HistoricalDays
  :: Market -- ^ "market" -  The exchange to obtain data from
  -> Instrument -- ^ "instrument" -  The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
  -> CryptoCompareMarket,Index,ReferenceData,NewsAndOverviewMetrcisAPIForTheCryptocurrencyIndustryRequest IndexV1HistoricalDays MimeNoContent GENERICRESPONSE MimeJSON
indexV1HistoricalDays (Market market) (Instrument instrument) =
  _mkRequest "GET" ["/index/v1/historical/days"]
    `addQuery` toQuery ("market", Just market)
    `addQuery` toQuery ("instrument", Just instrument)

data IndexV1HistoricalDays  

-- | /Optional Param/ "groups" - When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,OHLC,OHLC_MESSAGE,MESSAGE,VOLUME
instance HasOptionalParam IndexV1HistoricalDays GroupsText where
  applyOptionalParam req (GroupsText xs) =
    req `addQuery` toQueryColl CommaSeparated ("groups", Just xs)

-- | /Optional Param/ "limit" - The number of data points to return
instance HasOptionalParam IndexV1HistoricalDays Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "to_ts" - Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit=2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &limit=2000&to_ts={the earliest unix timestamp received}
instance HasOptionalParam IndexV1HistoricalDays ToTs where
  applyOptionalParam req (ToTs xs) =
    req `addQuery` toQuery ("to_ts", Just xs)

-- | /Optional Param/ "aggregate" - The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
instance HasOptionalParam IndexV1HistoricalDays Aggregate where
  applyOptionalParam req (Aggregate xs) =
    req `addQuery` toQuery ("aggregate", Just xs)

-- | /Optional Param/ "fill" - Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
instance HasOptionalParam IndexV1HistoricalDays Fill where
  applyOptionalParam req (Fill xs) =
    req `addQuery` toQuery ("fill", Just xs)

-- | /Optional Param/ "mapping_priority" - The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
instance HasOptionalParam IndexV1HistoricalDays MappingPriority where
  applyOptionalParam req (MappingPriority xs) =
    req `addQuery` toQuery ("mapping_priority", Just xs)

-- | /Optional Param/ "response_format" - The format of the data response in uppercase. It can be one of the following: JSON,CSV
instance HasOptionalParam IndexV1HistoricalDays ResponseFormat where
  applyOptionalParam req (ResponseFormat xs) =
    req `addQuery` toQuery ("response_format", Just xs)
-- | @application/json@
instance Produces IndexV1HistoricalDays MimeJSON


-- *** indexV1HistoricalHours

-- | @GET \/index\/v1\/historical\/hours@
-- 
indexV1HistoricalHours
  :: Market -- ^ "market" -  The exchange to obtain data from
  -> Instrument -- ^ "instrument" -  The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
  -> CryptoCompareMarket,Index,ReferenceData,NewsAndOverviewMetrcisAPIForTheCryptocurrencyIndustryRequest IndexV1HistoricalHours MimeNoContent GENERICRESPONSE MimeJSON
indexV1HistoricalHours (Market market) (Instrument instrument) =
  _mkRequest "GET" ["/index/v1/historical/hours"]
    `addQuery` toQuery ("market", Just market)
    `addQuery` toQuery ("instrument", Just instrument)

data IndexV1HistoricalHours  

-- | /Optional Param/ "groups" - When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,OHLC,OHLC_MESSAGE,MESSAGE,VOLUME
instance HasOptionalParam IndexV1HistoricalHours GroupsText where
  applyOptionalParam req (GroupsText xs) =
    req `addQuery` toQueryColl CommaSeparated ("groups", Just xs)

-- | /Optional Param/ "limit" - The number of data points to return
instance HasOptionalParam IndexV1HistoricalHours Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "to_ts" - Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit=2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &limit=2000&to_ts={the earliest unix timestamp received}
instance HasOptionalParam IndexV1HistoricalHours ToTs where
  applyOptionalParam req (ToTs xs) =
    req `addQuery` toQuery ("to_ts", Just xs)

-- | /Optional Param/ "aggregate" - The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
instance HasOptionalParam IndexV1HistoricalHours Aggregate where
  applyOptionalParam req (Aggregate xs) =
    req `addQuery` toQuery ("aggregate", Just xs)

-- | /Optional Param/ "fill" - Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
instance HasOptionalParam IndexV1HistoricalHours Fill where
  applyOptionalParam req (Fill xs) =
    req `addQuery` toQuery ("fill", Just xs)

-- | /Optional Param/ "mapping_priority" - The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
instance HasOptionalParam IndexV1HistoricalHours MappingPriority where
  applyOptionalParam req (MappingPriority xs) =
    req `addQuery` toQuery ("mapping_priority", Just xs)

-- | /Optional Param/ "response_format" - The format of the data response in uppercase. It can be one of the following: JSON,CSV
instance HasOptionalParam IndexV1HistoricalHours ResponseFormat where
  applyOptionalParam req (ResponseFormat xs) =
    req `addQuery` toQuery ("response_format", Just xs)
-- | @application/json@
instance Produces IndexV1HistoricalHours MimeJSON


-- *** indexV1HistoricalMessages

-- | @GET \/index\/v1\/historical\/messages@
-- 
-- AuthMethod: 'AuthApiKeyApiKeyHeader', 'AuthApiKeyApiKeyQuery'
-- 
indexV1HistoricalMessages
  :: Market -- ^ "market" -  The exchange to obtain data from
  -> Instrument -- ^ "instrument" -  The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
  -> CryptoCompareMarket,Index,ReferenceData,NewsAndOverviewMetrcisAPIForTheCryptocurrencyIndustryRequest IndexV1HistoricalMessages MimeNoContent GENERICRESPONSE MimeJSON
indexV1HistoricalMessages (Market market) (Instrument instrument) =
  _mkRequest "GET" ["/index/v1/historical/messages"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiKeyHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiKeyQuery)
    `addQuery` toQuery ("market", Just market)
    `addQuery` toQuery ("instrument", Just instrument)

data IndexV1HistoricalMessages  

-- | /Optional Param/ "after_ts" - Unix timestamp in seconds of the earliest index message in the response
instance HasOptionalParam IndexV1HistoricalMessages AfterTs where
  applyOptionalParam req (AfterTs xs) =
    req `addQuery` toQuery ("after_ts", Just xs)

-- | /Optional Param/ "last_ccseq" - The CCSEQ of the last message seen in the previous request. Useful for pagination within messages that happened in the same second. It will look though the messages in the same second and discard all messages until it reaches the CCSEQ from the last_ccseq parameter. If the CCSEQ is not part of that second, it will discard all messages in the second and only return messages starting from the next second onwards. When starting an integration with our API, on the first request, you should either not send a value for this paramater (defaults to 0 and does not discard any messages) or send 0. After you get a response use the TIMESTAMP and CCSEQ from the last message in the response. Pass the TIMESTAMP in the after_ts parameter and the CCSEQ in the last_ccseq parameter on your next request.
instance HasOptionalParam IndexV1HistoricalMessages LastCcseq where
  applyOptionalParam req (LastCcseq xs) =
    req `addQuery` toQuery ("last_ccseq", Just xs)

-- | /Optional Param/ "limit" - The maximum number of index messages to return
instance HasOptionalParam IndexV1HistoricalMessages Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "mapping_priority" - The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
instance HasOptionalParam IndexV1HistoricalMessages MappingPriority where
  applyOptionalParam req (MappingPriority xs) =
    req `addQuery` toQuery ("mapping_priority", Just xs)

-- | /Optional Param/ "response_format" - The format of the data response in uppercase. It can be one of the following: JSON,CSV
instance HasOptionalParam IndexV1HistoricalMessages ResponseFormat where
  applyOptionalParam req (ResponseFormat xs) =
    req `addQuery` toQuery ("response_format", Just xs)

-- | /Optional Param/ "return_404_on_empty_response" - If set to false (default) then when there are no items to return, you will get a response status code of 200 and an empty JSON array or a CSV file with just the header. If set to true then when there are no items you will get a 404 status code for both JSON and CSV response_formats.
instance HasOptionalParam IndexV1HistoricalMessages Return404OnEmptyResponse where
  applyOptionalParam req (Return404OnEmptyResponse xs) =
    req `addQuery` toQuery ("return_404_on_empty_response", Just xs)
-- | @application/json@
instance Produces IndexV1HistoricalMessages MimeJSON


-- *** indexV1HistoricalMessagesHour

-- | @GET \/index\/v1\/historical\/messages\/hour@
-- 
-- AuthMethod: 'AuthApiKeyApiKeyHeader', 'AuthApiKeyApiKeyQuery'
-- 
indexV1HistoricalMessagesHour
  :: Market -- ^ "market" -  The exchange to obtain data from
  -> Instrument -- ^ "instrument" -  The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
  -> CryptoCompareMarket,Index,ReferenceData,NewsAndOverviewMetrcisAPIForTheCryptocurrencyIndustryRequest IndexV1HistoricalMessagesHour MimeNoContent GENERICRESPONSE MimeJSON
indexV1HistoricalMessagesHour (Market market) (Instrument instrument) =
  _mkRequest "GET" ["/index/v1/historical/messages/hour"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiKeyHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiKeyQuery)
    `addQuery` toQuery ("market", Just market)
    `addQuery` toQuery ("instrument", Just instrument)

data IndexV1HistoricalMessagesHour  

-- | /Optional Param/ "hour_ts" - Unix timestamp in seconds for the hour containing the index updates you are interested in. You can pass any timestamp in the hour but we will round it down the the full hour timestmap and return all index updates in that hour.
instance HasOptionalParam IndexV1HistoricalMessagesHour HourTs where
  applyOptionalParam req (HourTs xs) =
    req `addQuery` toQuery ("hour_ts", Just xs)

-- | /Optional Param/ "mapping_priority" - The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
instance HasOptionalParam IndexV1HistoricalMessagesHour MappingPriority where
  applyOptionalParam req (MappingPriority xs) =
    req `addQuery` toQuery ("mapping_priority", Just xs)

-- | /Optional Param/ "response_format" - The format of the data response in uppercase. It can be one of the following: JSON,CSV
instance HasOptionalParam IndexV1HistoricalMessagesHour ResponseFormat where
  applyOptionalParam req (ResponseFormat xs) =
    req `addQuery` toQuery ("response_format", Just xs)

-- | /Optional Param/ "return_404_on_empty_response" - If set to false (default) then when there are no items to return, you will get a response status code of 200 and an empty JSON array or a CSV file with just the header. If set to true then when there are no items you will get a 404 status code for both JSON and CSV response_formats.
instance HasOptionalParam IndexV1HistoricalMessagesHour Return404OnEmptyResponse where
  applyOptionalParam req (Return404OnEmptyResponse xs) =
    req `addQuery` toQuery ("return_404_on_empty_response", Just xs)
-- | @application/json@
instance Produces IndexV1HistoricalMessagesHour MimeJSON


-- *** indexV1HistoricalMinutes

-- | @GET \/index\/v1\/historical\/minutes@
-- 
indexV1HistoricalMinutes
  :: Market -- ^ "market" -  The exchange to obtain data from
  -> Instrument -- ^ "instrument" -  The mapped or unmapped instrument to retrieve on a specific market. We first check the instrument against the mapped list and then against the unmapped list          but you can use the mapping_priority param to check the unmapped list first.
  -> CryptoCompareMarket,Index,ReferenceData,NewsAndOverviewMetrcisAPIForTheCryptocurrencyIndustryRequest IndexV1HistoricalMinutes MimeNoContent GENERICRESPONSE MimeJSON
indexV1HistoricalMinutes (Market market) (Instrument instrument) =
  _mkRequest "GET" ["/index/v1/historical/minutes"]
    `addQuery` toQuery ("market", Just market)
    `addQuery` toQuery ("instrument", Just instrument)

data IndexV1HistoricalMinutes  

-- | /Optional Param/ "groups" - When requesting historical entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,OHLC,OHLC_MESSAGE,MESSAGE,VOLUME
instance HasOptionalParam IndexV1HistoricalMinutes GroupsText where
  applyOptionalParam req (GroupsText xs) =
    req `addQuery` toQueryColl CommaSeparated ("groups", Just xs)

-- | /Optional Param/ "limit" - The number of data points to return
instance HasOptionalParam IndexV1HistoricalMinutes Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "to_ts" - Returns historical data before this unix timestamp. If you want to get all the available historical data, you can use limit=2000 and keep going back in time using the to_ts param. You can then keep requesting batches using: &limit=2000&to_ts={the earliest unix timestamp received}
instance HasOptionalParam IndexV1HistoricalMinutes ToTs where
  applyOptionalParam req (ToTs xs) =
    req `addQuery` toQuery ("to_ts", Just xs)

-- | /Optional Param/ "aggregate" - The number of points to aggregate for each returned value. E.g. passing 5 on a minute histo data endpoint will return data at 5 minute intervals. You are still limited to a maximum of 2000 minute points so the maximum you can get is 400 5 minutes interval entries
instance HasOptionalParam IndexV1HistoricalMinutes Aggregate where
  applyOptionalParam req (Aggregate xs) =
    req `addQuery` toQuery ("aggregate", Just xs)

-- | /Optional Param/ "fill" - Boolean value, if set to false or 0 we will not return data points for periods with no trading activity.
instance HasOptionalParam IndexV1HistoricalMinutes Fill where
  applyOptionalParam req (Fill xs) =
    req `addQuery` toQuery ("fill", Just xs)

-- | /Optional Param/ "mapping_priority" - The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
instance HasOptionalParam IndexV1HistoricalMinutes MappingPriority where
  applyOptionalParam req (MappingPriority xs) =
    req `addQuery` toQuery ("mapping_priority", Just xs)

-- | /Optional Param/ "response_format" - The format of the data response in uppercase. It can be one of the following: JSON,CSV
instance HasOptionalParam IndexV1HistoricalMinutes ResponseFormat where
  applyOptionalParam req (ResponseFormat xs) =
    req `addQuery` toQuery ("response_format", Just xs)
-- | @application/json@
instance Produces IndexV1HistoricalMinutes MimeJSON


-- *** indexV1LatestInstrumentMetadata

-- | @GET \/index\/v1\/latest\/instrument\/metadata@
-- 
indexV1LatestInstrumentMetadata
  :: Market -- ^ "market" -  The exchange to obtain data from
  -> Instruments -- ^ "instruments" -  A comma separated array of mapped and/or unmapped instruments to retrieve for a specific market (you can use either the instrument XXBTZUSD or mapped instrument (base - quote) BTC-USD on kraken as an example). We first check each instrument against the mapped list and then against the unmapped list but you can use the mapping_priority param to check the unmapped list first.
  -> CryptoCompareMarket,Index,ReferenceData,NewsAndOverviewMetrcisAPIForTheCryptocurrencyIndustryRequest IndexV1LatestInstrumentMetadata MimeNoContent GENERICRESPONSE MimeJSON
indexV1LatestInstrumentMetadata (Market market) (Instruments instruments) =
  _mkRequest "GET" ["/index/v1/latest/instrument/metadata"]
    `addQuery` toQuery ("market", Just market)
    `addQuery` toQueryColl CommaSeparated ("instruments", Just instruments)

data IndexV1LatestInstrumentMetadata  

-- | /Optional Param/ "groups" - When requesting metadata entries you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: STATUS,INTERNAL,GENERAL,MIGRATION,SOURCE
instance HasOptionalParam IndexV1LatestInstrumentMetadata GroupsText where
  applyOptionalParam req (GroupsText xs) =
    req `addQuery` toQueryColl CommaSeparated ("groups", Just xs)

-- | /Optional Param/ "mapping_priority" - The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
instance HasOptionalParam IndexV1LatestInstrumentMetadata MappingPriority where
  applyOptionalParam req (MappingPriority xs) =
    req `addQuery` toQuery ("mapping_priority", Just xs)
-- | @application/json@
instance Produces IndexV1LatestInstrumentMetadata MimeJSON


-- *** indexV1LatestTick

-- | @GET \/index\/v1\/latest\/tick@
-- 
indexV1LatestTick
  :: Market -- ^ "market" -  The exchange to obtain data from
  -> Instruments -- ^ "instruments" -  A comma separated array of mapped and/or unmapped instruments to retrieve for a specific market (you can use either the instrument XXBTZUSD or mapped instrument (base - quote) BTC-USD on kraken as an example). We first check each instrument against the mapped list and then against the unmapped list but you can use the mapping_priority param to check the unmapped list first.
  -> CryptoCompareMarket,Index,ReferenceData,NewsAndOverviewMetrcisAPIForTheCryptocurrencyIndustryRequest IndexV1LatestTick MimeNoContent GENERICRESPONSE MimeJSON
indexV1LatestTick (Market market) (Instruments instruments) =
  _mkRequest "GET" ["/index/v1/latest/tick"]
    `addQuery` toQuery ("market", Just market)
    `addQuery` toQueryColl CommaSeparated ("instruments", Just instruments)

data IndexV1LatestTick  

-- | /Optional Param/ "groups" - When requesting tick data you can fiter by specific groups of interest. To do so just pass the groups of interest into the URL as a comma separted list. If left empty it will get all data that you account is allowed to access. The groups available are: ID,VALUE,LAST_UPDATE,CURRENT_HOUR,CURRENT_DAY,CURRENT_WEEK,CURRENT_MONTH,CURRENT_YEAR,MOVING_24_HOUR,MOVING_7_DAY,MOVING_30_DAY,MOVING_90_DAY,MOVING_180_DAY,MOVING_365_DAY,LIFETIME
instance HasOptionalParam IndexV1LatestTick GroupsText where
  applyOptionalParam req (GroupsText xs) =
    req `addQuery` toQueryColl CommaSeparated ("groups", Just xs)

-- | /Optional Param/ "mapping_priority" - The mapping priority of the instrument. It is set to CHECK_MAPPED_FIRST by default. It can be one of the following: CHECK_MAPPED_FIRST,CHECK_UNMAPPED_FIRST
instance HasOptionalParam IndexV1LatestTick MappingPriority where
  applyOptionalParam req (MappingPriority xs) =
    req `addQuery` toQuery ("mapping_priority", Just xs)
-- | @application/json@
instance Produces IndexV1LatestTick MimeJSON


-- *** indexV1Markets

-- | @GET \/index\/v1\/markets@
-- 
indexV1Markets
  :: CryptoCompareMarket,Index,ReferenceData,NewsAndOverviewMetrcisAPIForTheCryptocurrencyIndustryRequest IndexV1Markets MimeNoContent GENERICRESPONSE MimeJSON
indexV1Markets =
  _mkRequest "GET" ["/index/v1/markets"]

data IndexV1Markets  

-- | /Optional Param/ "market" - The exchange to obtain data from
instance HasOptionalParam IndexV1Markets Market where
  applyOptionalParam req (Market xs) =
    req `addQuery` toQuery ("market", Just xs)
-- | @application/json@
instance Produces IndexV1Markets MimeJSON


-- *** indexV1MarketsInstruments

-- | @GET \/index\/v1\/markets\/instruments@
-- 
indexV1MarketsInstruments
  :: CryptoCompareMarket,Index,ReferenceData,NewsAndOverviewMetrcisAPIForTheCryptocurrencyIndustryRequest IndexV1MarketsInstruments MimeNoContent GENERICRESPONSE MimeJSON
indexV1MarketsInstruments =
  _mkRequest "GET" ["/index/v1/markets/instruments"]

data IndexV1MarketsInstruments  

-- | /Optional Param/ "market" - The exchange to obtain data from
instance HasOptionalParam IndexV1MarketsInstruments Market where
  applyOptionalParam req (Market xs) =
    req `addQuery` toQuery ("market", Just xs)

-- | /Optional Param/ "instrument" - The mapped instrument to retrieve on a specific market.
instance HasOptionalParam IndexV1MarketsInstruments Instrument where
  applyOptionalParam req (Instrument xs) =
    req `addQuery` toQuery ("instrument", Just xs)

-- | /Optional Param/ "instrument_status" - The status of the instrument, can be one of the following: ACTIVE, IGNORED, RETIRED, EXPIRED
instance HasOptionalParam IndexV1MarketsInstruments InstrumentStatus where
  applyOptionalParam req (InstrumentStatus xs) =
    req `addQuery` toQueryColl CommaSeparated ("instrument_status", Just xs)
-- | @application/json@
instance Produces IndexV1MarketsInstruments MimeJSON


-- *** indexV1MarketsInstrumentsUnmapped

-- | @GET \/index\/v1\/markets\/instruments\/unmapped@
-- 
indexV1MarketsInstrumentsUnmapped
  :: CryptoCompareMarket,Index,ReferenceData,NewsAndOverviewMetrcisAPIForTheCryptocurrencyIndustryRequest IndexV1MarketsInstrumentsUnmapped MimeNoContent GENERICRESPONSE MimeJSON
indexV1MarketsInstrumentsUnmapped =
  _mkRequest "GET" ["/index/v1/markets/instruments/unmapped"]

data IndexV1MarketsInstrumentsUnmapped  

-- | /Optional Param/ "market" - The exchange to obtain data from
instance HasOptionalParam IndexV1MarketsInstrumentsUnmapped Market where
  applyOptionalParam req (Market xs) =
    req `addQuery` toQuery ("market", Just xs)

-- | /Optional Param/ "instrument" - The unmapped instrument to retrieve on a specific market.
instance HasOptionalParam IndexV1MarketsInstrumentsUnmapped Instrument where
  applyOptionalParam req (Instrument xs) =
    req `addQuery` toQuery ("instrument", Just xs)

-- | /Optional Param/ "instrument_status" - The status of the instrument, can be one of the following: ACTIVE, IGNORED, RETIRED, EXPIRED
instance HasOptionalParam IndexV1MarketsInstrumentsUnmapped InstrumentStatus where
  applyOptionalParam req (InstrumentStatus xs) =
    req `addQuery` toQueryColl CommaSeparated ("instrument_status", Just xs)
-- | @application/json@
instance Produces IndexV1MarketsInstrumentsUnmapped MimeJSON

