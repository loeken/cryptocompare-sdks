# Automatically generated by openapi-generator (https://openapi-generator.tech)
# Please update as you see appropriate

context("Test SPOTINSTRUMENTTRADE")

model_instance <- SPOTINSTRUMENTTRADE$new()

test_that("BASE", {
  # tests for the property `BASE` (character)
  # The mapped from asset (base / symbol/ coin). Only available on instruments that have been mapped (e.g. BTC).

  # uncomment below to test the property
  #expect_equal(model.instance$`BASE`, "EXPECTED_RESULT")
})

test_that("CCSEQ", {
  # tests for the property `CCSEQ` (integer)
  # Our internal sequence number for this trade, this is unique per market / exchange and trading pair. Should always be increasing by 1 for each new trade we discover, not in chronological order.

  # uncomment below to test the property
  #expect_equal(model.instance$`CCSEQ`, "EXPECTED_RESULT")
})

test_that("ID", {
  # tests for the property `ID` (character)
  # The trade ID as reported by the market / exchange. If the exchange does not provide a trade ID, this will be the timestamp of the trade + a number from 0 - 999. This preserves uniqueness, assuming there would never be more than 999 trades in any given second.

  # uncomment below to test the property
  #expect_equal(model.instance$`ID`, "EXPECTED_RESULT")
})

test_that("INSTRUMENT", {
  # tests for the property `INSTRUMENT` (character)
  # The unmapped instrument ID as given by the exchange (e.g. BTCUSD, BTC_USD, XBT-ZUSD, BTC-USD).

  # uncomment below to test the property
  #expect_equal(model.instance$`INSTRUMENT`, "EXPECTED_RESULT")
})

test_that("MAPPED_INSTRUMENT", {
  # tests for the property `MAPPED_INSTRUMENT` (character)
  # The mapped instrument ID, as derived from our mapping rules. This takes the form: \&quot;BASE-QUOTE\&quot;. Only available on instruments that have been mapped (e.g. BTC-USD).

  # uncomment below to test the property
  #expect_equal(model.instance$`MAPPED_INSTRUMENT`, "EXPECTED_RESULT")
})

test_that("MARKET", {
  # tests for the property `MARKET` (character)
  # The market / exchange under consideration (e.g. Coinbase, Kraken, etc.).

  # uncomment below to test the property
  #expect_equal(model.instance$`MARKET`, "EXPECTED_RESULT")
})

test_that("PRICE", {
  # tests for the property `PRICE` (integer)
  # The price in the to instrument (quote / counter symbol / coin) of the trade. For a BTC-USD trade, this is how much was paid for one BTC in USD. For futures, this will be the price of the contract.

  # uncomment below to test the property
  #expect_equal(model.instance$`PRICE`, "EXPECTED_RESULT")
})

test_that("QUANTITY", {
  # tests for the property `QUANTITY` (integer)
  # The volume of the trade, given in the from instrument (base symbol / coin/ contract). For a spot BTC-USD trade, this is how much BTC was traded at the trade price. For a futures BTCUSDPERP, this is the BTC equivalent for the contracts traded.

  # uncomment below to test the property
  #expect_equal(model.instance$`QUANTITY`, "EXPECTED_RESULT")
})

test_that("QUOTE", {
  # tests for the property `QUOTE` (character)
  # The mapped to asset (quote / counter symbol / coin). Only available on instruments that have been mapped (e.g. USD).

  # uncomment below to test the property
  #expect_equal(model.instance$`QUOTE`, "EXPECTED_RESULT")
})

test_that("QUOTE_QUANTITY", {
  # tests for the property `QUOTE_QUANTITY` (integer)
  # The volume of the trade, given in the to instrument (quote / counter symbol / coin). This is equivalent to QUANTITY * PRICE. E.g. for a BTC-USD trade, this is how much USD was paid in total for the volume of BTC traded. For futures this is the quote currency equivalent for the contracts traded.

  # uncomment below to test the property
  #expect_equal(model.instance$`QUOTE_QUANTITY`, "EXPECTED_RESULT")
})

test_that("RECEIVED_TIMESTAMP", {
  # tests for the property `RECEIVED_TIMESTAMP` (integer)
  # The timestamp in seconds that the trade was received. This varies from the trade taking place on the market by a few millisconds to a few seconds depending on the market / exchange API options / rate limits.

  # uncomment below to test the property
  #expect_equal(model.instance$`RECEIVED_TIMESTAMP`, "EXPECTED_RESULT")
})

test_that("RECEIVED_TIMESTAMP_NS", {
  # tests for the property `RECEIVED_TIMESTAMP_NS` (integer)
  # The nanosecond part of the received timestamp.

  # uncomment below to test the property
  #expect_equal(model.instance$`RECEIVED_TIMESTAMP_NS`, "EXPECTED_RESULT")
})

test_that("SIDE", {
  # tests for the property `SIDE` (character)
  # The side of the trade: SELL, BUY or UNKNOWN. If the exchange / api does not provide a side, \&quot;UNKNOWN\&quot; will be returned.

  # uncomment below to test the property
  #expect_equal(model.instance$`SIDE`, "EXPECTED_RESULT")
})

test_that("SOURCE", {
  # tests for the property `SOURCE` (character)
  # The source of the trade update: POLLING, STREAMING, GO, BLOB etc.

  # uncomment below to test the property
  #expect_equal(model.instance$`SOURCE`, "EXPECTED_RESULT")
})

test_that("TIMESTAMP", {
  # tests for the property `TIMESTAMP` (integer)
  # The timestamp in seconds as reported by the market / exchange or the received timestamp if the market / exchange does not provide one.

  # uncomment below to test the property
  #expect_equal(model.instance$`TIMESTAMP`, "EXPECTED_RESULT")
})

test_that("TIMESTAMP_NS", {
  # tests for the property `TIMESTAMP_NS` (integer)
  # The nanosecond part of the reported timestamp.

  # uncomment below to test the property
  #expect_equal(model.instance$`TIMESTAMP_NS`, "EXPECTED_RESULT")
})

test_that("TYPE", {
  # tests for the property `TYPE` (character)
  # The type of the message.

  # uncomment below to test the property
  #expect_equal(model.instance$`TYPE`, "EXPECTED_RESULT")
})
