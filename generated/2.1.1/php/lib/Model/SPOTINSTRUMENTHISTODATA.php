<?php
/**
 * SPOTINSTRUMENTHISTODATA
 *
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * CryptoCompare Market, Index, Reference Data, News and Overview Metrcis API for the Cryptocurrency Industry
 *
 * CryptoCompare is the world's leading digital asset data company, providing services that cater to corporate, government and retail clients. Our main reference index is widely recognized as a reliable benchmark, and we have been authorized by the Financial Conduct Authority (FCA) in the United Kingdom to operate as a benchmark administrator. In addition to catering to corporate, government, and retail clients, we offer a range of services including comprehensive market data for cryptocurrency exchanges in both the centralized and decentralized finance sectors, as well as individual asset data on custodians, supported platforms, and privacy solutions. Our offerings include price, volume, trade, and orderbook updates, as well as historical OHLCV data.
 *
 * The version of the OpenAPI document: 2.1.1
 * Contact: data@cryptocompare.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.3.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Model;

use \ArrayAccess;
use \OpenAPI\Client\ObjectSerializer;

/**
 * SPOTINSTRUMENTHISTODATA Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class SPOTINSTRUMENTHISTODATA implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'SPOT_INSTRUMENT_HISTO_DATA';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'base' => 'string',
        'close' => 'int',
        'first_trade_price' => 'int',
        'first_trade_timestamp' => 'int',
        'high' => 'int',
        'high_trade_price' => 'int',
        'high_trade_timestamp' => 'int',
        'instrument' => 'string',
        'last_trade_price' => 'int',
        'last_trade_timestamp' => 'int',
        'low' => 'int',
        'low_trade_price' => 'int',
        'low_trade_timestamp' => 'int',
        'mapped_instrument' => 'string',
        'market' => 'string',
        'open' => 'int',
        'quote' => 'string',
        'quote_volume' => 'int',
        'quote_volume_buy' => 'int',
        'quote_volume_sell' => 'int',
        'quote_volume_unknown' => 'int',
        'timestamp' => 'int',
        'total_trades' => 'int',
        'total_trades_buy' => 'int',
        'total_trades_sell' => 'int',
        'total_trades_unknown' => 'int',
        'type' => 'string',
        'unit' => 'string',
        'volume' => 'int',
        'volume_buy' => 'int',
        'volume_sell' => 'int',
        'volume_unknown' => 'int'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'base' => null,
        'close' => null,
        'first_trade_price' => null,
        'first_trade_timestamp' => null,
        'high' => null,
        'high_trade_price' => null,
        'high_trade_timestamp' => null,
        'instrument' => null,
        'last_trade_price' => null,
        'last_trade_timestamp' => null,
        'low' => null,
        'low_trade_price' => null,
        'low_trade_timestamp' => null,
        'mapped_instrument' => null,
        'market' => null,
        'open' => null,
        'quote' => null,
        'quote_volume' => null,
        'quote_volume_buy' => null,
        'quote_volume_sell' => null,
        'quote_volume_unknown' => null,
        'timestamp' => null,
        'total_trades' => null,
        'total_trades_buy' => null,
        'total_trades_sell' => null,
        'total_trades_unknown' => null,
        'type' => null,
        'unit' => null,
        'volume' => null,
        'volume_buy' => null,
        'volume_sell' => null,
        'volume_unknown' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'base' => false,
		'close' => false,
		'first_trade_price' => false,
		'first_trade_timestamp' => false,
		'high' => false,
		'high_trade_price' => false,
		'high_trade_timestamp' => false,
		'instrument' => false,
		'last_trade_price' => false,
		'last_trade_timestamp' => false,
		'low' => false,
		'low_trade_price' => false,
		'low_trade_timestamp' => false,
		'mapped_instrument' => false,
		'market' => false,
		'open' => false,
		'quote' => false,
		'quote_volume' => false,
		'quote_volume_buy' => false,
		'quote_volume_sell' => false,
		'quote_volume_unknown' => false,
		'timestamp' => false,
		'total_trades' => false,
		'total_trades_buy' => false,
		'total_trades_sell' => false,
		'total_trades_unknown' => false,
		'type' => false,
		'unit' => false,
		'volume' => false,
		'volume_buy' => false,
		'volume_sell' => false,
		'volume_unknown' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'base' => 'BASE',
        'close' => 'CLOSE',
        'first_trade_price' => 'FIRST_TRADE_PRICE',
        'first_trade_timestamp' => 'FIRST_TRADE_TIMESTAMP',
        'high' => 'HIGH',
        'high_trade_price' => 'HIGH_TRADE_PRICE',
        'high_trade_timestamp' => 'HIGH_TRADE_TIMESTAMP',
        'instrument' => 'INSTRUMENT',
        'last_trade_price' => 'LAST_TRADE_PRICE',
        'last_trade_timestamp' => 'LAST_TRADE_TIMESTAMP',
        'low' => 'LOW',
        'low_trade_price' => 'LOW_TRADE_PRICE',
        'low_trade_timestamp' => 'LOW_TRADE_TIMESTAMP',
        'mapped_instrument' => 'MAPPED_INSTRUMENT',
        'market' => 'MARKET',
        'open' => 'OPEN',
        'quote' => 'QUOTE',
        'quote_volume' => 'QUOTE_VOLUME',
        'quote_volume_buy' => 'QUOTE_VOLUME_BUY',
        'quote_volume_sell' => 'QUOTE_VOLUME_SELL',
        'quote_volume_unknown' => 'QUOTE_VOLUME_UNKNOWN',
        'timestamp' => 'TIMESTAMP',
        'total_trades' => 'TOTAL_TRADES',
        'total_trades_buy' => 'TOTAL_TRADES_BUY',
        'total_trades_sell' => 'TOTAL_TRADES_SELL',
        'total_trades_unknown' => 'TOTAL_TRADES_UNKNOWN',
        'type' => 'TYPE',
        'unit' => 'UNIT',
        'volume' => 'VOLUME',
        'volume_buy' => 'VOLUME_BUY',
        'volume_sell' => 'VOLUME_SELL',
        'volume_unknown' => 'VOLUME_UNKNOWN'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'base' => 'setBase',
        'close' => 'setClose',
        'first_trade_price' => 'setFirstTradePrice',
        'first_trade_timestamp' => 'setFirstTradeTimestamp',
        'high' => 'setHigh',
        'high_trade_price' => 'setHighTradePrice',
        'high_trade_timestamp' => 'setHighTradeTimestamp',
        'instrument' => 'setInstrument',
        'last_trade_price' => 'setLastTradePrice',
        'last_trade_timestamp' => 'setLastTradeTimestamp',
        'low' => 'setLow',
        'low_trade_price' => 'setLowTradePrice',
        'low_trade_timestamp' => 'setLowTradeTimestamp',
        'mapped_instrument' => 'setMappedInstrument',
        'market' => 'setMarket',
        'open' => 'setOpen',
        'quote' => 'setQuote',
        'quote_volume' => 'setQuoteVolume',
        'quote_volume_buy' => 'setQuoteVolumeBuy',
        'quote_volume_sell' => 'setQuoteVolumeSell',
        'quote_volume_unknown' => 'setQuoteVolumeUnknown',
        'timestamp' => 'setTimestamp',
        'total_trades' => 'setTotalTrades',
        'total_trades_buy' => 'setTotalTradesBuy',
        'total_trades_sell' => 'setTotalTradesSell',
        'total_trades_unknown' => 'setTotalTradesUnknown',
        'type' => 'setType',
        'unit' => 'setUnit',
        'volume' => 'setVolume',
        'volume_buy' => 'setVolumeBuy',
        'volume_sell' => 'setVolumeSell',
        'volume_unknown' => 'setVolumeUnknown'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'base' => 'getBase',
        'close' => 'getClose',
        'first_trade_price' => 'getFirstTradePrice',
        'first_trade_timestamp' => 'getFirstTradeTimestamp',
        'high' => 'getHigh',
        'high_trade_price' => 'getHighTradePrice',
        'high_trade_timestamp' => 'getHighTradeTimestamp',
        'instrument' => 'getInstrument',
        'last_trade_price' => 'getLastTradePrice',
        'last_trade_timestamp' => 'getLastTradeTimestamp',
        'low' => 'getLow',
        'low_trade_price' => 'getLowTradePrice',
        'low_trade_timestamp' => 'getLowTradeTimestamp',
        'mapped_instrument' => 'getMappedInstrument',
        'market' => 'getMarket',
        'open' => 'getOpen',
        'quote' => 'getQuote',
        'quote_volume' => 'getQuoteVolume',
        'quote_volume_buy' => 'getQuoteVolumeBuy',
        'quote_volume_sell' => 'getQuoteVolumeSell',
        'quote_volume_unknown' => 'getQuoteVolumeUnknown',
        'timestamp' => 'getTimestamp',
        'total_trades' => 'getTotalTrades',
        'total_trades_buy' => 'getTotalTradesBuy',
        'total_trades_sell' => 'getTotalTradesSell',
        'total_trades_unknown' => 'getTotalTradesUnknown',
        'type' => 'getType',
        'unit' => 'getUnit',
        'volume' => 'getVolume',
        'volume_buy' => 'getVolumeBuy',
        'volume_sell' => 'getVolumeSell',
        'volume_unknown' => 'getVolumeUnknown'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }


    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->setIfExists('base', $data ?? [], null);
        $this->setIfExists('close', $data ?? [], null);
        $this->setIfExists('first_trade_price', $data ?? [], null);
        $this->setIfExists('first_trade_timestamp', $data ?? [], null);
        $this->setIfExists('high', $data ?? [], null);
        $this->setIfExists('high_trade_price', $data ?? [], null);
        $this->setIfExists('high_trade_timestamp', $data ?? [], null);
        $this->setIfExists('instrument', $data ?? [], null);
        $this->setIfExists('last_trade_price', $data ?? [], null);
        $this->setIfExists('last_trade_timestamp', $data ?? [], null);
        $this->setIfExists('low', $data ?? [], null);
        $this->setIfExists('low_trade_price', $data ?? [], null);
        $this->setIfExists('low_trade_timestamp', $data ?? [], null);
        $this->setIfExists('mapped_instrument', $data ?? [], null);
        $this->setIfExists('market', $data ?? [], null);
        $this->setIfExists('open', $data ?? [], null);
        $this->setIfExists('quote', $data ?? [], null);
        $this->setIfExists('quote_volume', $data ?? [], null);
        $this->setIfExists('quote_volume_buy', $data ?? [], null);
        $this->setIfExists('quote_volume_sell', $data ?? [], null);
        $this->setIfExists('quote_volume_unknown', $data ?? [], null);
        $this->setIfExists('timestamp', $data ?? [], null);
        $this->setIfExists('total_trades', $data ?? [], null);
        $this->setIfExists('total_trades_buy', $data ?? [], null);
        $this->setIfExists('total_trades_sell', $data ?? [], null);
        $this->setIfExists('total_trades_unknown', $data ?? [], null);
        $this->setIfExists('type', $data ?? [], null);
        $this->setIfExists('unit', $data ?? [], null);
        $this->setIfExists('volume', $data ?? [], null);
        $this->setIfExists('volume_buy', $data ?? [], null);
        $this->setIfExists('volume_sell', $data ?? [], null);
        $this->setIfExists('volume_unknown', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets base
     *
     * @return string|null
     */
    public function getBase()
    {
        return $this->container['base'];
    }

    /**
     * Sets base
     *
     * @param string|null $base The mapped from asset (base / symbol/ coin) (e.g. BTC). Only available on instruments that have mapping.
     *
     * @return self
     */
    public function setBase($base)
    {
        if (is_null($base)) {
            throw new \InvalidArgumentException('non-nullable base cannot be null');
        }
        $this->container['base'] = $base;

        return $this;
    }

    /**
     * Gets close
     *
     * @return int|null
     */
    public function getClose()
    {
        return $this->container['close'];
    }

    /**
     * Sets close
     *
     * @param int|null $close The price of the last trade in this time period. If there were no trades in the time period, the open price will be given.
     *
     * @return self
     */
    public function setClose($close)
    {
        if (is_null($close)) {
            throw new \InvalidArgumentException('non-nullable close cannot be null');
        }
        $this->container['close'] = $close;

        return $this;
    }

    /**
     * Gets first_trade_price
     *
     * @return int|null
     */
    public function getFirstTradePrice()
    {
        return $this->container['first_trade_price'];
    }

    /**
     * Sets first_trade_price
     *
     * @param int|null $first_trade_price The price of the first trade in the time period. This is only available when there is at least one trade in the time period.
     *
     * @return self
     */
    public function setFirstTradePrice($first_trade_price)
    {
        if (is_null($first_trade_price)) {
            throw new \InvalidArgumentException('non-nullable first_trade_price cannot be null');
        }
        $this->container['first_trade_price'] = $first_trade_price;

        return $this;
    }

    /**
     * Gets first_trade_timestamp
     *
     * @return int|null
     */
    public function getFirstTradeTimestamp()
    {
        return $this->container['first_trade_timestamp'];
    }

    /**
     * Sets first_trade_timestamp
     *
     * @param int|null $first_trade_timestamp The timestamp, in seconds, of the first trade in this time perio. This is only available when there is at least one trade in the time period.
     *
     * @return self
     */
    public function setFirstTradeTimestamp($first_trade_timestamp)
    {
        if (is_null($first_trade_timestamp)) {
            throw new \InvalidArgumentException('non-nullable first_trade_timestamp cannot be null');
        }
        $this->container['first_trade_timestamp'] = $first_trade_timestamp;

        return $this;
    }

    /**
     * Gets high
     *
     * @return int|null
     */
    public function getHigh()
    {
        return $this->container['high'];
    }

    /**
     * Sets high
     *
     * @param int|null $high The highest trade price in the time period. If there were no trades in the time period, the open price will be given.
     *
     * @return self
     */
    public function setHigh($high)
    {
        if (is_null($high)) {
            throw new \InvalidArgumentException('non-nullable high cannot be null');
        }
        $this->container['high'] = $high;

        return $this;
    }

    /**
     * Gets high_trade_price
     *
     * @return int|null
     */
    public function getHighTradePrice()
    {
        return $this->container['high_trade_price'];
    }

    /**
     * Sets high_trade_price
     *
     * @param int|null $high_trade_price The highest value of the trades in the time period. This is only available when there is at least one trade in the time period.
     *
     * @return self
     */
    public function setHighTradePrice($high_trade_price)
    {
        if (is_null($high_trade_price)) {
            throw new \InvalidArgumentException('non-nullable high_trade_price cannot be null');
        }
        $this->container['high_trade_price'] = $high_trade_price;

        return $this;
    }

    /**
     * Gets high_trade_timestamp
     *
     * @return int|null
     */
    public function getHighTradeTimestamp()
    {
        return $this->container['high_trade_timestamp'];
    }

    /**
     * Sets high_trade_timestamp
     *
     * @param int|null $high_trade_timestamp The timestamp, in seconds, of the highest trade in the time period. This is only available when there is at least one trade in the time period.
     *
     * @return self
     */
    public function setHighTradeTimestamp($high_trade_timestamp)
    {
        if (is_null($high_trade_timestamp)) {
            throw new \InvalidArgumentException('non-nullable high_trade_timestamp cannot be null');
        }
        $this->container['high_trade_timestamp'] = $high_trade_timestamp;

        return $this;
    }

    /**
     * Gets instrument
     *
     * @return string|null
     */
    public function getInstrument()
    {
        return $this->container['instrument'];
    }

    /**
     * Sets instrument
     *
     * @param string|null $instrument The unmapped instrument ID
     *
     * @return self
     */
    public function setInstrument($instrument)
    {
        if (is_null($instrument)) {
            throw new \InvalidArgumentException('non-nullable instrument cannot be null');
        }
        $this->container['instrument'] = $instrument;

        return $this;
    }

    /**
     * Gets last_trade_price
     *
     * @return int|null
     */
    public function getLastTradePrice()
    {
        return $this->container['last_trade_price'];
    }

    /**
     * Sets last_trade_price
     *
     * @param int|null $last_trade_price The last trade price in the time period. This is only available when there is at least one trade in the time period.
     *
     * @return self
     */
    public function setLastTradePrice($last_trade_price)
    {
        if (is_null($last_trade_price)) {
            throw new \InvalidArgumentException('non-nullable last_trade_price cannot be null');
        }
        $this->container['last_trade_price'] = $last_trade_price;

        return $this;
    }

    /**
     * Gets last_trade_timestamp
     *
     * @return int|null
     */
    public function getLastTradeTimestamp()
    {
        return $this->container['last_trade_timestamp'];
    }

    /**
     * Sets last_trade_timestamp
     *
     * @param int|null $last_trade_timestamp The timestamp, in seconds, of the last trade in this time period. This is only available when there is at least one trade in the time period.
     *
     * @return self
     */
    public function setLastTradeTimestamp($last_trade_timestamp)
    {
        if (is_null($last_trade_timestamp)) {
            throw new \InvalidArgumentException('non-nullable last_trade_timestamp cannot be null');
        }
        $this->container['last_trade_timestamp'] = $last_trade_timestamp;

        return $this;
    }

    /**
     * Gets low
     *
     * @return int|null
     */
    public function getLow()
    {
        return $this->container['low'];
    }

    /**
     * Sets low
     *
     * @param int|null $low The lowest trade price in the time period. If there were no trades in the time period, the open price will be given.
     *
     * @return self
     */
    public function setLow($low)
    {
        if (is_null($low)) {
            throw new \InvalidArgumentException('non-nullable low cannot be null');
        }
        $this->container['low'] = $low;

        return $this;
    }

    /**
     * Gets low_trade_price
     *
     * @return int|null
     */
    public function getLowTradePrice()
    {
        return $this->container['low_trade_price'];
    }

    /**
     * Sets low_trade_price
     *
     * @param int|null $low_trade_price The lowest value of the trades in the time period. This is only available when there is at least one trade in the time period.
     *
     * @return self
     */
    public function setLowTradePrice($low_trade_price)
    {
        if (is_null($low_trade_price)) {
            throw new \InvalidArgumentException('non-nullable low_trade_price cannot be null');
        }
        $this->container['low_trade_price'] = $low_trade_price;

        return $this;
    }

    /**
     * Gets low_trade_timestamp
     *
     * @return int|null
     */
    public function getLowTradeTimestamp()
    {
        return $this->container['low_trade_timestamp'];
    }

    /**
     * Sets low_trade_timestamp
     *
     * @param int|null $low_trade_timestamp The timestamp, in seconds, of the lowest trade in the time period. This is only available when there is at least one trade in the time period.
     *
     * @return self
     */
    public function setLowTradeTimestamp($low_trade_timestamp)
    {
        if (is_null($low_trade_timestamp)) {
            throw new \InvalidArgumentException('non-nullable low_trade_timestamp cannot be null');
        }
        $this->container['low_trade_timestamp'] = $low_trade_timestamp;

        return $this;
    }

    /**
     * Gets mapped_instrument
     *
     * @return string|null
     */
    public function getMappedInstrument()
    {
        return $this->container['mapped_instrument'];
    }

    /**
     * Sets mapped_instrument
     *
     * @param string|null $mapped_instrument The instrument ID, as derived from our mapping rules. This takes the form \"BASE-QUOTE\" (e.g. BTC-USD). Only available on instruments that have been mapped.
     *
     * @return self
     */
    public function setMappedInstrument($mapped_instrument)
    {
        if (is_null($mapped_instrument)) {
            throw new \InvalidArgumentException('non-nullable mapped_instrument cannot be null');
        }
        $this->container['mapped_instrument'] = $mapped_instrument;

        return $this;
    }

    /**
     * Gets market
     *
     * @return string|null
     */
    public function getMarket()
    {
        return $this->container['market'];
    }

    /**
     * Sets market
     *
     * @param string|null $market The market / exchange under consideration (e.g. gemini, kraken, coinbase, etc).
     *
     * @return self
     */
    public function setMarket($market)
    {
        if (is_null($market)) {
            throw new \InvalidArgumentException('non-nullable market cannot be null');
        }
        $this->container['market'] = $market;

        return $this;
    }

    /**
     * Gets open
     *
     * @return int|null
     */
    public function getOpen()
    {
        return $this->container['open'];
    }

    /**
     * Sets open
     *
     * @param int|null $open The open price for the historical period, this is based on the closest trade before the period start.
     *
     * @return self
     */
    public function setOpen($open)
    {
        if (is_null($open)) {
            throw new \InvalidArgumentException('non-nullable open cannot be null');
        }
        $this->container['open'] = $open;

        return $this;
    }

    /**
     * Gets quote
     *
     * @return string|null
     */
    public function getQuote()
    {
        return $this->container['quote'];
    }

    /**
     * Sets quote
     *
     * @param string|null $quote The mapped to asset (quote / counter symbol / coin) (e.g. USD). Only available on instruments that have mapping.
     *
     * @return self
     */
    public function setQuote($quote)
    {
        if (is_null($quote)) {
            throw new \InvalidArgumentException('non-nullable quote cannot be null');
        }
        $this->container['quote'] = $quote;

        return $this;
    }

    /**
     * Gets quote_volume
     *
     * @return int|null
     */
    public function getQuoteVolume()
    {
        return $this->container['quote_volume'];
    }

    /**
     * Sets quote_volume
     *
     * @param int|null $quote_volume The sum of all the trade volumes in the To asset (quote/counter symbol/coin) for the time period. If there were no trades in the time period, 0 will be returned.
     *
     * @return self
     */
    public function setQuoteVolume($quote_volume)
    {
        if (is_null($quote_volume)) {
            throw new \InvalidArgumentException('non-nullable quote_volume cannot be null');
        }
        $this->container['quote_volume'] = $quote_volume;

        return $this;
    }

    /**
     * Gets quote_volume_buy
     *
     * @return int|null
     */
    public function getQuoteVolumeBuy()
    {
        return $this->container['quote_volume_buy'];
    }

    /**
     * Sets quote_volume_buy
     *
     * @param int|null $quote_volume_buy The sum of all the BUY trade volumes in the to asset (quote/counter symbol/coin) for the time period.
     *
     * @return self
     */
    public function setQuoteVolumeBuy($quote_volume_buy)
    {
        if (is_null($quote_volume_buy)) {
            throw new \InvalidArgumentException('non-nullable quote_volume_buy cannot be null');
        }
        $this->container['quote_volume_buy'] = $quote_volume_buy;

        return $this;
    }

    /**
     * Gets quote_volume_sell
     *
     * @return int|null
     */
    public function getQuoteVolumeSell()
    {
        return $this->container['quote_volume_sell'];
    }

    /**
     * Sets quote_volume_sell
     *
     * @param int|null $quote_volume_sell The sum of all the SELL trade volumes in the To asset (quote/counter symbol/coin) for the time period.
     *
     * @return self
     */
    public function setQuoteVolumeSell($quote_volume_sell)
    {
        if (is_null($quote_volume_sell)) {
            throw new \InvalidArgumentException('non-nullable quote_volume_sell cannot be null');
        }
        $this->container['quote_volume_sell'] = $quote_volume_sell;

        return $this;
    }

    /**
     * Gets quote_volume_unknown
     *
     * @return int|null
     */
    public function getQuoteVolumeUnknown()
    {
        return $this->container['quote_volume_unknown'];
    }

    /**
     * Sets quote_volume_unknown
     *
     * @param int|null $quote_volume_unknown The sum of all the UNKNOWN trade volumes in the To asset (quote/counter symbol/coin) for the time period.
     *
     * @return self
     */
    public function setQuoteVolumeUnknown($quote_volume_unknown)
    {
        if (is_null($quote_volume_unknown)) {
            throw new \InvalidArgumentException('non-nullable quote_volume_unknown cannot be null');
        }
        $this->container['quote_volume_unknown'] = $quote_volume_unknown;

        return $this;
    }

    /**
     * Gets timestamp
     *
     * @return int|null
     */
    public function getTimestamp()
    {
        return $this->container['timestamp'];
    }

    /**
     * Sets timestamp
     *
     * @param int|null $timestamp The timestamp in seconds of the beginning of the histo period. For minute it would be every minute at the beginning of the minute, for hour it would be the start of the hour and for daily it is 00:00 GMT.
     *
     * @return self
     */
    public function setTimestamp($timestamp)
    {
        if (is_null($timestamp)) {
            throw new \InvalidArgumentException('non-nullable timestamp cannot be null');
        }
        $this->container['timestamp'] = $timestamp;

        return $this;
    }

    /**
     * Gets total_trades
     *
     * @return int|null
     */
    public function getTotalTrades()
    {
        return $this->container['total_trades'];
    }

    /**
     * Sets total_trades
     *
     * @param int|null $total_trades The total number of trades seen in this time period. If there were no trades in the time period, 0 will be returned.
     *
     * @return self
     */
    public function setTotalTrades($total_trades)
    {
        if (is_null($total_trades)) {
            throw new \InvalidArgumentException('non-nullable total_trades cannot be null');
        }
        $this->container['total_trades'] = $total_trades;

        return $this;
    }

    /**
     * Gets total_trades_buy
     *
     * @return int|null
     */
    public function getTotalTradesBuy()
    {
        return $this->container['total_trades_buy'];
    }

    /**
     * Sets total_trades_buy
     *
     * @param int|null $total_trades_buy The total number of BUY trades seen in this time period. If there were no trades in the time period, 0 will be returned.
     *
     * @return self
     */
    public function setTotalTradesBuy($total_trades_buy)
    {
        if (is_null($total_trades_buy)) {
            throw new \InvalidArgumentException('non-nullable total_trades_buy cannot be null');
        }
        $this->container['total_trades_buy'] = $total_trades_buy;

        return $this;
    }

    /**
     * Gets total_trades_sell
     *
     * @return int|null
     */
    public function getTotalTradesSell()
    {
        return $this->container['total_trades_sell'];
    }

    /**
     * Sets total_trades_sell
     *
     * @param int|null $total_trades_sell The total number of SELL trades seen in this time period. If there were no trades in the time period, 0 will be returned.
     *
     * @return self
     */
    public function setTotalTradesSell($total_trades_sell)
    {
        if (is_null($total_trades_sell)) {
            throw new \InvalidArgumentException('non-nullable total_trades_sell cannot be null');
        }
        $this->container['total_trades_sell'] = $total_trades_sell;

        return $this;
    }

    /**
     * Gets total_trades_unknown
     *
     * @return int|null
     */
    public function getTotalTradesUnknown()
    {
        return $this->container['total_trades_unknown'];
    }

    /**
     * Sets total_trades_unknown
     *
     * @param int|null $total_trades_unknown The total number of UNKNOWN trades seen in this time period. If there were no trades in the time period, 0 will be returned.
     *
     * @return self
     */
    public function setTotalTradesUnknown($total_trades_unknown)
    {
        if (is_null($total_trades_unknown)) {
            throw new \InvalidArgumentException('non-nullable total_trades_unknown cannot be null');
        }
        $this->container['total_trades_unknown'] = $total_trades_unknown;

        return $this;
    }

    /**
     * Gets type
     *
     * @return string|null
     */
    public function getType()
    {
        return $this->container['type'];
    }

    /**
     * Sets type
     *
     * @param string|null $type The type of the message.
     *
     * @return self
     */
    public function setType($type)
    {
        if (is_null($type)) {
            throw new \InvalidArgumentException('non-nullable type cannot be null');
        }
        $this->container['type'] = $type;

        return $this;
    }

    /**
     * Gets unit
     *
     * @return string|null
     */
    public function getUnit()
    {
        return $this->container['unit'];
    }

    /**
     * Sets unit
     *
     * @param string|null $unit The unit of the historical period update: MINUTE for minute, HOUR for hour and DAY for day.
     *
     * @return self
     */
    public function setUnit($unit)
    {
        if (is_null($unit)) {
            throw new \InvalidArgumentException('non-nullable unit cannot be null');
        }
        $this->container['unit'] = $unit;

        return $this;
    }

    /**
     * Gets volume
     *
     * @return int|null
     */
    public function getVolume()
    {
        return $this->container['volume'];
    }

    /**
     * Sets volume
     *
     * @param int|null $volume The sum of all the trade volumes in the from asset (base symbol / coin) for the time period. If there were no trades in the time period, 0 will be returned.
     *
     * @return self
     */
    public function setVolume($volume)
    {
        if (is_null($volume)) {
            throw new \InvalidArgumentException('non-nullable volume cannot be null');
        }
        $this->container['volume'] = $volume;

        return $this;
    }

    /**
     * Gets volume_buy
     *
     * @return int|null
     */
    public function getVolumeBuy()
    {
        return $this->container['volume_buy'];
    }

    /**
     * Sets volume_buy
     *
     * @param int|null $volume_buy The sum of all the BUY trade volumes in the from asset (base symbol / coin) for the time period.
     *
     * @return self
     */
    public function setVolumeBuy($volume_buy)
    {
        if (is_null($volume_buy)) {
            throw new \InvalidArgumentException('non-nullable volume_buy cannot be null');
        }
        $this->container['volume_buy'] = $volume_buy;

        return $this;
    }

    /**
     * Gets volume_sell
     *
     * @return int|null
     */
    public function getVolumeSell()
    {
        return $this->container['volume_sell'];
    }

    /**
     * Sets volume_sell
     *
     * @param int|null $volume_sell The sum of all the SELL trade volumes in the from asset (base symbol / coin) for the time period.
     *
     * @return self
     */
    public function setVolumeSell($volume_sell)
    {
        if (is_null($volume_sell)) {
            throw new \InvalidArgumentException('non-nullable volume_sell cannot be null');
        }
        $this->container['volume_sell'] = $volume_sell;

        return $this;
    }

    /**
     * Gets volume_unknown
     *
     * @return int|null
     */
    public function getVolumeUnknown()
    {
        return $this->container['volume_unknown'];
    }

    /**
     * Sets volume_unknown
     *
     * @param int|null $volume_unknown The sum of all the UNKNOWN trade volumes in the from asset (base symbol / coin) for the time period.
     *
     * @return self
     */
    public function setVolumeUnknown($volume_unknown)
    {
        if (is_null($volume_unknown)) {
            throw new \InvalidArgumentException('non-nullable volume_unknown cannot be null');
        }
        $this->container['volume_unknown'] = $volume_unknown;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


