<?php
/**
 * SPOTINSTRUMENTTRADE
 *
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * CryptoCompare Market, Index, Reference Data, News and Overview Metrcis API for the Cryptocurrency Industry
 *
 * CryptoCompare is the world's leading digital asset data company, providing services that cater to corporate, government and retail clients. Our main reference index is widely recognized as a reliable benchmark, and we have been authorized by the Financial Conduct Authority (FCA) in the United Kingdom to operate as a benchmark administrator. In addition to catering to corporate, government, and retail clients, we offer a range of services including comprehensive market data for cryptocurrency exchanges in both the centralized and decentralized finance sectors, as well as individual asset data on custodians, supported platforms, and privacy solutions. Our offerings include price, volume, trade, and orderbook updates, as well as historical OHLCV data.
 *
 * The version of the OpenAPI document: 2.1.1
 * Contact: data@cryptocompare.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.3.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Model;

use \ArrayAccess;
use \OpenAPI\Client\ObjectSerializer;

/**
 * SPOTINSTRUMENTTRADE Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class SPOTINSTRUMENTTRADE implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'SPOT_INSTRUMENT_TRADE';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'base' => 'string',
        'ccseq' => 'int',
        'id' => 'string',
        'instrument' => 'string',
        'mapped_instrument' => 'string',
        'market' => 'string',
        'price' => 'int',
        'quantity' => 'int',
        'quote' => 'string',
        'quote_quantity' => 'int',
        'received_timestamp' => 'int',
        'received_timestamp_ns' => 'int',
        'side' => 'string',
        'source' => 'string',
        'timestamp' => 'int',
        'timestamp_ns' => 'int',
        'type' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'base' => null,
        'ccseq' => null,
        'id' => null,
        'instrument' => null,
        'mapped_instrument' => null,
        'market' => null,
        'price' => null,
        'quantity' => null,
        'quote' => null,
        'quote_quantity' => null,
        'received_timestamp' => null,
        'received_timestamp_ns' => null,
        'side' => null,
        'source' => null,
        'timestamp' => null,
        'timestamp_ns' => null,
        'type' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'base' => false,
		'ccseq' => false,
		'id' => false,
		'instrument' => false,
		'mapped_instrument' => false,
		'market' => false,
		'price' => false,
		'quantity' => false,
		'quote' => false,
		'quote_quantity' => false,
		'received_timestamp' => false,
		'received_timestamp_ns' => false,
		'side' => false,
		'source' => false,
		'timestamp' => false,
		'timestamp_ns' => false,
		'type' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'base' => 'BASE',
        'ccseq' => 'CCSEQ',
        'id' => 'ID',
        'instrument' => 'INSTRUMENT',
        'mapped_instrument' => 'MAPPED_INSTRUMENT',
        'market' => 'MARKET',
        'price' => 'PRICE',
        'quantity' => 'QUANTITY',
        'quote' => 'QUOTE',
        'quote_quantity' => 'QUOTE_QUANTITY',
        'received_timestamp' => 'RECEIVED_TIMESTAMP',
        'received_timestamp_ns' => 'RECEIVED_TIMESTAMP_NS',
        'side' => 'SIDE',
        'source' => 'SOURCE',
        'timestamp' => 'TIMESTAMP',
        'timestamp_ns' => 'TIMESTAMP_NS',
        'type' => 'TYPE'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'base' => 'setBase',
        'ccseq' => 'setCcseq',
        'id' => 'setId',
        'instrument' => 'setInstrument',
        'mapped_instrument' => 'setMappedInstrument',
        'market' => 'setMarket',
        'price' => 'setPrice',
        'quantity' => 'setQuantity',
        'quote' => 'setQuote',
        'quote_quantity' => 'setQuoteQuantity',
        'received_timestamp' => 'setReceivedTimestamp',
        'received_timestamp_ns' => 'setReceivedTimestampNs',
        'side' => 'setSide',
        'source' => 'setSource',
        'timestamp' => 'setTimestamp',
        'timestamp_ns' => 'setTimestampNs',
        'type' => 'setType'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'base' => 'getBase',
        'ccseq' => 'getCcseq',
        'id' => 'getId',
        'instrument' => 'getInstrument',
        'mapped_instrument' => 'getMappedInstrument',
        'market' => 'getMarket',
        'price' => 'getPrice',
        'quantity' => 'getQuantity',
        'quote' => 'getQuote',
        'quote_quantity' => 'getQuoteQuantity',
        'received_timestamp' => 'getReceivedTimestamp',
        'received_timestamp_ns' => 'getReceivedTimestampNs',
        'side' => 'getSide',
        'source' => 'getSource',
        'timestamp' => 'getTimestamp',
        'timestamp_ns' => 'getTimestampNs',
        'type' => 'getType'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }


    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->setIfExists('base', $data ?? [], null);
        $this->setIfExists('ccseq', $data ?? [], null);
        $this->setIfExists('id', $data ?? [], null);
        $this->setIfExists('instrument', $data ?? [], null);
        $this->setIfExists('mapped_instrument', $data ?? [], null);
        $this->setIfExists('market', $data ?? [], null);
        $this->setIfExists('price', $data ?? [], null);
        $this->setIfExists('quantity', $data ?? [], null);
        $this->setIfExists('quote', $data ?? [], null);
        $this->setIfExists('quote_quantity', $data ?? [], null);
        $this->setIfExists('received_timestamp', $data ?? [], null);
        $this->setIfExists('received_timestamp_ns', $data ?? [], null);
        $this->setIfExists('side', $data ?? [], null);
        $this->setIfExists('source', $data ?? [], null);
        $this->setIfExists('timestamp', $data ?? [], null);
        $this->setIfExists('timestamp_ns', $data ?? [], null);
        $this->setIfExists('type', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets base
     *
     * @return string|null
     */
    public function getBase()
    {
        return $this->container['base'];
    }

    /**
     * Sets base
     *
     * @param string|null $base The mapped from asset (base / symbol/ coin). Only available on instruments that have been mapped (e.g. BTC).
     *
     * @return self
     */
    public function setBase($base)
    {
        if (is_null($base)) {
            throw new \InvalidArgumentException('non-nullable base cannot be null');
        }
        $this->container['base'] = $base;

        return $this;
    }

    /**
     * Gets ccseq
     *
     * @return int|null
     */
    public function getCcseq()
    {
        return $this->container['ccseq'];
    }

    /**
     * Sets ccseq
     *
     * @param int|null $ccseq Our internal sequence number for this trade, this is unique per market / exchange and trading pair. Should always be increasing by 1 for each new trade we discover, not in chronological order.
     *
     * @return self
     */
    public function setCcseq($ccseq)
    {
        if (is_null($ccseq)) {
            throw new \InvalidArgumentException('non-nullable ccseq cannot be null');
        }
        $this->container['ccseq'] = $ccseq;

        return $this;
    }

    /**
     * Gets id
     *
     * @return string|null
     */
    public function getId()
    {
        return $this->container['id'];
    }

    /**
     * Sets id
     *
     * @param string|null $id The trade ID as reported by the market / exchange. If the exchange does not provide a trade ID, this will be the timestamp of the trade + a number from 0 - 999. This preserves uniqueness, assuming there would never be more than 999 trades in any given second.
     *
     * @return self
     */
    public function setId($id)
    {
        if (is_null($id)) {
            throw new \InvalidArgumentException('non-nullable id cannot be null');
        }
        $this->container['id'] = $id;

        return $this;
    }

    /**
     * Gets instrument
     *
     * @return string|null
     */
    public function getInstrument()
    {
        return $this->container['instrument'];
    }

    /**
     * Sets instrument
     *
     * @param string|null $instrument The unmapped instrument ID as given by the exchange (e.g. BTCUSD, BTC_USD, XBT-ZUSD, BTC-USD).
     *
     * @return self
     */
    public function setInstrument($instrument)
    {
        if (is_null($instrument)) {
            throw new \InvalidArgumentException('non-nullable instrument cannot be null');
        }
        $this->container['instrument'] = $instrument;

        return $this;
    }

    /**
     * Gets mapped_instrument
     *
     * @return string|null
     */
    public function getMappedInstrument()
    {
        return $this->container['mapped_instrument'];
    }

    /**
     * Sets mapped_instrument
     *
     * @param string|null $mapped_instrument The mapped instrument ID, as derived from our mapping rules. This takes the form: \"BASE-QUOTE\". Only available on instruments that have been mapped (e.g. BTC-USD).
     *
     * @return self
     */
    public function setMappedInstrument($mapped_instrument)
    {
        if (is_null($mapped_instrument)) {
            throw new \InvalidArgumentException('non-nullable mapped_instrument cannot be null');
        }
        $this->container['mapped_instrument'] = $mapped_instrument;

        return $this;
    }

    /**
     * Gets market
     *
     * @return string|null
     */
    public function getMarket()
    {
        return $this->container['market'];
    }

    /**
     * Sets market
     *
     * @param string|null $market The market / exchange under consideration (e.g. Coinbase, Kraken, etc.).
     *
     * @return self
     */
    public function setMarket($market)
    {
        if (is_null($market)) {
            throw new \InvalidArgumentException('non-nullable market cannot be null');
        }
        $this->container['market'] = $market;

        return $this;
    }

    /**
     * Gets price
     *
     * @return int|null
     */
    public function getPrice()
    {
        return $this->container['price'];
    }

    /**
     * Sets price
     *
     * @param int|null $price The price in the to instrument (quote / counter symbol / coin) of the trade. For a BTC-USD trade, this is how much was paid for one BTC in USD. For futures, this will be the price of the contract.
     *
     * @return self
     */
    public function setPrice($price)
    {
        if (is_null($price)) {
            throw new \InvalidArgumentException('non-nullable price cannot be null');
        }
        $this->container['price'] = $price;

        return $this;
    }

    /**
     * Gets quantity
     *
     * @return int|null
     */
    public function getQuantity()
    {
        return $this->container['quantity'];
    }

    /**
     * Sets quantity
     *
     * @param int|null $quantity The volume of the trade, given in the from instrument (base symbol / coin/ contract). For a spot BTC-USD trade, this is how much BTC was traded at the trade price. For a futures BTCUSDPERP, this is the BTC equivalent for the contracts traded.
     *
     * @return self
     */
    public function setQuantity($quantity)
    {
        if (is_null($quantity)) {
            throw new \InvalidArgumentException('non-nullable quantity cannot be null');
        }
        $this->container['quantity'] = $quantity;

        return $this;
    }

    /**
     * Gets quote
     *
     * @return string|null
     */
    public function getQuote()
    {
        return $this->container['quote'];
    }

    /**
     * Sets quote
     *
     * @param string|null $quote The mapped to asset (quote / counter symbol / coin). Only available on instruments that have been mapped (e.g. USD).
     *
     * @return self
     */
    public function setQuote($quote)
    {
        if (is_null($quote)) {
            throw new \InvalidArgumentException('non-nullable quote cannot be null');
        }
        $this->container['quote'] = $quote;

        return $this;
    }

    /**
     * Gets quote_quantity
     *
     * @return int|null
     */
    public function getQuoteQuantity()
    {
        return $this->container['quote_quantity'];
    }

    /**
     * Sets quote_quantity
     *
     * @param int|null $quote_quantity The volume of the trade, given in the to instrument (quote / counter symbol / coin). This is equivalent to QUANTITY * PRICE. E.g. for a BTC-USD trade, this is how much USD was paid in total for the volume of BTC traded. For futures this is the quote currency equivalent for the contracts traded.
     *
     * @return self
     */
    public function setQuoteQuantity($quote_quantity)
    {
        if (is_null($quote_quantity)) {
            throw new \InvalidArgumentException('non-nullable quote_quantity cannot be null');
        }
        $this->container['quote_quantity'] = $quote_quantity;

        return $this;
    }

    /**
     * Gets received_timestamp
     *
     * @return int|null
     */
    public function getReceivedTimestamp()
    {
        return $this->container['received_timestamp'];
    }

    /**
     * Sets received_timestamp
     *
     * @param int|null $received_timestamp The timestamp in seconds that the trade was received. This varies from the trade taking place on the market by a few millisconds to a few seconds depending on the market / exchange API options / rate limits.
     *
     * @return self
     */
    public function setReceivedTimestamp($received_timestamp)
    {
        if (is_null($received_timestamp)) {
            throw new \InvalidArgumentException('non-nullable received_timestamp cannot be null');
        }
        $this->container['received_timestamp'] = $received_timestamp;

        return $this;
    }

    /**
     * Gets received_timestamp_ns
     *
     * @return int|null
     */
    public function getReceivedTimestampNs()
    {
        return $this->container['received_timestamp_ns'];
    }

    /**
     * Sets received_timestamp_ns
     *
     * @param int|null $received_timestamp_ns The nanosecond part of the received timestamp.
     *
     * @return self
     */
    public function setReceivedTimestampNs($received_timestamp_ns)
    {
        if (is_null($received_timestamp_ns)) {
            throw new \InvalidArgumentException('non-nullable received_timestamp_ns cannot be null');
        }
        $this->container['received_timestamp_ns'] = $received_timestamp_ns;

        return $this;
    }

    /**
     * Gets side
     *
     * @return string|null
     */
    public function getSide()
    {
        return $this->container['side'];
    }

    /**
     * Sets side
     *
     * @param string|null $side The side of the trade: SELL, BUY or UNKNOWN. If the exchange / api does not provide a side, \"UNKNOWN\" will be returned.
     *
     * @return self
     */
    public function setSide($side)
    {
        if (is_null($side)) {
            throw new \InvalidArgumentException('non-nullable side cannot be null');
        }
        $this->container['side'] = $side;

        return $this;
    }

    /**
     * Gets source
     *
     * @return string|null
     */
    public function getSource()
    {
        return $this->container['source'];
    }

    /**
     * Sets source
     *
     * @param string|null $source The source of the trade update: POLLING, STREAMING, GO, BLOB etc.
     *
     * @return self
     */
    public function setSource($source)
    {
        if (is_null($source)) {
            throw new \InvalidArgumentException('non-nullable source cannot be null');
        }
        $this->container['source'] = $source;

        return $this;
    }

    /**
     * Gets timestamp
     *
     * @return int|null
     */
    public function getTimestamp()
    {
        return $this->container['timestamp'];
    }

    /**
     * Sets timestamp
     *
     * @param int|null $timestamp The timestamp in seconds as reported by the market / exchange or the received timestamp if the market / exchange does not provide one.
     *
     * @return self
     */
    public function setTimestamp($timestamp)
    {
        if (is_null($timestamp)) {
            throw new \InvalidArgumentException('non-nullable timestamp cannot be null');
        }
        $this->container['timestamp'] = $timestamp;

        return $this;
    }

    /**
     * Gets timestamp_ns
     *
     * @return int|null
     */
    public function getTimestampNs()
    {
        return $this->container['timestamp_ns'];
    }

    /**
     * Sets timestamp_ns
     *
     * @param int|null $timestamp_ns The nanosecond part of the reported timestamp.
     *
     * @return self
     */
    public function setTimestampNs($timestamp_ns)
    {
        if (is_null($timestamp_ns)) {
            throw new \InvalidArgumentException('non-nullable timestamp_ns cannot be null');
        }
        $this->container['timestamp_ns'] = $timestamp_ns;

        return $this;
    }

    /**
     * Gets type
     *
     * @return string|null
     */
    public function getType()
    {
        return $this->container['type'];
    }

    /**
     * Sets type
     *
     * @param string|null $type The type of the message.
     *
     * @return self
     */
    public function setType($type)
    {
        if (is_null($type)) {
            throw new \InvalidArgumentException('non-nullable type cannot be null');
        }
        $this->container['type'] = $type;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


