/* tslint:disable */
/* eslint-disable */
/**
 * CryptoCompare Market, Index, Reference Data, News and Overview Metrcis API for the Cryptocurrency Industry
 * CryptoCompare is the world\'s leading digital asset data company, providing services that cater to corporate, government and retail clients. Our main reference index is widely recognized as a reliable benchmark, and we have been authorized by the Financial Conduct Authority (FCA) in the United Kingdom to operate as a benchmark administrator. In addition to catering to corporate, government, and retail clients, we offer a range of services including comprehensive market data for cryptocurrency exchanges in both the centralized and decentralized finance sectors, as well as individual asset data on custodians, supported platforms, and privacy solutions. Our offerings include price, volume, trade, and orderbook updates, as well as historical OHLCV data.
 *
 * The version of the OpenAPI document: 2.1.1
 * Contact: data@cryptocompare.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  GENERICRESPONSE,
} from '../models';
import {
    GENERICRESPONSEFromJSON,
    GENERICRESPONSEToJSON,
} from '../models';

export interface FuturesV1HistoricalDaysRequest {
    market: string;
    instrument: string;
    groups?: Array<string>;
    limit?: number;
    toTs?: number;
    aggregate?: number;
    fill?: boolean;
    mappingPriority?: FuturesV1HistoricalDaysMappingPriorityEnum;
    responseFormat?: FuturesV1HistoricalDaysResponseFormatEnum;
}

export interface FuturesV1HistoricalFundingRateDaysRequest {
    market: string;
    instrument: string;
    groups?: Array<string>;
    limit?: number;
    toTs?: number;
    aggregate?: number;
    fill?: boolean;
    mappingPriority?: FuturesV1HistoricalFundingRateDaysMappingPriorityEnum;
    responseFormat?: FuturesV1HistoricalFundingRateDaysResponseFormatEnum;
}

export interface FuturesV1HistoricalFundingRateHoursRequest {
    market: string;
    instrument: string;
    groups?: Array<string>;
    limit?: number;
    toTs?: number;
    aggregate?: number;
    fill?: boolean;
    mappingPriority?: FuturesV1HistoricalFundingRateHoursMappingPriorityEnum;
    responseFormat?: FuturesV1HistoricalFundingRateHoursResponseFormatEnum;
}

export interface FuturesV1HistoricalFundingRateMessagesRequest {
    market: string;
    instrument: string;
    afterTs?: number;
    lastCcseq?: number;
    limit?: number;
    mappingPriority?: FuturesV1HistoricalFundingRateMessagesMappingPriorityEnum;
    responseFormat?: FuturesV1HistoricalFundingRateMessagesResponseFormatEnum;
    return404OnEmptyResponse?: boolean;
}

export interface FuturesV1HistoricalFundingRateMessagesHourRequest {
    market: string;
    instrument: string;
    hourTs?: number;
    mappingPriority?: FuturesV1HistoricalFundingRateMessagesHourMappingPriorityEnum;
    responseFormat?: FuturesV1HistoricalFundingRateMessagesHourResponseFormatEnum;
    return404OnEmptyResponse?: boolean;
}

export interface FuturesV1HistoricalFundingRateMinutesRequest {
    market: string;
    instrument: string;
    groups?: Array<string>;
    limit?: number;
    toTs?: number;
    aggregate?: number;
    fill?: boolean;
    mappingPriority?: FuturesV1HistoricalFundingRateMinutesMappingPriorityEnum;
    responseFormat?: FuturesV1HistoricalFundingRateMinutesResponseFormatEnum;
}

export interface FuturesV1HistoricalHoursRequest {
    market: string;
    instrument: string;
    groups?: Array<string>;
    limit?: number;
    toTs?: number;
    aggregate?: number;
    fill?: boolean;
    mappingPriority?: FuturesV1HistoricalHoursMappingPriorityEnum;
    responseFormat?: FuturesV1HistoricalHoursResponseFormatEnum;
}

export interface FuturesV1HistoricalMinutesRequest {
    market: string;
    instrument: string;
    groups?: Array<string>;
    limit?: number;
    toTs?: number;
    aggregate?: number;
    fill?: boolean;
    mappingPriority?: FuturesV1HistoricalMinutesMappingPriorityEnum;
    responseFormat?: FuturesV1HistoricalMinutesResponseFormatEnum;
}

export interface FuturesV1HistoricalOpenInterestDaysRequest {
    market: string;
    instrument: string;
    groups?: Array<string>;
    limit?: number;
    toTs?: number;
    aggregate?: number;
    fill?: boolean;
    mappingPriority?: FuturesV1HistoricalOpenInterestDaysMappingPriorityEnum;
    responseFormat?: FuturesV1HistoricalOpenInterestDaysResponseFormatEnum;
}

export interface FuturesV1HistoricalOpenInterestHoursRequest {
    market: string;
    instrument: string;
    groups?: Array<string>;
    limit?: number;
    toTs?: number;
    aggregate?: number;
    fill?: boolean;
    mappingPriority?: FuturesV1HistoricalOpenInterestHoursMappingPriorityEnum;
    responseFormat?: FuturesV1HistoricalOpenInterestHoursResponseFormatEnum;
}

export interface FuturesV1HistoricalOpenInterestMessagesRequest {
    market: string;
    instrument: string;
    afterTs?: number;
    lastCcseq?: number;
    limit?: number;
    mappingPriority?: FuturesV1HistoricalOpenInterestMessagesMappingPriorityEnum;
    responseFormat?: FuturesV1HistoricalOpenInterestMessagesResponseFormatEnum;
    return404OnEmptyResponse?: boolean;
}

export interface FuturesV1HistoricalOpenInterestMessagesHourRequest {
    market: string;
    instrument: string;
    hourTs?: number;
    mappingPriority?: FuturesV1HistoricalOpenInterestMessagesHourMappingPriorityEnum;
    responseFormat?: FuturesV1HistoricalOpenInterestMessagesHourResponseFormatEnum;
    return404OnEmptyResponse?: boolean;
}

export interface FuturesV1HistoricalOpenInterestMinutesRequest {
    market: string;
    instrument: string;
    groups?: Array<string>;
    limit?: number;
    toTs?: number;
    aggregate?: number;
    fill?: boolean;
    mappingPriority?: FuturesV1HistoricalOpenInterestMinutesMappingPriorityEnum;
    responseFormat?: FuturesV1HistoricalOpenInterestMinutesResponseFormatEnum;
}

export interface FuturesV1HistoricalTradesRequest {
    market: string;
    instrument: string;
    afterTs?: number;
    lastCcseq?: number;
    limit?: number;
    mappingPriority?: FuturesV1HistoricalTradesMappingPriorityEnum;
    responseFormat?: FuturesV1HistoricalTradesResponseFormatEnum;
    return404OnEmptyResponse?: boolean;
}

export interface FuturesV1HistoricalTradesHourRequest {
    market: string;
    instrument: string;
    hourTs?: number;
    mappingPriority?: FuturesV1HistoricalTradesHourMappingPriorityEnum;
    responseFormat?: FuturesV1HistoricalTradesHourResponseFormatEnum;
    return404OnEmptyResponse?: boolean;
}

export interface FuturesV1LatestFundingRateTickRequest {
    market: string;
    instruments: Array<string>;
    groups?: Array<string>;
    mappingPriority?: FuturesV1LatestFundingRateTickMappingPriorityEnum;
}

export interface FuturesV1LatestInstrumentMetadataRequest {
    market: string;
    instruments: Array<string>;
    groups?: Array<string>;
    mappingPriority?: FuturesV1LatestInstrumentMetadataMappingPriorityEnum;
}

export interface FuturesV1LatestOpenInterestTickRequest {
    market: string;
    instruments: Array<string>;
    groups?: Array<string>;
    mappingPriority?: FuturesV1LatestOpenInterestTickMappingPriorityEnum;
}

export interface FuturesV1LatestTickRequest {
    market: string;
    instruments: Array<string>;
    groups?: Array<string>;
    mappingPriority?: FuturesV1LatestTickMappingPriorityEnum;
}

export interface FuturesV1MarketsRequest {
    market?: string;
}

export interface FuturesV1MarketsInstrumentsRequest {
    market?: string;
    instrument?: string;
    instrumentStatus?: Array<FuturesV1MarketsInstrumentsInstrumentStatusEnum>;
}

export interface FuturesV1MarketsInstrumentsUnmappedRequest {
    market?: string;
    instrument?: string;
    instrumentStatus?: Array<FuturesV1MarketsInstrumentsUnmappedInstrumentStatusEnum>;
}

export interface IndexV1HistoricalDaysRequest {
    market: string;
    instrument: string;
    groups?: Array<string>;
    limit?: number;
    toTs?: number;
    aggregate?: number;
    fill?: boolean;
    mappingPriority?: IndexV1HistoricalDaysMappingPriorityEnum;
    responseFormat?: IndexV1HistoricalDaysResponseFormatEnum;
}

export interface IndexV1HistoricalHoursRequest {
    market: string;
    instrument: string;
    groups?: Array<string>;
    limit?: number;
    toTs?: number;
    aggregate?: number;
    fill?: boolean;
    mappingPriority?: IndexV1HistoricalHoursMappingPriorityEnum;
    responseFormat?: IndexV1HistoricalHoursResponseFormatEnum;
}

export interface IndexV1HistoricalMessagesRequest {
    market: string;
    instrument: string;
    afterTs?: number;
    lastCcseq?: number;
    limit?: number;
    mappingPriority?: IndexV1HistoricalMessagesMappingPriorityEnum;
    responseFormat?: IndexV1HistoricalMessagesResponseFormatEnum;
    return404OnEmptyResponse?: boolean;
}

export interface IndexV1HistoricalMessagesHourRequest {
    market: string;
    instrument: string;
    hourTs?: number;
    mappingPriority?: IndexV1HistoricalMessagesHourMappingPriorityEnum;
    responseFormat?: IndexV1HistoricalMessagesHourResponseFormatEnum;
    return404OnEmptyResponse?: boolean;
}

export interface IndexV1HistoricalMinutesRequest {
    market: string;
    instrument: string;
    groups?: Array<string>;
    limit?: number;
    toTs?: number;
    aggregate?: number;
    fill?: boolean;
    mappingPriority?: IndexV1HistoricalMinutesMappingPriorityEnum;
    responseFormat?: IndexV1HistoricalMinutesResponseFormatEnum;
}

export interface IndexV1LatestInstrumentMetadataRequest {
    market: string;
    instruments: Array<string>;
    groups?: Array<string>;
    mappingPriority?: IndexV1LatestInstrumentMetadataMappingPriorityEnum;
}

export interface IndexV1LatestTickRequest {
    market: string;
    instruments: Array<string>;
    groups?: Array<string>;
    mappingPriority?: IndexV1LatestTickMappingPriorityEnum;
}

export interface IndexV1MarketsRequest {
    market?: string;
}

export interface IndexV1MarketsInstrumentsRequest {
    market?: string;
    instrument?: string;
    instrumentStatus?: Array<IndexV1MarketsInstrumentsInstrumentStatusEnum>;
}

export interface IndexV1MarketsInstrumentsUnmappedRequest {
    market?: string;
    instrument?: string;
    instrumentStatus?: Array<IndexV1MarketsInstrumentsUnmappedInstrumentStatusEnum>;
}

/**
 * 
 */
export class FuturesApi extends runtime.BaseAPI {

    /**
     */
    async futuresV1HistoricalDaysRaw(requestParameters: FuturesV1HistoricalDaysRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GENERICRESPONSE>> {
        if (requestParameters.market === null || requestParameters.market === undefined) {
            throw new runtime.RequiredError('market','Required parameter requestParameters.market was null or undefined when calling futuresV1HistoricalDays.');
        }

        if (requestParameters.instrument === null || requestParameters.instrument === undefined) {
            throw new runtime.RequiredError('instrument','Required parameter requestParameters.instrument was null or undefined when calling futuresV1HistoricalDays.');
        }

        const queryParameters: any = {};

        if (requestParameters.market !== undefined) {
            queryParameters['market'] = requestParameters.market;
        }

        if (requestParameters.instrument !== undefined) {
            queryParameters['instrument'] = requestParameters.instrument;
        }

        if (requestParameters.groups) {
            queryParameters['groups'] = requestParameters.groups.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.toTs !== undefined) {
            queryParameters['to_ts'] = requestParameters.toTs;
        }

        if (requestParameters.aggregate !== undefined) {
            queryParameters['aggregate'] = requestParameters.aggregate;
        }

        if (requestParameters.fill !== undefined) {
            queryParameters['fill'] = requestParameters.fill;
        }

        if (requestParameters.mappingPriority !== undefined) {
            queryParameters['mapping_priority'] = requestParameters.mappingPriority;
        }

        if (requestParameters.responseFormat !== undefined) {
            queryParameters['response_format'] = requestParameters.responseFormat;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/futures/v1/historical/days`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GENERICRESPONSEFromJSON(jsonValue));
    }

    /**
     */
    async futuresV1HistoricalDays(requestParameters: FuturesV1HistoricalDaysRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GENERICRESPONSE> {
        const response = await this.futuresV1HistoricalDaysRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async futuresV1HistoricalFundingRateDaysRaw(requestParameters: FuturesV1HistoricalFundingRateDaysRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GENERICRESPONSE>> {
        if (requestParameters.market === null || requestParameters.market === undefined) {
            throw new runtime.RequiredError('market','Required parameter requestParameters.market was null or undefined when calling futuresV1HistoricalFundingRateDays.');
        }

        if (requestParameters.instrument === null || requestParameters.instrument === undefined) {
            throw new runtime.RequiredError('instrument','Required parameter requestParameters.instrument was null or undefined when calling futuresV1HistoricalFundingRateDays.');
        }

        const queryParameters: any = {};

        if (requestParameters.market !== undefined) {
            queryParameters['market'] = requestParameters.market;
        }

        if (requestParameters.instrument !== undefined) {
            queryParameters['instrument'] = requestParameters.instrument;
        }

        if (requestParameters.groups) {
            queryParameters['groups'] = requestParameters.groups.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.toTs !== undefined) {
            queryParameters['to_ts'] = requestParameters.toTs;
        }

        if (requestParameters.aggregate !== undefined) {
            queryParameters['aggregate'] = requestParameters.aggregate;
        }

        if (requestParameters.fill !== undefined) {
            queryParameters['fill'] = requestParameters.fill;
        }

        if (requestParameters.mappingPriority !== undefined) {
            queryParameters['mapping_priority'] = requestParameters.mappingPriority;
        }

        if (requestParameters.responseFormat !== undefined) {
            queryParameters['response_format'] = requestParameters.responseFormat;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/futures/v1/historical/funding-rate/days`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GENERICRESPONSEFromJSON(jsonValue));
    }

    /**
     */
    async futuresV1HistoricalFundingRateDays(requestParameters: FuturesV1HistoricalFundingRateDaysRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GENERICRESPONSE> {
        const response = await this.futuresV1HistoricalFundingRateDaysRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async futuresV1HistoricalFundingRateHoursRaw(requestParameters: FuturesV1HistoricalFundingRateHoursRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GENERICRESPONSE>> {
        if (requestParameters.market === null || requestParameters.market === undefined) {
            throw new runtime.RequiredError('market','Required parameter requestParameters.market was null or undefined when calling futuresV1HistoricalFundingRateHours.');
        }

        if (requestParameters.instrument === null || requestParameters.instrument === undefined) {
            throw new runtime.RequiredError('instrument','Required parameter requestParameters.instrument was null or undefined when calling futuresV1HistoricalFundingRateHours.');
        }

        const queryParameters: any = {};

        if (requestParameters.market !== undefined) {
            queryParameters['market'] = requestParameters.market;
        }

        if (requestParameters.instrument !== undefined) {
            queryParameters['instrument'] = requestParameters.instrument;
        }

        if (requestParameters.groups) {
            queryParameters['groups'] = requestParameters.groups.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.toTs !== undefined) {
            queryParameters['to_ts'] = requestParameters.toTs;
        }

        if (requestParameters.aggregate !== undefined) {
            queryParameters['aggregate'] = requestParameters.aggregate;
        }

        if (requestParameters.fill !== undefined) {
            queryParameters['fill'] = requestParameters.fill;
        }

        if (requestParameters.mappingPriority !== undefined) {
            queryParameters['mapping_priority'] = requestParameters.mappingPriority;
        }

        if (requestParameters.responseFormat !== undefined) {
            queryParameters['response_format'] = requestParameters.responseFormat;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/futures/v1/historical/funding-rate/hours`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GENERICRESPONSEFromJSON(jsonValue));
    }

    /**
     */
    async futuresV1HistoricalFundingRateHours(requestParameters: FuturesV1HistoricalFundingRateHoursRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GENERICRESPONSE> {
        const response = await this.futuresV1HistoricalFundingRateHoursRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async futuresV1HistoricalFundingRateMessagesRaw(requestParameters: FuturesV1HistoricalFundingRateMessagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GENERICRESPONSE>> {
        if (requestParameters.market === null || requestParameters.market === undefined) {
            throw new runtime.RequiredError('market','Required parameter requestParameters.market was null or undefined when calling futuresV1HistoricalFundingRateMessages.');
        }

        if (requestParameters.instrument === null || requestParameters.instrument === undefined) {
            throw new runtime.RequiredError('instrument','Required parameter requestParameters.instrument was null or undefined when calling futuresV1HistoricalFundingRateMessages.');
        }

        const queryParameters: any = {};

        if (requestParameters.market !== undefined) {
            queryParameters['market'] = requestParameters.market;
        }

        if (requestParameters.instrument !== undefined) {
            queryParameters['instrument'] = requestParameters.instrument;
        }

        if (requestParameters.afterTs !== undefined) {
            queryParameters['after_ts'] = requestParameters.afterTs;
        }

        if (requestParameters.lastCcseq !== undefined) {
            queryParameters['last_ccseq'] = requestParameters.lastCcseq;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.mappingPriority !== undefined) {
            queryParameters['mapping_priority'] = requestParameters.mappingPriority;
        }

        if (requestParameters.responseFormat !== undefined) {
            queryParameters['response_format'] = requestParameters.responseFormat;
        }

        if (requestParameters.return404OnEmptyResponse !== undefined) {
            queryParameters['return_404_on_empty_response'] = requestParameters.return404OnEmptyResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // api_key_header authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key_query authentication
        }

        const response = await this.request({
            path: `/futures/v1/historical/funding-rate-messages`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GENERICRESPONSEFromJSON(jsonValue));
    }

    /**
     */
    async futuresV1HistoricalFundingRateMessages(requestParameters: FuturesV1HistoricalFundingRateMessagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GENERICRESPONSE> {
        const response = await this.futuresV1HistoricalFundingRateMessagesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async futuresV1HistoricalFundingRateMessagesHourRaw(requestParameters: FuturesV1HistoricalFundingRateMessagesHourRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GENERICRESPONSE>> {
        if (requestParameters.market === null || requestParameters.market === undefined) {
            throw new runtime.RequiredError('market','Required parameter requestParameters.market was null or undefined when calling futuresV1HistoricalFundingRateMessagesHour.');
        }

        if (requestParameters.instrument === null || requestParameters.instrument === undefined) {
            throw new runtime.RequiredError('instrument','Required parameter requestParameters.instrument was null or undefined when calling futuresV1HistoricalFundingRateMessagesHour.');
        }

        const queryParameters: any = {};

        if (requestParameters.market !== undefined) {
            queryParameters['market'] = requestParameters.market;
        }

        if (requestParameters.instrument !== undefined) {
            queryParameters['instrument'] = requestParameters.instrument;
        }

        if (requestParameters.hourTs !== undefined) {
            queryParameters['hour_ts'] = requestParameters.hourTs;
        }

        if (requestParameters.mappingPriority !== undefined) {
            queryParameters['mapping_priority'] = requestParameters.mappingPriority;
        }

        if (requestParameters.responseFormat !== undefined) {
            queryParameters['response_format'] = requestParameters.responseFormat;
        }

        if (requestParameters.return404OnEmptyResponse !== undefined) {
            queryParameters['return_404_on_empty_response'] = requestParameters.return404OnEmptyResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // api_key_header authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key_query authentication
        }

        const response = await this.request({
            path: `/futures/v1/historical/funding-rate-messages/hour`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GENERICRESPONSEFromJSON(jsonValue));
    }

    /**
     */
    async futuresV1HistoricalFundingRateMessagesHour(requestParameters: FuturesV1HistoricalFundingRateMessagesHourRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GENERICRESPONSE> {
        const response = await this.futuresV1HistoricalFundingRateMessagesHourRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async futuresV1HistoricalFundingRateMinutesRaw(requestParameters: FuturesV1HistoricalFundingRateMinutesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GENERICRESPONSE>> {
        if (requestParameters.market === null || requestParameters.market === undefined) {
            throw new runtime.RequiredError('market','Required parameter requestParameters.market was null or undefined when calling futuresV1HistoricalFundingRateMinutes.');
        }

        if (requestParameters.instrument === null || requestParameters.instrument === undefined) {
            throw new runtime.RequiredError('instrument','Required parameter requestParameters.instrument was null or undefined when calling futuresV1HistoricalFundingRateMinutes.');
        }

        const queryParameters: any = {};

        if (requestParameters.market !== undefined) {
            queryParameters['market'] = requestParameters.market;
        }

        if (requestParameters.instrument !== undefined) {
            queryParameters['instrument'] = requestParameters.instrument;
        }

        if (requestParameters.groups) {
            queryParameters['groups'] = requestParameters.groups.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.toTs !== undefined) {
            queryParameters['to_ts'] = requestParameters.toTs;
        }

        if (requestParameters.aggregate !== undefined) {
            queryParameters['aggregate'] = requestParameters.aggregate;
        }

        if (requestParameters.fill !== undefined) {
            queryParameters['fill'] = requestParameters.fill;
        }

        if (requestParameters.mappingPriority !== undefined) {
            queryParameters['mapping_priority'] = requestParameters.mappingPriority;
        }

        if (requestParameters.responseFormat !== undefined) {
            queryParameters['response_format'] = requestParameters.responseFormat;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/futures/v1/historical/funding-rate/minutes`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GENERICRESPONSEFromJSON(jsonValue));
    }

    /**
     */
    async futuresV1HistoricalFundingRateMinutes(requestParameters: FuturesV1HistoricalFundingRateMinutesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GENERICRESPONSE> {
        const response = await this.futuresV1HistoricalFundingRateMinutesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async futuresV1HistoricalHoursRaw(requestParameters: FuturesV1HistoricalHoursRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GENERICRESPONSE>> {
        if (requestParameters.market === null || requestParameters.market === undefined) {
            throw new runtime.RequiredError('market','Required parameter requestParameters.market was null or undefined when calling futuresV1HistoricalHours.');
        }

        if (requestParameters.instrument === null || requestParameters.instrument === undefined) {
            throw new runtime.RequiredError('instrument','Required parameter requestParameters.instrument was null or undefined when calling futuresV1HistoricalHours.');
        }

        const queryParameters: any = {};

        if (requestParameters.market !== undefined) {
            queryParameters['market'] = requestParameters.market;
        }

        if (requestParameters.instrument !== undefined) {
            queryParameters['instrument'] = requestParameters.instrument;
        }

        if (requestParameters.groups) {
            queryParameters['groups'] = requestParameters.groups.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.toTs !== undefined) {
            queryParameters['to_ts'] = requestParameters.toTs;
        }

        if (requestParameters.aggregate !== undefined) {
            queryParameters['aggregate'] = requestParameters.aggregate;
        }

        if (requestParameters.fill !== undefined) {
            queryParameters['fill'] = requestParameters.fill;
        }

        if (requestParameters.mappingPriority !== undefined) {
            queryParameters['mapping_priority'] = requestParameters.mappingPriority;
        }

        if (requestParameters.responseFormat !== undefined) {
            queryParameters['response_format'] = requestParameters.responseFormat;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/futures/v1/historical/hours`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GENERICRESPONSEFromJSON(jsonValue));
    }

    /**
     */
    async futuresV1HistoricalHours(requestParameters: FuturesV1HistoricalHoursRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GENERICRESPONSE> {
        const response = await this.futuresV1HistoricalHoursRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async futuresV1HistoricalMinutesRaw(requestParameters: FuturesV1HistoricalMinutesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GENERICRESPONSE>> {
        if (requestParameters.market === null || requestParameters.market === undefined) {
            throw new runtime.RequiredError('market','Required parameter requestParameters.market was null or undefined when calling futuresV1HistoricalMinutes.');
        }

        if (requestParameters.instrument === null || requestParameters.instrument === undefined) {
            throw new runtime.RequiredError('instrument','Required parameter requestParameters.instrument was null or undefined when calling futuresV1HistoricalMinutes.');
        }

        const queryParameters: any = {};

        if (requestParameters.market !== undefined) {
            queryParameters['market'] = requestParameters.market;
        }

        if (requestParameters.instrument !== undefined) {
            queryParameters['instrument'] = requestParameters.instrument;
        }

        if (requestParameters.groups) {
            queryParameters['groups'] = requestParameters.groups.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.toTs !== undefined) {
            queryParameters['to_ts'] = requestParameters.toTs;
        }

        if (requestParameters.aggregate !== undefined) {
            queryParameters['aggregate'] = requestParameters.aggregate;
        }

        if (requestParameters.fill !== undefined) {
            queryParameters['fill'] = requestParameters.fill;
        }

        if (requestParameters.mappingPriority !== undefined) {
            queryParameters['mapping_priority'] = requestParameters.mappingPriority;
        }

        if (requestParameters.responseFormat !== undefined) {
            queryParameters['response_format'] = requestParameters.responseFormat;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/futures/v1/historical/minutes`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GENERICRESPONSEFromJSON(jsonValue));
    }

    /**
     */
    async futuresV1HistoricalMinutes(requestParameters: FuturesV1HistoricalMinutesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GENERICRESPONSE> {
        const response = await this.futuresV1HistoricalMinutesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async futuresV1HistoricalOpenInterestDaysRaw(requestParameters: FuturesV1HistoricalOpenInterestDaysRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GENERICRESPONSE>> {
        if (requestParameters.market === null || requestParameters.market === undefined) {
            throw new runtime.RequiredError('market','Required parameter requestParameters.market was null or undefined when calling futuresV1HistoricalOpenInterestDays.');
        }

        if (requestParameters.instrument === null || requestParameters.instrument === undefined) {
            throw new runtime.RequiredError('instrument','Required parameter requestParameters.instrument was null or undefined when calling futuresV1HistoricalOpenInterestDays.');
        }

        const queryParameters: any = {};

        if (requestParameters.market !== undefined) {
            queryParameters['market'] = requestParameters.market;
        }

        if (requestParameters.instrument !== undefined) {
            queryParameters['instrument'] = requestParameters.instrument;
        }

        if (requestParameters.groups) {
            queryParameters['groups'] = requestParameters.groups.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.toTs !== undefined) {
            queryParameters['to_ts'] = requestParameters.toTs;
        }

        if (requestParameters.aggregate !== undefined) {
            queryParameters['aggregate'] = requestParameters.aggregate;
        }

        if (requestParameters.fill !== undefined) {
            queryParameters['fill'] = requestParameters.fill;
        }

        if (requestParameters.mappingPriority !== undefined) {
            queryParameters['mapping_priority'] = requestParameters.mappingPriority;
        }

        if (requestParameters.responseFormat !== undefined) {
            queryParameters['response_format'] = requestParameters.responseFormat;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/futures/v1/historical/open-interest/days`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GENERICRESPONSEFromJSON(jsonValue));
    }

    /**
     */
    async futuresV1HistoricalOpenInterestDays(requestParameters: FuturesV1HistoricalOpenInterestDaysRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GENERICRESPONSE> {
        const response = await this.futuresV1HistoricalOpenInterestDaysRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async futuresV1HistoricalOpenInterestHoursRaw(requestParameters: FuturesV1HistoricalOpenInterestHoursRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GENERICRESPONSE>> {
        if (requestParameters.market === null || requestParameters.market === undefined) {
            throw new runtime.RequiredError('market','Required parameter requestParameters.market was null or undefined when calling futuresV1HistoricalOpenInterestHours.');
        }

        if (requestParameters.instrument === null || requestParameters.instrument === undefined) {
            throw new runtime.RequiredError('instrument','Required parameter requestParameters.instrument was null or undefined when calling futuresV1HistoricalOpenInterestHours.');
        }

        const queryParameters: any = {};

        if (requestParameters.market !== undefined) {
            queryParameters['market'] = requestParameters.market;
        }

        if (requestParameters.instrument !== undefined) {
            queryParameters['instrument'] = requestParameters.instrument;
        }

        if (requestParameters.groups) {
            queryParameters['groups'] = requestParameters.groups.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.toTs !== undefined) {
            queryParameters['to_ts'] = requestParameters.toTs;
        }

        if (requestParameters.aggregate !== undefined) {
            queryParameters['aggregate'] = requestParameters.aggregate;
        }

        if (requestParameters.fill !== undefined) {
            queryParameters['fill'] = requestParameters.fill;
        }

        if (requestParameters.mappingPriority !== undefined) {
            queryParameters['mapping_priority'] = requestParameters.mappingPriority;
        }

        if (requestParameters.responseFormat !== undefined) {
            queryParameters['response_format'] = requestParameters.responseFormat;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/futures/v1/historical/open-interest/hours`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GENERICRESPONSEFromJSON(jsonValue));
    }

    /**
     */
    async futuresV1HistoricalOpenInterestHours(requestParameters: FuturesV1HistoricalOpenInterestHoursRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GENERICRESPONSE> {
        const response = await this.futuresV1HistoricalOpenInterestHoursRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async futuresV1HistoricalOpenInterestMessagesRaw(requestParameters: FuturesV1HistoricalOpenInterestMessagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GENERICRESPONSE>> {
        if (requestParameters.market === null || requestParameters.market === undefined) {
            throw new runtime.RequiredError('market','Required parameter requestParameters.market was null or undefined when calling futuresV1HistoricalOpenInterestMessages.');
        }

        if (requestParameters.instrument === null || requestParameters.instrument === undefined) {
            throw new runtime.RequiredError('instrument','Required parameter requestParameters.instrument was null or undefined when calling futuresV1HistoricalOpenInterestMessages.');
        }

        const queryParameters: any = {};

        if (requestParameters.market !== undefined) {
            queryParameters['market'] = requestParameters.market;
        }

        if (requestParameters.instrument !== undefined) {
            queryParameters['instrument'] = requestParameters.instrument;
        }

        if (requestParameters.afterTs !== undefined) {
            queryParameters['after_ts'] = requestParameters.afterTs;
        }

        if (requestParameters.lastCcseq !== undefined) {
            queryParameters['last_ccseq'] = requestParameters.lastCcseq;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.mappingPriority !== undefined) {
            queryParameters['mapping_priority'] = requestParameters.mappingPriority;
        }

        if (requestParameters.responseFormat !== undefined) {
            queryParameters['response_format'] = requestParameters.responseFormat;
        }

        if (requestParameters.return404OnEmptyResponse !== undefined) {
            queryParameters['return_404_on_empty_response'] = requestParameters.return404OnEmptyResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // api_key_header authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key_query authentication
        }

        const response = await this.request({
            path: `/futures/v1/historical/open-interest-messages`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GENERICRESPONSEFromJSON(jsonValue));
    }

    /**
     */
    async futuresV1HistoricalOpenInterestMessages(requestParameters: FuturesV1HistoricalOpenInterestMessagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GENERICRESPONSE> {
        const response = await this.futuresV1HistoricalOpenInterestMessagesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async futuresV1HistoricalOpenInterestMessagesHourRaw(requestParameters: FuturesV1HistoricalOpenInterestMessagesHourRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GENERICRESPONSE>> {
        if (requestParameters.market === null || requestParameters.market === undefined) {
            throw new runtime.RequiredError('market','Required parameter requestParameters.market was null or undefined when calling futuresV1HistoricalOpenInterestMessagesHour.');
        }

        if (requestParameters.instrument === null || requestParameters.instrument === undefined) {
            throw new runtime.RequiredError('instrument','Required parameter requestParameters.instrument was null or undefined when calling futuresV1HistoricalOpenInterestMessagesHour.');
        }

        const queryParameters: any = {};

        if (requestParameters.market !== undefined) {
            queryParameters['market'] = requestParameters.market;
        }

        if (requestParameters.instrument !== undefined) {
            queryParameters['instrument'] = requestParameters.instrument;
        }

        if (requestParameters.hourTs !== undefined) {
            queryParameters['hour_ts'] = requestParameters.hourTs;
        }

        if (requestParameters.mappingPriority !== undefined) {
            queryParameters['mapping_priority'] = requestParameters.mappingPriority;
        }

        if (requestParameters.responseFormat !== undefined) {
            queryParameters['response_format'] = requestParameters.responseFormat;
        }

        if (requestParameters.return404OnEmptyResponse !== undefined) {
            queryParameters['return_404_on_empty_response'] = requestParameters.return404OnEmptyResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // api_key_header authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key_query authentication
        }

        const response = await this.request({
            path: `/futures/v1/historical/open-interest-messages/hour`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GENERICRESPONSEFromJSON(jsonValue));
    }

    /**
     */
    async futuresV1HistoricalOpenInterestMessagesHour(requestParameters: FuturesV1HistoricalOpenInterestMessagesHourRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GENERICRESPONSE> {
        const response = await this.futuresV1HistoricalOpenInterestMessagesHourRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async futuresV1HistoricalOpenInterestMinutesRaw(requestParameters: FuturesV1HistoricalOpenInterestMinutesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GENERICRESPONSE>> {
        if (requestParameters.market === null || requestParameters.market === undefined) {
            throw new runtime.RequiredError('market','Required parameter requestParameters.market was null or undefined when calling futuresV1HistoricalOpenInterestMinutes.');
        }

        if (requestParameters.instrument === null || requestParameters.instrument === undefined) {
            throw new runtime.RequiredError('instrument','Required parameter requestParameters.instrument was null or undefined when calling futuresV1HistoricalOpenInterestMinutes.');
        }

        const queryParameters: any = {};

        if (requestParameters.market !== undefined) {
            queryParameters['market'] = requestParameters.market;
        }

        if (requestParameters.instrument !== undefined) {
            queryParameters['instrument'] = requestParameters.instrument;
        }

        if (requestParameters.groups) {
            queryParameters['groups'] = requestParameters.groups.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.toTs !== undefined) {
            queryParameters['to_ts'] = requestParameters.toTs;
        }

        if (requestParameters.aggregate !== undefined) {
            queryParameters['aggregate'] = requestParameters.aggregate;
        }

        if (requestParameters.fill !== undefined) {
            queryParameters['fill'] = requestParameters.fill;
        }

        if (requestParameters.mappingPriority !== undefined) {
            queryParameters['mapping_priority'] = requestParameters.mappingPriority;
        }

        if (requestParameters.responseFormat !== undefined) {
            queryParameters['response_format'] = requestParameters.responseFormat;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/futures/v1/historical/open-interest/minutes`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GENERICRESPONSEFromJSON(jsonValue));
    }

    /**
     */
    async futuresV1HistoricalOpenInterestMinutes(requestParameters: FuturesV1HistoricalOpenInterestMinutesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GENERICRESPONSE> {
        const response = await this.futuresV1HistoricalOpenInterestMinutesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async futuresV1HistoricalTradesRaw(requestParameters: FuturesV1HistoricalTradesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GENERICRESPONSE>> {
        if (requestParameters.market === null || requestParameters.market === undefined) {
            throw new runtime.RequiredError('market','Required parameter requestParameters.market was null or undefined when calling futuresV1HistoricalTrades.');
        }

        if (requestParameters.instrument === null || requestParameters.instrument === undefined) {
            throw new runtime.RequiredError('instrument','Required parameter requestParameters.instrument was null or undefined when calling futuresV1HistoricalTrades.');
        }

        const queryParameters: any = {};

        if (requestParameters.market !== undefined) {
            queryParameters['market'] = requestParameters.market;
        }

        if (requestParameters.instrument !== undefined) {
            queryParameters['instrument'] = requestParameters.instrument;
        }

        if (requestParameters.afterTs !== undefined) {
            queryParameters['after_ts'] = requestParameters.afterTs;
        }

        if (requestParameters.lastCcseq !== undefined) {
            queryParameters['last_ccseq'] = requestParameters.lastCcseq;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.mappingPriority !== undefined) {
            queryParameters['mapping_priority'] = requestParameters.mappingPriority;
        }

        if (requestParameters.responseFormat !== undefined) {
            queryParameters['response_format'] = requestParameters.responseFormat;
        }

        if (requestParameters.return404OnEmptyResponse !== undefined) {
            queryParameters['return_404_on_empty_response'] = requestParameters.return404OnEmptyResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // api_key_header authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key_query authentication
        }

        const response = await this.request({
            path: `/futures/v1/historical/trades`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GENERICRESPONSEFromJSON(jsonValue));
    }

    /**
     */
    async futuresV1HistoricalTrades(requestParameters: FuturesV1HistoricalTradesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GENERICRESPONSE> {
        const response = await this.futuresV1HistoricalTradesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async futuresV1HistoricalTradesHourRaw(requestParameters: FuturesV1HistoricalTradesHourRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GENERICRESPONSE>> {
        if (requestParameters.market === null || requestParameters.market === undefined) {
            throw new runtime.RequiredError('market','Required parameter requestParameters.market was null or undefined when calling futuresV1HistoricalTradesHour.');
        }

        if (requestParameters.instrument === null || requestParameters.instrument === undefined) {
            throw new runtime.RequiredError('instrument','Required parameter requestParameters.instrument was null or undefined when calling futuresV1HistoricalTradesHour.');
        }

        const queryParameters: any = {};

        if (requestParameters.market !== undefined) {
            queryParameters['market'] = requestParameters.market;
        }

        if (requestParameters.instrument !== undefined) {
            queryParameters['instrument'] = requestParameters.instrument;
        }

        if (requestParameters.hourTs !== undefined) {
            queryParameters['hour_ts'] = requestParameters.hourTs;
        }

        if (requestParameters.mappingPriority !== undefined) {
            queryParameters['mapping_priority'] = requestParameters.mappingPriority;
        }

        if (requestParameters.responseFormat !== undefined) {
            queryParameters['response_format'] = requestParameters.responseFormat;
        }

        if (requestParameters.return404OnEmptyResponse !== undefined) {
            queryParameters['return_404_on_empty_response'] = requestParameters.return404OnEmptyResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // api_key_header authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key_query authentication
        }

        const response = await this.request({
            path: `/futures/v1/historical/trades/hour`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GENERICRESPONSEFromJSON(jsonValue));
    }

    /**
     */
    async futuresV1HistoricalTradesHour(requestParameters: FuturesV1HistoricalTradesHourRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GENERICRESPONSE> {
        const response = await this.futuresV1HistoricalTradesHourRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async futuresV1LatestFundingRateTickRaw(requestParameters: FuturesV1LatestFundingRateTickRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GENERICRESPONSE>> {
        if (requestParameters.market === null || requestParameters.market === undefined) {
            throw new runtime.RequiredError('market','Required parameter requestParameters.market was null or undefined when calling futuresV1LatestFundingRateTick.');
        }

        if (requestParameters.instruments === null || requestParameters.instruments === undefined) {
            throw new runtime.RequiredError('instruments','Required parameter requestParameters.instruments was null or undefined when calling futuresV1LatestFundingRateTick.');
        }

        const queryParameters: any = {};

        if (requestParameters.market !== undefined) {
            queryParameters['market'] = requestParameters.market;
        }

        if (requestParameters.instruments) {
            queryParameters['instruments'] = requestParameters.instruments.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.groups) {
            queryParameters['groups'] = requestParameters.groups.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.mappingPriority !== undefined) {
            queryParameters['mapping_priority'] = requestParameters.mappingPriority;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/futures/v1/latest/funding-rate/tick`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GENERICRESPONSEFromJSON(jsonValue));
    }

    /**
     */
    async futuresV1LatestFundingRateTick(requestParameters: FuturesV1LatestFundingRateTickRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GENERICRESPONSE> {
        const response = await this.futuresV1LatestFundingRateTickRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async futuresV1LatestInstrumentMetadataRaw(requestParameters: FuturesV1LatestInstrumentMetadataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GENERICRESPONSE>> {
        if (requestParameters.market === null || requestParameters.market === undefined) {
            throw new runtime.RequiredError('market','Required parameter requestParameters.market was null or undefined when calling futuresV1LatestInstrumentMetadata.');
        }

        if (requestParameters.instruments === null || requestParameters.instruments === undefined) {
            throw new runtime.RequiredError('instruments','Required parameter requestParameters.instruments was null or undefined when calling futuresV1LatestInstrumentMetadata.');
        }

        const queryParameters: any = {};

        if (requestParameters.market !== undefined) {
            queryParameters['market'] = requestParameters.market;
        }

        if (requestParameters.instruments) {
            queryParameters['instruments'] = requestParameters.instruments.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.groups) {
            queryParameters['groups'] = requestParameters.groups.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.mappingPriority !== undefined) {
            queryParameters['mapping_priority'] = requestParameters.mappingPriority;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/futures/v1/latest/instrument/metadata`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GENERICRESPONSEFromJSON(jsonValue));
    }

    /**
     */
    async futuresV1LatestInstrumentMetadata(requestParameters: FuturesV1LatestInstrumentMetadataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GENERICRESPONSE> {
        const response = await this.futuresV1LatestInstrumentMetadataRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async futuresV1LatestOpenInterestTickRaw(requestParameters: FuturesV1LatestOpenInterestTickRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GENERICRESPONSE>> {
        if (requestParameters.market === null || requestParameters.market === undefined) {
            throw new runtime.RequiredError('market','Required parameter requestParameters.market was null or undefined when calling futuresV1LatestOpenInterestTick.');
        }

        if (requestParameters.instruments === null || requestParameters.instruments === undefined) {
            throw new runtime.RequiredError('instruments','Required parameter requestParameters.instruments was null or undefined when calling futuresV1LatestOpenInterestTick.');
        }

        const queryParameters: any = {};

        if (requestParameters.market !== undefined) {
            queryParameters['market'] = requestParameters.market;
        }

        if (requestParameters.instruments) {
            queryParameters['instruments'] = requestParameters.instruments.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.groups) {
            queryParameters['groups'] = requestParameters.groups.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.mappingPriority !== undefined) {
            queryParameters['mapping_priority'] = requestParameters.mappingPriority;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/futures/v1/latest/open-interest/tick`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GENERICRESPONSEFromJSON(jsonValue));
    }

    /**
     */
    async futuresV1LatestOpenInterestTick(requestParameters: FuturesV1LatestOpenInterestTickRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GENERICRESPONSE> {
        const response = await this.futuresV1LatestOpenInterestTickRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async futuresV1LatestTickRaw(requestParameters: FuturesV1LatestTickRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GENERICRESPONSE>> {
        if (requestParameters.market === null || requestParameters.market === undefined) {
            throw new runtime.RequiredError('market','Required parameter requestParameters.market was null or undefined when calling futuresV1LatestTick.');
        }

        if (requestParameters.instruments === null || requestParameters.instruments === undefined) {
            throw new runtime.RequiredError('instruments','Required parameter requestParameters.instruments was null or undefined when calling futuresV1LatestTick.');
        }

        const queryParameters: any = {};

        if (requestParameters.market !== undefined) {
            queryParameters['market'] = requestParameters.market;
        }

        if (requestParameters.instruments) {
            queryParameters['instruments'] = requestParameters.instruments.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.groups) {
            queryParameters['groups'] = requestParameters.groups.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.mappingPriority !== undefined) {
            queryParameters['mapping_priority'] = requestParameters.mappingPriority;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/futures/v1/latest/tick`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GENERICRESPONSEFromJSON(jsonValue));
    }

    /**
     */
    async futuresV1LatestTick(requestParameters: FuturesV1LatestTickRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GENERICRESPONSE> {
        const response = await this.futuresV1LatestTickRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async futuresV1MarketsRaw(requestParameters: FuturesV1MarketsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GENERICRESPONSE>> {
        const queryParameters: any = {};

        if (requestParameters.market !== undefined) {
            queryParameters['market'] = requestParameters.market;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/futures/v1/markets`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GENERICRESPONSEFromJSON(jsonValue));
    }

    /**
     */
    async futuresV1Markets(requestParameters: FuturesV1MarketsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GENERICRESPONSE> {
        const response = await this.futuresV1MarketsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async futuresV1MarketsInstrumentsRaw(requestParameters: FuturesV1MarketsInstrumentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GENERICRESPONSE>> {
        const queryParameters: any = {};

        if (requestParameters.market !== undefined) {
            queryParameters['market'] = requestParameters.market;
        }

        if (requestParameters.instrument !== undefined) {
            queryParameters['instrument'] = requestParameters.instrument;
        }

        if (requestParameters.instrumentStatus) {
            queryParameters['instrument_status'] = requestParameters.instrumentStatus.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/futures/v1/markets/instruments`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GENERICRESPONSEFromJSON(jsonValue));
    }

    /**
     */
    async futuresV1MarketsInstruments(requestParameters: FuturesV1MarketsInstrumentsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GENERICRESPONSE> {
        const response = await this.futuresV1MarketsInstrumentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async futuresV1MarketsInstrumentsUnmappedRaw(requestParameters: FuturesV1MarketsInstrumentsUnmappedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GENERICRESPONSE>> {
        const queryParameters: any = {};

        if (requestParameters.market !== undefined) {
            queryParameters['market'] = requestParameters.market;
        }

        if (requestParameters.instrument !== undefined) {
            queryParameters['instrument'] = requestParameters.instrument;
        }

        if (requestParameters.instrumentStatus) {
            queryParameters['instrument_status'] = requestParameters.instrumentStatus.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/futures/v1/markets/instruments/unmapped`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GENERICRESPONSEFromJSON(jsonValue));
    }

    /**
     */
    async futuresV1MarketsInstrumentsUnmapped(requestParameters: FuturesV1MarketsInstrumentsUnmappedRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GENERICRESPONSE> {
        const response = await this.futuresV1MarketsInstrumentsUnmappedRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async indexV1HistoricalDaysRaw(requestParameters: IndexV1HistoricalDaysRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GENERICRESPONSE>> {
        if (requestParameters.market === null || requestParameters.market === undefined) {
            throw new runtime.RequiredError('market','Required parameter requestParameters.market was null or undefined when calling indexV1HistoricalDays.');
        }

        if (requestParameters.instrument === null || requestParameters.instrument === undefined) {
            throw new runtime.RequiredError('instrument','Required parameter requestParameters.instrument was null or undefined when calling indexV1HistoricalDays.');
        }

        const queryParameters: any = {};

        if (requestParameters.market !== undefined) {
            queryParameters['market'] = requestParameters.market;
        }

        if (requestParameters.instrument !== undefined) {
            queryParameters['instrument'] = requestParameters.instrument;
        }

        if (requestParameters.groups) {
            queryParameters['groups'] = requestParameters.groups.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.toTs !== undefined) {
            queryParameters['to_ts'] = requestParameters.toTs;
        }

        if (requestParameters.aggregate !== undefined) {
            queryParameters['aggregate'] = requestParameters.aggregate;
        }

        if (requestParameters.fill !== undefined) {
            queryParameters['fill'] = requestParameters.fill;
        }

        if (requestParameters.mappingPriority !== undefined) {
            queryParameters['mapping_priority'] = requestParameters.mappingPriority;
        }

        if (requestParameters.responseFormat !== undefined) {
            queryParameters['response_format'] = requestParameters.responseFormat;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/index/v1/historical/days`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GENERICRESPONSEFromJSON(jsonValue));
    }

    /**
     */
    async indexV1HistoricalDays(requestParameters: IndexV1HistoricalDaysRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GENERICRESPONSE> {
        const response = await this.indexV1HistoricalDaysRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async indexV1HistoricalHoursRaw(requestParameters: IndexV1HistoricalHoursRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GENERICRESPONSE>> {
        if (requestParameters.market === null || requestParameters.market === undefined) {
            throw new runtime.RequiredError('market','Required parameter requestParameters.market was null or undefined when calling indexV1HistoricalHours.');
        }

        if (requestParameters.instrument === null || requestParameters.instrument === undefined) {
            throw new runtime.RequiredError('instrument','Required parameter requestParameters.instrument was null or undefined when calling indexV1HistoricalHours.');
        }

        const queryParameters: any = {};

        if (requestParameters.market !== undefined) {
            queryParameters['market'] = requestParameters.market;
        }

        if (requestParameters.instrument !== undefined) {
            queryParameters['instrument'] = requestParameters.instrument;
        }

        if (requestParameters.groups) {
            queryParameters['groups'] = requestParameters.groups.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.toTs !== undefined) {
            queryParameters['to_ts'] = requestParameters.toTs;
        }

        if (requestParameters.aggregate !== undefined) {
            queryParameters['aggregate'] = requestParameters.aggregate;
        }

        if (requestParameters.fill !== undefined) {
            queryParameters['fill'] = requestParameters.fill;
        }

        if (requestParameters.mappingPriority !== undefined) {
            queryParameters['mapping_priority'] = requestParameters.mappingPriority;
        }

        if (requestParameters.responseFormat !== undefined) {
            queryParameters['response_format'] = requestParameters.responseFormat;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/index/v1/historical/hours`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GENERICRESPONSEFromJSON(jsonValue));
    }

    /**
     */
    async indexV1HistoricalHours(requestParameters: IndexV1HistoricalHoursRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GENERICRESPONSE> {
        const response = await this.indexV1HistoricalHoursRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async indexV1HistoricalMessagesRaw(requestParameters: IndexV1HistoricalMessagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GENERICRESPONSE>> {
        if (requestParameters.market === null || requestParameters.market === undefined) {
            throw new runtime.RequiredError('market','Required parameter requestParameters.market was null or undefined when calling indexV1HistoricalMessages.');
        }

        if (requestParameters.instrument === null || requestParameters.instrument === undefined) {
            throw new runtime.RequiredError('instrument','Required parameter requestParameters.instrument was null or undefined when calling indexV1HistoricalMessages.');
        }

        const queryParameters: any = {};

        if (requestParameters.market !== undefined) {
            queryParameters['market'] = requestParameters.market;
        }

        if (requestParameters.instrument !== undefined) {
            queryParameters['instrument'] = requestParameters.instrument;
        }

        if (requestParameters.afterTs !== undefined) {
            queryParameters['after_ts'] = requestParameters.afterTs;
        }

        if (requestParameters.lastCcseq !== undefined) {
            queryParameters['last_ccseq'] = requestParameters.lastCcseq;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.mappingPriority !== undefined) {
            queryParameters['mapping_priority'] = requestParameters.mappingPriority;
        }

        if (requestParameters.responseFormat !== undefined) {
            queryParameters['response_format'] = requestParameters.responseFormat;
        }

        if (requestParameters.return404OnEmptyResponse !== undefined) {
            queryParameters['return_404_on_empty_response'] = requestParameters.return404OnEmptyResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // api_key_header authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key_query authentication
        }

        const response = await this.request({
            path: `/index/v1/historical/messages`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GENERICRESPONSEFromJSON(jsonValue));
    }

    /**
     */
    async indexV1HistoricalMessages(requestParameters: IndexV1HistoricalMessagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GENERICRESPONSE> {
        const response = await this.indexV1HistoricalMessagesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async indexV1HistoricalMessagesHourRaw(requestParameters: IndexV1HistoricalMessagesHourRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GENERICRESPONSE>> {
        if (requestParameters.market === null || requestParameters.market === undefined) {
            throw new runtime.RequiredError('market','Required parameter requestParameters.market was null or undefined when calling indexV1HistoricalMessagesHour.');
        }

        if (requestParameters.instrument === null || requestParameters.instrument === undefined) {
            throw new runtime.RequiredError('instrument','Required parameter requestParameters.instrument was null or undefined when calling indexV1HistoricalMessagesHour.');
        }

        const queryParameters: any = {};

        if (requestParameters.market !== undefined) {
            queryParameters['market'] = requestParameters.market;
        }

        if (requestParameters.instrument !== undefined) {
            queryParameters['instrument'] = requestParameters.instrument;
        }

        if (requestParameters.hourTs !== undefined) {
            queryParameters['hour_ts'] = requestParameters.hourTs;
        }

        if (requestParameters.mappingPriority !== undefined) {
            queryParameters['mapping_priority'] = requestParameters.mappingPriority;
        }

        if (requestParameters.responseFormat !== undefined) {
            queryParameters['response_format'] = requestParameters.responseFormat;
        }

        if (requestParameters.return404OnEmptyResponse !== undefined) {
            queryParameters['return_404_on_empty_response'] = requestParameters.return404OnEmptyResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // api_key_header authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key_query authentication
        }

        const response = await this.request({
            path: `/index/v1/historical/messages/hour`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GENERICRESPONSEFromJSON(jsonValue));
    }

    /**
     */
    async indexV1HistoricalMessagesHour(requestParameters: IndexV1HistoricalMessagesHourRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GENERICRESPONSE> {
        const response = await this.indexV1HistoricalMessagesHourRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async indexV1HistoricalMinutesRaw(requestParameters: IndexV1HistoricalMinutesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GENERICRESPONSE>> {
        if (requestParameters.market === null || requestParameters.market === undefined) {
            throw new runtime.RequiredError('market','Required parameter requestParameters.market was null or undefined when calling indexV1HistoricalMinutes.');
        }

        if (requestParameters.instrument === null || requestParameters.instrument === undefined) {
            throw new runtime.RequiredError('instrument','Required parameter requestParameters.instrument was null or undefined when calling indexV1HistoricalMinutes.');
        }

        const queryParameters: any = {};

        if (requestParameters.market !== undefined) {
            queryParameters['market'] = requestParameters.market;
        }

        if (requestParameters.instrument !== undefined) {
            queryParameters['instrument'] = requestParameters.instrument;
        }

        if (requestParameters.groups) {
            queryParameters['groups'] = requestParameters.groups.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.toTs !== undefined) {
            queryParameters['to_ts'] = requestParameters.toTs;
        }

        if (requestParameters.aggregate !== undefined) {
            queryParameters['aggregate'] = requestParameters.aggregate;
        }

        if (requestParameters.fill !== undefined) {
            queryParameters['fill'] = requestParameters.fill;
        }

        if (requestParameters.mappingPriority !== undefined) {
            queryParameters['mapping_priority'] = requestParameters.mappingPriority;
        }

        if (requestParameters.responseFormat !== undefined) {
            queryParameters['response_format'] = requestParameters.responseFormat;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/index/v1/historical/minutes`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GENERICRESPONSEFromJSON(jsonValue));
    }

    /**
     */
    async indexV1HistoricalMinutes(requestParameters: IndexV1HistoricalMinutesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GENERICRESPONSE> {
        const response = await this.indexV1HistoricalMinutesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async indexV1LatestInstrumentMetadataRaw(requestParameters: IndexV1LatestInstrumentMetadataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GENERICRESPONSE>> {
        if (requestParameters.market === null || requestParameters.market === undefined) {
            throw new runtime.RequiredError('market','Required parameter requestParameters.market was null or undefined when calling indexV1LatestInstrumentMetadata.');
        }

        if (requestParameters.instruments === null || requestParameters.instruments === undefined) {
            throw new runtime.RequiredError('instruments','Required parameter requestParameters.instruments was null or undefined when calling indexV1LatestInstrumentMetadata.');
        }

        const queryParameters: any = {};

        if (requestParameters.market !== undefined) {
            queryParameters['market'] = requestParameters.market;
        }

        if (requestParameters.instruments) {
            queryParameters['instruments'] = requestParameters.instruments.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.groups) {
            queryParameters['groups'] = requestParameters.groups.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.mappingPriority !== undefined) {
            queryParameters['mapping_priority'] = requestParameters.mappingPriority;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/index/v1/latest/instrument/metadata`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GENERICRESPONSEFromJSON(jsonValue));
    }

    /**
     */
    async indexV1LatestInstrumentMetadata(requestParameters: IndexV1LatestInstrumentMetadataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GENERICRESPONSE> {
        const response = await this.indexV1LatestInstrumentMetadataRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async indexV1LatestTickRaw(requestParameters: IndexV1LatestTickRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GENERICRESPONSE>> {
        if (requestParameters.market === null || requestParameters.market === undefined) {
            throw new runtime.RequiredError('market','Required parameter requestParameters.market was null or undefined when calling indexV1LatestTick.');
        }

        if (requestParameters.instruments === null || requestParameters.instruments === undefined) {
            throw new runtime.RequiredError('instruments','Required parameter requestParameters.instruments was null or undefined when calling indexV1LatestTick.');
        }

        const queryParameters: any = {};

        if (requestParameters.market !== undefined) {
            queryParameters['market'] = requestParameters.market;
        }

        if (requestParameters.instruments) {
            queryParameters['instruments'] = requestParameters.instruments.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.groups) {
            queryParameters['groups'] = requestParameters.groups.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.mappingPriority !== undefined) {
            queryParameters['mapping_priority'] = requestParameters.mappingPriority;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/index/v1/latest/tick`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GENERICRESPONSEFromJSON(jsonValue));
    }

    /**
     */
    async indexV1LatestTick(requestParameters: IndexV1LatestTickRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GENERICRESPONSE> {
        const response = await this.indexV1LatestTickRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async indexV1MarketsRaw(requestParameters: IndexV1MarketsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GENERICRESPONSE>> {
        const queryParameters: any = {};

        if (requestParameters.market !== undefined) {
            queryParameters['market'] = requestParameters.market;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/index/v1/markets`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GENERICRESPONSEFromJSON(jsonValue));
    }

    /**
     */
    async indexV1Markets(requestParameters: IndexV1MarketsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GENERICRESPONSE> {
        const response = await this.indexV1MarketsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async indexV1MarketsInstrumentsRaw(requestParameters: IndexV1MarketsInstrumentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GENERICRESPONSE>> {
        const queryParameters: any = {};

        if (requestParameters.market !== undefined) {
            queryParameters['market'] = requestParameters.market;
        }

        if (requestParameters.instrument !== undefined) {
            queryParameters['instrument'] = requestParameters.instrument;
        }

        if (requestParameters.instrumentStatus) {
            queryParameters['instrument_status'] = requestParameters.instrumentStatus.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/index/v1/markets/instruments`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GENERICRESPONSEFromJSON(jsonValue));
    }

    /**
     */
    async indexV1MarketsInstruments(requestParameters: IndexV1MarketsInstrumentsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GENERICRESPONSE> {
        const response = await this.indexV1MarketsInstrumentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async indexV1MarketsInstrumentsUnmappedRaw(requestParameters: IndexV1MarketsInstrumentsUnmappedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GENERICRESPONSE>> {
        const queryParameters: any = {};

        if (requestParameters.market !== undefined) {
            queryParameters['market'] = requestParameters.market;
        }

        if (requestParameters.instrument !== undefined) {
            queryParameters['instrument'] = requestParameters.instrument;
        }

        if (requestParameters.instrumentStatus) {
            queryParameters['instrument_status'] = requestParameters.instrumentStatus.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/index/v1/markets/instruments/unmapped`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GENERICRESPONSEFromJSON(jsonValue));
    }

    /**
     */
    async indexV1MarketsInstrumentsUnmapped(requestParameters: IndexV1MarketsInstrumentsUnmappedRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GENERICRESPONSE> {
        const response = await this.indexV1MarketsInstrumentsUnmappedRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const FuturesV1HistoricalDaysMappingPriorityEnum = {
    MappedFirst: 'CHECK_MAPPED_FIRST',
    UnmappedFirst: 'CHECK_UNMAPPED_FIRST'
} as const;
export type FuturesV1HistoricalDaysMappingPriorityEnum = typeof FuturesV1HistoricalDaysMappingPriorityEnum[keyof typeof FuturesV1HistoricalDaysMappingPriorityEnum];
/**
 * @export
 */
export const FuturesV1HistoricalDaysResponseFormatEnum = {
    Json: 'JSON',
    Csv: 'CSV'
} as const;
export type FuturesV1HistoricalDaysResponseFormatEnum = typeof FuturesV1HistoricalDaysResponseFormatEnum[keyof typeof FuturesV1HistoricalDaysResponseFormatEnum];
/**
 * @export
 */
export const FuturesV1HistoricalFundingRateDaysMappingPriorityEnum = {
    MappedFirst: 'CHECK_MAPPED_FIRST',
    UnmappedFirst: 'CHECK_UNMAPPED_FIRST'
} as const;
export type FuturesV1HistoricalFundingRateDaysMappingPriorityEnum = typeof FuturesV1HistoricalFundingRateDaysMappingPriorityEnum[keyof typeof FuturesV1HistoricalFundingRateDaysMappingPriorityEnum];
/**
 * @export
 */
export const FuturesV1HistoricalFundingRateDaysResponseFormatEnum = {
    Json: 'JSON',
    Csv: 'CSV'
} as const;
export type FuturesV1HistoricalFundingRateDaysResponseFormatEnum = typeof FuturesV1HistoricalFundingRateDaysResponseFormatEnum[keyof typeof FuturesV1HistoricalFundingRateDaysResponseFormatEnum];
/**
 * @export
 */
export const FuturesV1HistoricalFundingRateHoursMappingPriorityEnum = {
    MappedFirst: 'CHECK_MAPPED_FIRST',
    UnmappedFirst: 'CHECK_UNMAPPED_FIRST'
} as const;
export type FuturesV1HistoricalFundingRateHoursMappingPriorityEnum = typeof FuturesV1HistoricalFundingRateHoursMappingPriorityEnum[keyof typeof FuturesV1HistoricalFundingRateHoursMappingPriorityEnum];
/**
 * @export
 */
export const FuturesV1HistoricalFundingRateHoursResponseFormatEnum = {
    Json: 'JSON',
    Csv: 'CSV'
} as const;
export type FuturesV1HistoricalFundingRateHoursResponseFormatEnum = typeof FuturesV1HistoricalFundingRateHoursResponseFormatEnum[keyof typeof FuturesV1HistoricalFundingRateHoursResponseFormatEnum];
/**
 * @export
 */
export const FuturesV1HistoricalFundingRateMessagesMappingPriorityEnum = {
    MappedFirst: 'CHECK_MAPPED_FIRST',
    UnmappedFirst: 'CHECK_UNMAPPED_FIRST'
} as const;
export type FuturesV1HistoricalFundingRateMessagesMappingPriorityEnum = typeof FuturesV1HistoricalFundingRateMessagesMappingPriorityEnum[keyof typeof FuturesV1HistoricalFundingRateMessagesMappingPriorityEnum];
/**
 * @export
 */
export const FuturesV1HistoricalFundingRateMessagesResponseFormatEnum = {
    Json: 'JSON',
    Csv: 'CSV'
} as const;
export type FuturesV1HistoricalFundingRateMessagesResponseFormatEnum = typeof FuturesV1HistoricalFundingRateMessagesResponseFormatEnum[keyof typeof FuturesV1HistoricalFundingRateMessagesResponseFormatEnum];
/**
 * @export
 */
export const FuturesV1HistoricalFundingRateMessagesHourMappingPriorityEnum = {
    MappedFirst: 'CHECK_MAPPED_FIRST',
    UnmappedFirst: 'CHECK_UNMAPPED_FIRST'
} as const;
export type FuturesV1HistoricalFundingRateMessagesHourMappingPriorityEnum = typeof FuturesV1HistoricalFundingRateMessagesHourMappingPriorityEnum[keyof typeof FuturesV1HistoricalFundingRateMessagesHourMappingPriorityEnum];
/**
 * @export
 */
export const FuturesV1HistoricalFundingRateMessagesHourResponseFormatEnum = {
    Json: 'JSON',
    Csv: 'CSV'
} as const;
export type FuturesV1HistoricalFundingRateMessagesHourResponseFormatEnum = typeof FuturesV1HistoricalFundingRateMessagesHourResponseFormatEnum[keyof typeof FuturesV1HistoricalFundingRateMessagesHourResponseFormatEnum];
/**
 * @export
 */
export const FuturesV1HistoricalFundingRateMinutesMappingPriorityEnum = {
    MappedFirst: 'CHECK_MAPPED_FIRST',
    UnmappedFirst: 'CHECK_UNMAPPED_FIRST'
} as const;
export type FuturesV1HistoricalFundingRateMinutesMappingPriorityEnum = typeof FuturesV1HistoricalFundingRateMinutesMappingPriorityEnum[keyof typeof FuturesV1HistoricalFundingRateMinutesMappingPriorityEnum];
/**
 * @export
 */
export const FuturesV1HistoricalFundingRateMinutesResponseFormatEnum = {
    Json: 'JSON',
    Csv: 'CSV'
} as const;
export type FuturesV1HistoricalFundingRateMinutesResponseFormatEnum = typeof FuturesV1HistoricalFundingRateMinutesResponseFormatEnum[keyof typeof FuturesV1HistoricalFundingRateMinutesResponseFormatEnum];
/**
 * @export
 */
export const FuturesV1HistoricalHoursMappingPriorityEnum = {
    MappedFirst: 'CHECK_MAPPED_FIRST',
    UnmappedFirst: 'CHECK_UNMAPPED_FIRST'
} as const;
export type FuturesV1HistoricalHoursMappingPriorityEnum = typeof FuturesV1HistoricalHoursMappingPriorityEnum[keyof typeof FuturesV1HistoricalHoursMappingPriorityEnum];
/**
 * @export
 */
export const FuturesV1HistoricalHoursResponseFormatEnum = {
    Json: 'JSON',
    Csv: 'CSV'
} as const;
export type FuturesV1HistoricalHoursResponseFormatEnum = typeof FuturesV1HistoricalHoursResponseFormatEnum[keyof typeof FuturesV1HistoricalHoursResponseFormatEnum];
/**
 * @export
 */
export const FuturesV1HistoricalMinutesMappingPriorityEnum = {
    MappedFirst: 'CHECK_MAPPED_FIRST',
    UnmappedFirst: 'CHECK_UNMAPPED_FIRST'
} as const;
export type FuturesV1HistoricalMinutesMappingPriorityEnum = typeof FuturesV1HistoricalMinutesMappingPriorityEnum[keyof typeof FuturesV1HistoricalMinutesMappingPriorityEnum];
/**
 * @export
 */
export const FuturesV1HistoricalMinutesResponseFormatEnum = {
    Json: 'JSON',
    Csv: 'CSV'
} as const;
export type FuturesV1HistoricalMinutesResponseFormatEnum = typeof FuturesV1HistoricalMinutesResponseFormatEnum[keyof typeof FuturesV1HistoricalMinutesResponseFormatEnum];
/**
 * @export
 */
export const FuturesV1HistoricalOpenInterestDaysMappingPriorityEnum = {
    MappedFirst: 'CHECK_MAPPED_FIRST',
    UnmappedFirst: 'CHECK_UNMAPPED_FIRST'
} as const;
export type FuturesV1HistoricalOpenInterestDaysMappingPriorityEnum = typeof FuturesV1HistoricalOpenInterestDaysMappingPriorityEnum[keyof typeof FuturesV1HistoricalOpenInterestDaysMappingPriorityEnum];
/**
 * @export
 */
export const FuturesV1HistoricalOpenInterestDaysResponseFormatEnum = {
    Json: 'JSON',
    Csv: 'CSV'
} as const;
export type FuturesV1HistoricalOpenInterestDaysResponseFormatEnum = typeof FuturesV1HistoricalOpenInterestDaysResponseFormatEnum[keyof typeof FuturesV1HistoricalOpenInterestDaysResponseFormatEnum];
/**
 * @export
 */
export const FuturesV1HistoricalOpenInterestHoursMappingPriorityEnum = {
    MappedFirst: 'CHECK_MAPPED_FIRST',
    UnmappedFirst: 'CHECK_UNMAPPED_FIRST'
} as const;
export type FuturesV1HistoricalOpenInterestHoursMappingPriorityEnum = typeof FuturesV1HistoricalOpenInterestHoursMappingPriorityEnum[keyof typeof FuturesV1HistoricalOpenInterestHoursMappingPriorityEnum];
/**
 * @export
 */
export const FuturesV1HistoricalOpenInterestHoursResponseFormatEnum = {
    Json: 'JSON',
    Csv: 'CSV'
} as const;
export type FuturesV1HistoricalOpenInterestHoursResponseFormatEnum = typeof FuturesV1HistoricalOpenInterestHoursResponseFormatEnum[keyof typeof FuturesV1HistoricalOpenInterestHoursResponseFormatEnum];
/**
 * @export
 */
export const FuturesV1HistoricalOpenInterestMessagesMappingPriorityEnum = {
    MappedFirst: 'CHECK_MAPPED_FIRST',
    UnmappedFirst: 'CHECK_UNMAPPED_FIRST'
} as const;
export type FuturesV1HistoricalOpenInterestMessagesMappingPriorityEnum = typeof FuturesV1HistoricalOpenInterestMessagesMappingPriorityEnum[keyof typeof FuturesV1HistoricalOpenInterestMessagesMappingPriorityEnum];
/**
 * @export
 */
export const FuturesV1HistoricalOpenInterestMessagesResponseFormatEnum = {
    Json: 'JSON',
    Csv: 'CSV'
} as const;
export type FuturesV1HistoricalOpenInterestMessagesResponseFormatEnum = typeof FuturesV1HistoricalOpenInterestMessagesResponseFormatEnum[keyof typeof FuturesV1HistoricalOpenInterestMessagesResponseFormatEnum];
/**
 * @export
 */
export const FuturesV1HistoricalOpenInterestMessagesHourMappingPriorityEnum = {
    MappedFirst: 'CHECK_MAPPED_FIRST',
    UnmappedFirst: 'CHECK_UNMAPPED_FIRST'
} as const;
export type FuturesV1HistoricalOpenInterestMessagesHourMappingPriorityEnum = typeof FuturesV1HistoricalOpenInterestMessagesHourMappingPriorityEnum[keyof typeof FuturesV1HistoricalOpenInterestMessagesHourMappingPriorityEnum];
/**
 * @export
 */
export const FuturesV1HistoricalOpenInterestMessagesHourResponseFormatEnum = {
    Json: 'JSON',
    Csv: 'CSV'
} as const;
export type FuturesV1HistoricalOpenInterestMessagesHourResponseFormatEnum = typeof FuturesV1HistoricalOpenInterestMessagesHourResponseFormatEnum[keyof typeof FuturesV1HistoricalOpenInterestMessagesHourResponseFormatEnum];
/**
 * @export
 */
export const FuturesV1HistoricalOpenInterestMinutesMappingPriorityEnum = {
    MappedFirst: 'CHECK_MAPPED_FIRST',
    UnmappedFirst: 'CHECK_UNMAPPED_FIRST'
} as const;
export type FuturesV1HistoricalOpenInterestMinutesMappingPriorityEnum = typeof FuturesV1HistoricalOpenInterestMinutesMappingPriorityEnum[keyof typeof FuturesV1HistoricalOpenInterestMinutesMappingPriorityEnum];
/**
 * @export
 */
export const FuturesV1HistoricalOpenInterestMinutesResponseFormatEnum = {
    Json: 'JSON',
    Csv: 'CSV'
} as const;
export type FuturesV1HistoricalOpenInterestMinutesResponseFormatEnum = typeof FuturesV1HistoricalOpenInterestMinutesResponseFormatEnum[keyof typeof FuturesV1HistoricalOpenInterestMinutesResponseFormatEnum];
/**
 * @export
 */
export const FuturesV1HistoricalTradesMappingPriorityEnum = {
    MappedFirst: 'CHECK_MAPPED_FIRST',
    UnmappedFirst: 'CHECK_UNMAPPED_FIRST'
} as const;
export type FuturesV1HistoricalTradesMappingPriorityEnum = typeof FuturesV1HistoricalTradesMappingPriorityEnum[keyof typeof FuturesV1HistoricalTradesMappingPriorityEnum];
/**
 * @export
 */
export const FuturesV1HistoricalTradesResponseFormatEnum = {
    Json: 'JSON',
    Csv: 'CSV'
} as const;
export type FuturesV1HistoricalTradesResponseFormatEnum = typeof FuturesV1HistoricalTradesResponseFormatEnum[keyof typeof FuturesV1HistoricalTradesResponseFormatEnum];
/**
 * @export
 */
export const FuturesV1HistoricalTradesHourMappingPriorityEnum = {
    MappedFirst: 'CHECK_MAPPED_FIRST',
    UnmappedFirst: 'CHECK_UNMAPPED_FIRST'
} as const;
export type FuturesV1HistoricalTradesHourMappingPriorityEnum = typeof FuturesV1HistoricalTradesHourMappingPriorityEnum[keyof typeof FuturesV1HistoricalTradesHourMappingPriorityEnum];
/**
 * @export
 */
export const FuturesV1HistoricalTradesHourResponseFormatEnum = {
    Json: 'JSON',
    Csv: 'CSV'
} as const;
export type FuturesV1HistoricalTradesHourResponseFormatEnum = typeof FuturesV1HistoricalTradesHourResponseFormatEnum[keyof typeof FuturesV1HistoricalTradesHourResponseFormatEnum];
/**
 * @export
 */
export const FuturesV1LatestFundingRateTickMappingPriorityEnum = {
    MappedFirst: 'CHECK_MAPPED_FIRST',
    UnmappedFirst: 'CHECK_UNMAPPED_FIRST'
} as const;
export type FuturesV1LatestFundingRateTickMappingPriorityEnum = typeof FuturesV1LatestFundingRateTickMappingPriorityEnum[keyof typeof FuturesV1LatestFundingRateTickMappingPriorityEnum];
/**
 * @export
 */
export const FuturesV1LatestInstrumentMetadataMappingPriorityEnum = {
    MappedFirst: 'CHECK_MAPPED_FIRST',
    UnmappedFirst: 'CHECK_UNMAPPED_FIRST'
} as const;
export type FuturesV1LatestInstrumentMetadataMappingPriorityEnum = typeof FuturesV1LatestInstrumentMetadataMappingPriorityEnum[keyof typeof FuturesV1LatestInstrumentMetadataMappingPriorityEnum];
/**
 * @export
 */
export const FuturesV1LatestOpenInterestTickMappingPriorityEnum = {
    MappedFirst: 'CHECK_MAPPED_FIRST',
    UnmappedFirst: 'CHECK_UNMAPPED_FIRST'
} as const;
export type FuturesV1LatestOpenInterestTickMappingPriorityEnum = typeof FuturesV1LatestOpenInterestTickMappingPriorityEnum[keyof typeof FuturesV1LatestOpenInterestTickMappingPriorityEnum];
/**
 * @export
 */
export const FuturesV1LatestTickMappingPriorityEnum = {
    MappedFirst: 'CHECK_MAPPED_FIRST',
    UnmappedFirst: 'CHECK_UNMAPPED_FIRST'
} as const;
export type FuturesV1LatestTickMappingPriorityEnum = typeof FuturesV1LatestTickMappingPriorityEnum[keyof typeof FuturesV1LatestTickMappingPriorityEnum];
/**
 * @export
 */
export const FuturesV1MarketsInstrumentsInstrumentStatusEnum = {
    Active: 'ACTIVE',
    Ignored: 'IGNORED',
    Retired: 'RETIRED',
    Expired: 'EXPIRED'
} as const;
export type FuturesV1MarketsInstrumentsInstrumentStatusEnum = typeof FuturesV1MarketsInstrumentsInstrumentStatusEnum[keyof typeof FuturesV1MarketsInstrumentsInstrumentStatusEnum];
/**
 * @export
 */
export const FuturesV1MarketsInstrumentsUnmappedInstrumentStatusEnum = {
    Active: 'ACTIVE',
    Ignored: 'IGNORED',
    Retired: 'RETIRED',
    Expired: 'EXPIRED'
} as const;
export type FuturesV1MarketsInstrumentsUnmappedInstrumentStatusEnum = typeof FuturesV1MarketsInstrumentsUnmappedInstrumentStatusEnum[keyof typeof FuturesV1MarketsInstrumentsUnmappedInstrumentStatusEnum];
/**
 * @export
 */
export const IndexV1HistoricalDaysMappingPriorityEnum = {
    MappedFirst: 'CHECK_MAPPED_FIRST',
    UnmappedFirst: 'CHECK_UNMAPPED_FIRST'
} as const;
export type IndexV1HistoricalDaysMappingPriorityEnum = typeof IndexV1HistoricalDaysMappingPriorityEnum[keyof typeof IndexV1HistoricalDaysMappingPriorityEnum];
/**
 * @export
 */
export const IndexV1HistoricalDaysResponseFormatEnum = {
    Json: 'JSON',
    Csv: 'CSV'
} as const;
export type IndexV1HistoricalDaysResponseFormatEnum = typeof IndexV1HistoricalDaysResponseFormatEnum[keyof typeof IndexV1HistoricalDaysResponseFormatEnum];
/**
 * @export
 */
export const IndexV1HistoricalHoursMappingPriorityEnum = {
    MappedFirst: 'CHECK_MAPPED_FIRST',
    UnmappedFirst: 'CHECK_UNMAPPED_FIRST'
} as const;
export type IndexV1HistoricalHoursMappingPriorityEnum = typeof IndexV1HistoricalHoursMappingPriorityEnum[keyof typeof IndexV1HistoricalHoursMappingPriorityEnum];
/**
 * @export
 */
export const IndexV1HistoricalHoursResponseFormatEnum = {
    Json: 'JSON',
    Csv: 'CSV'
} as const;
export type IndexV1HistoricalHoursResponseFormatEnum = typeof IndexV1HistoricalHoursResponseFormatEnum[keyof typeof IndexV1HistoricalHoursResponseFormatEnum];
/**
 * @export
 */
export const IndexV1HistoricalMessagesMappingPriorityEnum = {
    MappedFirst: 'CHECK_MAPPED_FIRST',
    UnmappedFirst: 'CHECK_UNMAPPED_FIRST'
} as const;
export type IndexV1HistoricalMessagesMappingPriorityEnum = typeof IndexV1HistoricalMessagesMappingPriorityEnum[keyof typeof IndexV1HistoricalMessagesMappingPriorityEnum];
/**
 * @export
 */
export const IndexV1HistoricalMessagesResponseFormatEnum = {
    Json: 'JSON',
    Csv: 'CSV'
} as const;
export type IndexV1HistoricalMessagesResponseFormatEnum = typeof IndexV1HistoricalMessagesResponseFormatEnum[keyof typeof IndexV1HistoricalMessagesResponseFormatEnum];
/**
 * @export
 */
export const IndexV1HistoricalMessagesHourMappingPriorityEnum = {
    MappedFirst: 'CHECK_MAPPED_FIRST',
    UnmappedFirst: 'CHECK_UNMAPPED_FIRST'
} as const;
export type IndexV1HistoricalMessagesHourMappingPriorityEnum = typeof IndexV1HistoricalMessagesHourMappingPriorityEnum[keyof typeof IndexV1HistoricalMessagesHourMappingPriorityEnum];
/**
 * @export
 */
export const IndexV1HistoricalMessagesHourResponseFormatEnum = {
    Json: 'JSON',
    Csv: 'CSV'
} as const;
export type IndexV1HistoricalMessagesHourResponseFormatEnum = typeof IndexV1HistoricalMessagesHourResponseFormatEnum[keyof typeof IndexV1HistoricalMessagesHourResponseFormatEnum];
/**
 * @export
 */
export const IndexV1HistoricalMinutesMappingPriorityEnum = {
    MappedFirst: 'CHECK_MAPPED_FIRST',
    UnmappedFirst: 'CHECK_UNMAPPED_FIRST'
} as const;
export type IndexV1HistoricalMinutesMappingPriorityEnum = typeof IndexV1HistoricalMinutesMappingPriorityEnum[keyof typeof IndexV1HistoricalMinutesMappingPriorityEnum];
/**
 * @export
 */
export const IndexV1HistoricalMinutesResponseFormatEnum = {
    Json: 'JSON',
    Csv: 'CSV'
} as const;
export type IndexV1HistoricalMinutesResponseFormatEnum = typeof IndexV1HistoricalMinutesResponseFormatEnum[keyof typeof IndexV1HistoricalMinutesResponseFormatEnum];
/**
 * @export
 */
export const IndexV1LatestInstrumentMetadataMappingPriorityEnum = {
    MappedFirst: 'CHECK_MAPPED_FIRST',
    UnmappedFirst: 'CHECK_UNMAPPED_FIRST'
} as const;
export type IndexV1LatestInstrumentMetadataMappingPriorityEnum = typeof IndexV1LatestInstrumentMetadataMappingPriorityEnum[keyof typeof IndexV1LatestInstrumentMetadataMappingPriorityEnum];
/**
 * @export
 */
export const IndexV1LatestTickMappingPriorityEnum = {
    MappedFirst: 'CHECK_MAPPED_FIRST',
    UnmappedFirst: 'CHECK_UNMAPPED_FIRST'
} as const;
export type IndexV1LatestTickMappingPriorityEnum = typeof IndexV1LatestTickMappingPriorityEnum[keyof typeof IndexV1LatestTickMappingPriorityEnum];
/**
 * @export
 */
export const IndexV1MarketsInstrumentsInstrumentStatusEnum = {
    Active: 'ACTIVE',
    Ignored: 'IGNORED',
    Retired: 'RETIRED',
    Expired: 'EXPIRED'
} as const;
export type IndexV1MarketsInstrumentsInstrumentStatusEnum = typeof IndexV1MarketsInstrumentsInstrumentStatusEnum[keyof typeof IndexV1MarketsInstrumentsInstrumentStatusEnum];
/**
 * @export
 */
export const IndexV1MarketsInstrumentsUnmappedInstrumentStatusEnum = {
    Active: 'ACTIVE',
    Ignored: 'IGNORED',
    Retired: 'RETIRED',
    Expired: 'EXPIRED'
} as const;
export type IndexV1MarketsInstrumentsUnmappedInstrumentStatusEnum = typeof IndexV1MarketsInstrumentsUnmappedInstrumentStatusEnum[keyof typeof IndexV1MarketsInstrumentsUnmappedInstrumentStatusEnum];
