/**
 * CryptoCompare Market, Index, Reference Data, News and Overview Metrcis API for the Cryptocurrency Industry
 * CryptoCompare is the world's leading digital asset data company, providing services that cater to corporate, government and retail clients. Our main reference index is widely recognized as a reliable benchmark, and we have been authorized by the Financial Conduct Authority (FCA) in the United Kingdom to operate as a benchmark administrator. In addition to catering to corporate, government, and retail clients, we offer a range of services including comprehensive market data for cryptocurrency exchanges in both the centralized and decentralized finance sectors, as well as individual asset data on custodians, supported platforms, and privacy solutions. Our offerings include price, volume, trade, and orderbook updates, as well as historical OHLCV data.
 *
 * The version of the OpenAPI document: 2.1.1
 * Contact: data@cryptocompare.com
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 6.3.0-SNAPSHOT.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/*
 * SPOT_INSTRUMENT_TRADE.h
 *
 * 
 */

#ifndef ORG_OPENAPITOOLS_CLIENT_MODEL_SPOT_INSTRUMENT_TRADE_H_
#define ORG_OPENAPITOOLS_CLIENT_MODEL_SPOT_INSTRUMENT_TRADE_H_


#include "CppRestOpenAPIClient/ModelBase.h"

#include <cpprest/details/basic_types.h>

namespace org {
namespace openapitools {
namespace client {
namespace model {


/// <summary>
/// 
/// </summary>
class  SPOT_INSTRUMENT_TRADE
    : public ModelBase
{
public:
    SPOT_INSTRUMENT_TRADE();
    virtual ~SPOT_INSTRUMENT_TRADE();

    /////////////////////////////////////////////
    /// ModelBase overrides

    void validate() override;

    web::json::value toJson() const override;
    bool fromJson(const web::json::value& json) override;

    void toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& namePrefix) const override;
    bool fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& namePrefix) override;

    /////////////////////////////////////////////
    /// SPOT_INSTRUMENT_TRADE members

    /// <summary>
    /// The mapped from asset (base / symbol/ coin). Only available on instruments that have been mapped (e.g. BTC).
    /// </summary>
    utility::string_t getBASE() const;
    bool bASEIsSet() const;
    void unsetBASE();

    void setBASE(const utility::string_t& value);

    /// <summary>
    /// Our internal sequence number for this trade, this is unique per market / exchange and trading pair. Should always be increasing by 1 for each new trade we discover, not in chronological order.
    /// </summary>
    int32_t getCCSEQ() const;
    bool cCSEQIsSet() const;
    void unsetCCSEQ();

    void setCCSEQ(int32_t value);

    /// <summary>
    /// The trade ID as reported by the market / exchange. If the exchange does not provide a trade ID, this will be the timestamp of the trade + a number from 0 - 999. This preserves uniqueness, assuming there would never be more than 999 trades in any given second.
    /// </summary>
    utility::string_t getID() const;
    bool iDIsSet() const;
    void unsetID();

    void setID(const utility::string_t& value);

    /// <summary>
    /// The unmapped instrument ID as given by the exchange (e.g. BTCUSD, BTC_USD, XBT-ZUSD, BTC-USD).
    /// </summary>
    utility::string_t getINSTRUMENT() const;
    bool iNSTRUMENTIsSet() const;
    void unsetINSTRUMENT();

    void setINSTRUMENT(const utility::string_t& value);

    /// <summary>
    /// The mapped instrument ID, as derived from our mapping rules. This takes the form: \&quot;BASE-QUOTE\&quot;. Only available on instruments that have been mapped (e.g. BTC-USD).
    /// </summary>
    utility::string_t getMAPPEDINSTRUMENT() const;
    bool mAPPEDINSTRUMENTIsSet() const;
    void unsetMAPPED_INSTRUMENT();

    void setMAPPEDINSTRUMENT(const utility::string_t& value);

    /// <summary>
    /// The market / exchange under consideration (e.g. Coinbase, Kraken, etc.).
    /// </summary>
    utility::string_t getMARKET() const;
    bool mARKETIsSet() const;
    void unsetMARKET();

    void setMARKET(const utility::string_t& value);

    /// <summary>
    /// The price in the to instrument (quote / counter symbol / coin) of the trade. For a BTC-USD trade, this is how much was paid for one BTC in USD. For futures, this will be the price of the contract.
    /// </summary>
    int32_t getPRICE() const;
    bool pRICEIsSet() const;
    void unsetPRICE();

    void setPRICE(int32_t value);

    /// <summary>
    /// The volume of the trade, given in the from instrument (base symbol / coin/ contract). For a spot BTC-USD trade, this is how much BTC was traded at the trade price. For a futures BTCUSDPERP, this is the BTC equivalent for the contracts traded.
    /// </summary>
    int32_t getQUANTITY() const;
    bool qUANTITYIsSet() const;
    void unsetQUANTITY();

    void setQUANTITY(int32_t value);

    /// <summary>
    /// The mapped to asset (quote / counter symbol / coin). Only available on instruments that have been mapped (e.g. USD).
    /// </summary>
    utility::string_t getQUOTE() const;
    bool qUOTEIsSet() const;
    void unsetQUOTE();

    void setQUOTE(const utility::string_t& value);

    /// <summary>
    /// The volume of the trade, given in the to instrument (quote / counter symbol / coin). This is equivalent to QUANTITY * PRICE. E.g. for a BTC-USD trade, this is how much USD was paid in total for the volume of BTC traded. For futures this is the quote currency equivalent for the contracts traded.
    /// </summary>
    int32_t getQUOTEQUANTITY() const;
    bool qUOTEQUANTITYIsSet() const;
    void unsetQUOTE_QUANTITY();

    void setQUOTEQUANTITY(int32_t value);

    /// <summary>
    /// The timestamp in seconds that the trade was received. This varies from the trade taking place on the market by a few millisconds to a few seconds depending on the market / exchange API options / rate limits.
    /// </summary>
    int32_t getRECEIVEDTIMESTAMP() const;
    bool rECEIVEDTIMESTAMPIsSet() const;
    void unsetRECEIVED_TIMESTAMP();

    void setRECEIVEDTIMESTAMP(int32_t value);

    /// <summary>
    /// The nanosecond part of the received timestamp.
    /// </summary>
    int32_t getRECEIVEDTIMESTAMPNS() const;
    bool rECEIVEDTIMESTAMPNSIsSet() const;
    void unsetRECEIVED_TIMESTAMP_NS();

    void setRECEIVEDTIMESTAMPNS(int32_t value);

    /// <summary>
    /// The side of the trade: SELL, BUY or UNKNOWN. If the exchange / api does not provide a side, \&quot;UNKNOWN\&quot; will be returned.
    /// </summary>
    utility::string_t getSIDE() const;
    bool sIDEIsSet() const;
    void unsetSIDE();

    void setSIDE(const utility::string_t& value);

    /// <summary>
    /// The source of the trade update: POLLING, STREAMING, GO, BLOB etc.
    /// </summary>
    utility::string_t getSOURCE() const;
    bool sOURCEIsSet() const;
    void unsetSOURCE();

    void setSOURCE(const utility::string_t& value);

    /// <summary>
    /// The timestamp in seconds as reported by the market / exchange or the received timestamp if the market / exchange does not provide one.
    /// </summary>
    int32_t getTIMESTAMP() const;
    bool tIMESTAMPIsSet() const;
    void unsetTIMESTAMP();

    void setTIMESTAMP(int32_t value);

    /// <summary>
    /// The nanosecond part of the reported timestamp.
    /// </summary>
    int32_t getTIMESTAMPNS() const;
    bool tIMESTAMPNSIsSet() const;
    void unsetTIMESTAMP_NS();

    void setTIMESTAMPNS(int32_t value);

    /// <summary>
    /// The type of the message.
    /// </summary>
    utility::string_t getTYPE() const;
    bool tYPEIsSet() const;
    void unsetTYPE();

    void setTYPE(const utility::string_t& value);


protected:
    utility::string_t m_BASE;
    bool m_BASEIsSet;
    int32_t m_CCSEQ;
    bool m_CCSEQIsSet;
    utility::string_t m_ID;
    bool m_IDIsSet;
    utility::string_t m_INSTRUMENT;
    bool m_INSTRUMENTIsSet;
    utility::string_t m_MAPPED_INSTRUMENT;
    bool m_MAPPED_INSTRUMENTIsSet;
    utility::string_t m_MARKET;
    bool m_MARKETIsSet;
    int32_t m_PRICE;
    bool m_PRICEIsSet;
    int32_t m_QUANTITY;
    bool m_QUANTITYIsSet;
    utility::string_t m_QUOTE;
    bool m_QUOTEIsSet;
    int32_t m_QUOTE_QUANTITY;
    bool m_QUOTE_QUANTITYIsSet;
    int32_t m_RECEIVED_TIMESTAMP;
    bool m_RECEIVED_TIMESTAMPIsSet;
    int32_t m_RECEIVED_TIMESTAMP_NS;
    bool m_RECEIVED_TIMESTAMP_NSIsSet;
    utility::string_t m_SIDE;
    bool m_SIDEIsSet;
    utility::string_t m_SOURCE;
    bool m_SOURCEIsSet;
    int32_t m_TIMESTAMP;
    bool m_TIMESTAMPIsSet;
    int32_t m_TIMESTAMP_NS;
    bool m_TIMESTAMP_NSIsSet;
    utility::string_t m_TYPE;
    bool m_TYPEIsSet;
};


}
}
}
}

#endif /* ORG_OPENAPITOOLS_CLIENT_MODEL_SPOT_INSTRUMENT_TRADE_H_ */
