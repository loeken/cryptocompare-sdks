/**
 * CryptoCompare Market, Index, Reference Data, News and Overview Metrcis API for the Cryptocurrency Industry
 * CryptoCompare is the world's leading digital asset data company, providing services that cater to corporate, government and retail clients. Our main reference index is widely recognized as a reliable benchmark, and we have been authorized by the Financial Conduct Authority (FCA) in the United Kingdom to operate as a benchmark administrator. In addition to catering to corporate, government, and retail clients, we offer a range of services including comprehensive market data for cryptocurrency exchanges in both the centralized and decentralized finance sectors, as well as individual asset data on custodians, supported platforms, and privacy solutions. Our offerings include price, volume, trade, and orderbook updates, as well as historical OHLCV data.
 *
 * OpenAPI spec version: 2.1.1
 * Contact: data@cryptocompare.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator
 * https://github.com/OpenAPITools/openapi-generator
 * Do not edit the class manually.
 */

#include "OpenAPIFuturesApi.h"

#include "OpenAPIFuturesApiOperations.h"
#include "OpenAPIModule.h"

#include "HttpModule.h"
#include "Serialization/JsonSerializer.h"

namespace OpenAPI
{

OpenAPIFuturesApi::OpenAPIFuturesApi()
: Url(TEXT("https://data-api.cryptocompare.com"))
{
}

OpenAPIFuturesApi::~OpenAPIFuturesApi() {}

void OpenAPIFuturesApi::SetURL(const FString& InUrl)
{
	Url = InUrl;
}

void OpenAPIFuturesApi::AddHeaderParam(const FString& Key, const FString& Value)
{
	AdditionalHeaderParams.Add(Key, Value);
}

void OpenAPIFuturesApi::ClearHeaderParams()
{
	AdditionalHeaderParams.Reset();
}

bool OpenAPIFuturesApi::IsValid() const
{
	if (Url.IsEmpty())
	{
		UE_LOG(LogOpenAPI, Error, TEXT("OpenAPIFuturesApi: Endpoint Url is not set, request cannot be performed"));
		return false;
	}

	return true;
}

void OpenAPIFuturesApi::SetHttpRetryManager(FHttpRetrySystem::FManager& InRetryManager)
{
	if(RetryManager != &GetHttpRetryManager())
	{
		DefaultRetryManager.Reset();
		RetryManager = &InRetryManager;
	}
}

FHttpRetrySystem::FManager& OpenAPIFuturesApi::GetHttpRetryManager()
{
	checkf(RetryManager, TEXT("OpenAPIFuturesApi: RetryManager is null.  You may have meant to set it with SetHttpRetryManager first, or you may not be using a custom RetryManager at all."))
	return *RetryManager;
}

FHttpRequestRef OpenAPIFuturesApi::CreateHttpRequest(const Request& Request) const
{
	if (!Request.GetRetryParams().IsSet())
	{
		return FHttpModule::Get().CreateRequest();
	}
	else
	{
		if (!RetryManager)
		{
			// Create default retry manager if none was specified
			DefaultRetryManager = MakeUnique<HttpRetryManager>(6, 60);
			RetryManager = DefaultRetryManager.Get();
		}

		const HttpRetryParams& Params = Request.GetRetryParams().GetValue();
		return RetryManager->CreateRequest(Params.RetryLimitCountOverride, Params.RetryTimeoutRelativeSecondsOverride, Params.RetryResponseCodes, Params.RetryVerbs, Params.RetryDomains);
	}
}

void OpenAPIFuturesApi::HandleResponse(FHttpResponsePtr HttpResponse, bool bSucceeded, Response& InOutResponse) const
{
	InOutResponse.SetHttpResponse(HttpResponse);
	InOutResponse.SetSuccessful(bSucceeded);

	if (bSucceeded && HttpResponse.IsValid())
	{
		InOutResponse.SetHttpResponseCode((EHttpResponseCodes::Type)HttpResponse->GetResponseCode());
		FString ContentType = HttpResponse->GetContentType();
		FString Content;

		if (ContentType.IsEmpty())
		{
			return; // Nothing to parse
		}
		else if (ContentType.StartsWith(TEXT("application/json")) || ContentType.StartsWith("text/json"))
		{
			Content = HttpResponse->GetContentAsString();

			TSharedPtr<FJsonValue> JsonValue;
			auto Reader = TJsonReaderFactory<>::Create(Content);

			if (FJsonSerializer::Deserialize(Reader, JsonValue) && JsonValue.IsValid())
			{
				if (InOutResponse.FromJson(JsonValue))
					return; // Successfully parsed
			}
		}
		else if(ContentType.StartsWith(TEXT("text/plain")))
		{
			Content = HttpResponse->GetContentAsString();
			InOutResponse.SetResponseString(Content);
			return; // Successfully parsed
		}

		// Report the parse error but do not mark the request as unsuccessful. Data could be partial or malformed, but the request succeeded.
		UE_LOG(LogOpenAPI, Error, TEXT("Failed to deserialize Http response content (type:%s):\n%s"), *ContentType , *Content);
		return;
	}

	// By default, assume we failed to establish connection
	InOutResponse.SetHttpResponseCode(EHttpResponseCodes::RequestTimeout);
}

FHttpRequestPtr OpenAPIFuturesApi::FuturesV1HistoricalDays(const FuturesV1HistoricalDaysRequest& Request, const FFuturesV1HistoricalDaysDelegate& Delegate /*= FFuturesV1HistoricalDaysDelegate()*/) const
{
	if (!IsValid())
		return nullptr;

	FHttpRequestRef HttpRequest = CreateHttpRequest(Request);
	HttpRequest->SetURL(*(Url + Request.ComputePath()));

	for(const auto& It : AdditionalHeaderParams)
	{
		HttpRequest->SetHeader(It.Key, It.Value);
	}

	Request.SetupHttpRequest(HttpRequest);

	HttpRequest->OnProcessRequestComplete().BindRaw(this, &OpenAPIFuturesApi::OnFuturesV1HistoricalDaysResponse, Delegate);
	HttpRequest->ProcessRequest();
	return HttpRequest;
}

void OpenAPIFuturesApi::OnFuturesV1HistoricalDaysResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FFuturesV1HistoricalDaysDelegate Delegate) const
{
	FuturesV1HistoricalDaysResponse Response;
	HandleResponse(HttpResponse, bSucceeded, Response);
	Delegate.ExecuteIfBound(Response);
}

FHttpRequestPtr OpenAPIFuturesApi::FuturesV1HistoricalFundingRateDays(const FuturesV1HistoricalFundingRateDaysRequest& Request, const FFuturesV1HistoricalFundingRateDaysDelegate& Delegate /*= FFuturesV1HistoricalFundingRateDaysDelegate()*/) const
{
	if (!IsValid())
		return nullptr;

	FHttpRequestRef HttpRequest = CreateHttpRequest(Request);
	HttpRequest->SetURL(*(Url + Request.ComputePath()));

	for(const auto& It : AdditionalHeaderParams)
	{
		HttpRequest->SetHeader(It.Key, It.Value);
	}

	Request.SetupHttpRequest(HttpRequest);

	HttpRequest->OnProcessRequestComplete().BindRaw(this, &OpenAPIFuturesApi::OnFuturesV1HistoricalFundingRateDaysResponse, Delegate);
	HttpRequest->ProcessRequest();
	return HttpRequest;
}

void OpenAPIFuturesApi::OnFuturesV1HistoricalFundingRateDaysResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FFuturesV1HistoricalFundingRateDaysDelegate Delegate) const
{
	FuturesV1HistoricalFundingRateDaysResponse Response;
	HandleResponse(HttpResponse, bSucceeded, Response);
	Delegate.ExecuteIfBound(Response);
}

FHttpRequestPtr OpenAPIFuturesApi::FuturesV1HistoricalFundingRateHours(const FuturesV1HistoricalFundingRateHoursRequest& Request, const FFuturesV1HistoricalFundingRateHoursDelegate& Delegate /*= FFuturesV1HistoricalFundingRateHoursDelegate()*/) const
{
	if (!IsValid())
		return nullptr;

	FHttpRequestRef HttpRequest = CreateHttpRequest(Request);
	HttpRequest->SetURL(*(Url + Request.ComputePath()));

	for(const auto& It : AdditionalHeaderParams)
	{
		HttpRequest->SetHeader(It.Key, It.Value);
	}

	Request.SetupHttpRequest(HttpRequest);

	HttpRequest->OnProcessRequestComplete().BindRaw(this, &OpenAPIFuturesApi::OnFuturesV1HistoricalFundingRateHoursResponse, Delegate);
	HttpRequest->ProcessRequest();
	return HttpRequest;
}

void OpenAPIFuturesApi::OnFuturesV1HistoricalFundingRateHoursResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FFuturesV1HistoricalFundingRateHoursDelegate Delegate) const
{
	FuturesV1HistoricalFundingRateHoursResponse Response;
	HandleResponse(HttpResponse, bSucceeded, Response);
	Delegate.ExecuteIfBound(Response);
}

FHttpRequestPtr OpenAPIFuturesApi::FuturesV1HistoricalFundingRateMessages(const FuturesV1HistoricalFundingRateMessagesRequest& Request, const FFuturesV1HistoricalFundingRateMessagesDelegate& Delegate /*= FFuturesV1HistoricalFundingRateMessagesDelegate()*/) const
{
	if (!IsValid())
		return nullptr;

	FHttpRequestRef HttpRequest = CreateHttpRequest(Request);
	HttpRequest->SetURL(*(Url + Request.ComputePath()));

	for(const auto& It : AdditionalHeaderParams)
	{
		HttpRequest->SetHeader(It.Key, It.Value);
	}

	Request.SetupHttpRequest(HttpRequest);

	HttpRequest->OnProcessRequestComplete().BindRaw(this, &OpenAPIFuturesApi::OnFuturesV1HistoricalFundingRateMessagesResponse, Delegate);
	HttpRequest->ProcessRequest();
	return HttpRequest;
}

void OpenAPIFuturesApi::OnFuturesV1HistoricalFundingRateMessagesResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FFuturesV1HistoricalFundingRateMessagesDelegate Delegate) const
{
	FuturesV1HistoricalFundingRateMessagesResponse Response;
	HandleResponse(HttpResponse, bSucceeded, Response);
	Delegate.ExecuteIfBound(Response);
}

FHttpRequestPtr OpenAPIFuturesApi::FuturesV1HistoricalFundingRateMessagesHour(const FuturesV1HistoricalFundingRateMessagesHourRequest& Request, const FFuturesV1HistoricalFundingRateMessagesHourDelegate& Delegate /*= FFuturesV1HistoricalFundingRateMessagesHourDelegate()*/) const
{
	if (!IsValid())
		return nullptr;

	FHttpRequestRef HttpRequest = CreateHttpRequest(Request);
	HttpRequest->SetURL(*(Url + Request.ComputePath()));

	for(const auto& It : AdditionalHeaderParams)
	{
		HttpRequest->SetHeader(It.Key, It.Value);
	}

	Request.SetupHttpRequest(HttpRequest);

	HttpRequest->OnProcessRequestComplete().BindRaw(this, &OpenAPIFuturesApi::OnFuturesV1HistoricalFundingRateMessagesHourResponse, Delegate);
	HttpRequest->ProcessRequest();
	return HttpRequest;
}

void OpenAPIFuturesApi::OnFuturesV1HistoricalFundingRateMessagesHourResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FFuturesV1HistoricalFundingRateMessagesHourDelegate Delegate) const
{
	FuturesV1HistoricalFundingRateMessagesHourResponse Response;
	HandleResponse(HttpResponse, bSucceeded, Response);
	Delegate.ExecuteIfBound(Response);
}

FHttpRequestPtr OpenAPIFuturesApi::FuturesV1HistoricalFundingRateMinutes(const FuturesV1HistoricalFundingRateMinutesRequest& Request, const FFuturesV1HistoricalFundingRateMinutesDelegate& Delegate /*= FFuturesV1HistoricalFundingRateMinutesDelegate()*/) const
{
	if (!IsValid())
		return nullptr;

	FHttpRequestRef HttpRequest = CreateHttpRequest(Request);
	HttpRequest->SetURL(*(Url + Request.ComputePath()));

	for(const auto& It : AdditionalHeaderParams)
	{
		HttpRequest->SetHeader(It.Key, It.Value);
	}

	Request.SetupHttpRequest(HttpRequest);

	HttpRequest->OnProcessRequestComplete().BindRaw(this, &OpenAPIFuturesApi::OnFuturesV1HistoricalFundingRateMinutesResponse, Delegate);
	HttpRequest->ProcessRequest();
	return HttpRequest;
}

void OpenAPIFuturesApi::OnFuturesV1HistoricalFundingRateMinutesResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FFuturesV1HistoricalFundingRateMinutesDelegate Delegate) const
{
	FuturesV1HistoricalFundingRateMinutesResponse Response;
	HandleResponse(HttpResponse, bSucceeded, Response);
	Delegate.ExecuteIfBound(Response);
}

FHttpRequestPtr OpenAPIFuturesApi::FuturesV1HistoricalHours(const FuturesV1HistoricalHoursRequest& Request, const FFuturesV1HistoricalHoursDelegate& Delegate /*= FFuturesV1HistoricalHoursDelegate()*/) const
{
	if (!IsValid())
		return nullptr;

	FHttpRequestRef HttpRequest = CreateHttpRequest(Request);
	HttpRequest->SetURL(*(Url + Request.ComputePath()));

	for(const auto& It : AdditionalHeaderParams)
	{
		HttpRequest->SetHeader(It.Key, It.Value);
	}

	Request.SetupHttpRequest(HttpRequest);

	HttpRequest->OnProcessRequestComplete().BindRaw(this, &OpenAPIFuturesApi::OnFuturesV1HistoricalHoursResponse, Delegate);
	HttpRequest->ProcessRequest();
	return HttpRequest;
}

void OpenAPIFuturesApi::OnFuturesV1HistoricalHoursResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FFuturesV1HistoricalHoursDelegate Delegate) const
{
	FuturesV1HistoricalHoursResponse Response;
	HandleResponse(HttpResponse, bSucceeded, Response);
	Delegate.ExecuteIfBound(Response);
}

FHttpRequestPtr OpenAPIFuturesApi::FuturesV1HistoricalMinutes(const FuturesV1HistoricalMinutesRequest& Request, const FFuturesV1HistoricalMinutesDelegate& Delegate /*= FFuturesV1HistoricalMinutesDelegate()*/) const
{
	if (!IsValid())
		return nullptr;

	FHttpRequestRef HttpRequest = CreateHttpRequest(Request);
	HttpRequest->SetURL(*(Url + Request.ComputePath()));

	for(const auto& It : AdditionalHeaderParams)
	{
		HttpRequest->SetHeader(It.Key, It.Value);
	}

	Request.SetupHttpRequest(HttpRequest);

	HttpRequest->OnProcessRequestComplete().BindRaw(this, &OpenAPIFuturesApi::OnFuturesV1HistoricalMinutesResponse, Delegate);
	HttpRequest->ProcessRequest();
	return HttpRequest;
}

void OpenAPIFuturesApi::OnFuturesV1HistoricalMinutesResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FFuturesV1HistoricalMinutesDelegate Delegate) const
{
	FuturesV1HistoricalMinutesResponse Response;
	HandleResponse(HttpResponse, bSucceeded, Response);
	Delegate.ExecuteIfBound(Response);
}

FHttpRequestPtr OpenAPIFuturesApi::FuturesV1HistoricalOpenInterestDays(const FuturesV1HistoricalOpenInterestDaysRequest& Request, const FFuturesV1HistoricalOpenInterestDaysDelegate& Delegate /*= FFuturesV1HistoricalOpenInterestDaysDelegate()*/) const
{
	if (!IsValid())
		return nullptr;

	FHttpRequestRef HttpRequest = CreateHttpRequest(Request);
	HttpRequest->SetURL(*(Url + Request.ComputePath()));

	for(const auto& It : AdditionalHeaderParams)
	{
		HttpRequest->SetHeader(It.Key, It.Value);
	}

	Request.SetupHttpRequest(HttpRequest);

	HttpRequest->OnProcessRequestComplete().BindRaw(this, &OpenAPIFuturesApi::OnFuturesV1HistoricalOpenInterestDaysResponse, Delegate);
	HttpRequest->ProcessRequest();
	return HttpRequest;
}

void OpenAPIFuturesApi::OnFuturesV1HistoricalOpenInterestDaysResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FFuturesV1HistoricalOpenInterestDaysDelegate Delegate) const
{
	FuturesV1HistoricalOpenInterestDaysResponse Response;
	HandleResponse(HttpResponse, bSucceeded, Response);
	Delegate.ExecuteIfBound(Response);
}

FHttpRequestPtr OpenAPIFuturesApi::FuturesV1HistoricalOpenInterestHours(const FuturesV1HistoricalOpenInterestHoursRequest& Request, const FFuturesV1HistoricalOpenInterestHoursDelegate& Delegate /*= FFuturesV1HistoricalOpenInterestHoursDelegate()*/) const
{
	if (!IsValid())
		return nullptr;

	FHttpRequestRef HttpRequest = CreateHttpRequest(Request);
	HttpRequest->SetURL(*(Url + Request.ComputePath()));

	for(const auto& It : AdditionalHeaderParams)
	{
		HttpRequest->SetHeader(It.Key, It.Value);
	}

	Request.SetupHttpRequest(HttpRequest);

	HttpRequest->OnProcessRequestComplete().BindRaw(this, &OpenAPIFuturesApi::OnFuturesV1HistoricalOpenInterestHoursResponse, Delegate);
	HttpRequest->ProcessRequest();
	return HttpRequest;
}

void OpenAPIFuturesApi::OnFuturesV1HistoricalOpenInterestHoursResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FFuturesV1HistoricalOpenInterestHoursDelegate Delegate) const
{
	FuturesV1HistoricalOpenInterestHoursResponse Response;
	HandleResponse(HttpResponse, bSucceeded, Response);
	Delegate.ExecuteIfBound(Response);
}

FHttpRequestPtr OpenAPIFuturesApi::FuturesV1HistoricalOpenInterestMessages(const FuturesV1HistoricalOpenInterestMessagesRequest& Request, const FFuturesV1HistoricalOpenInterestMessagesDelegate& Delegate /*= FFuturesV1HistoricalOpenInterestMessagesDelegate()*/) const
{
	if (!IsValid())
		return nullptr;

	FHttpRequestRef HttpRequest = CreateHttpRequest(Request);
	HttpRequest->SetURL(*(Url + Request.ComputePath()));

	for(const auto& It : AdditionalHeaderParams)
	{
		HttpRequest->SetHeader(It.Key, It.Value);
	}

	Request.SetupHttpRequest(HttpRequest);

	HttpRequest->OnProcessRequestComplete().BindRaw(this, &OpenAPIFuturesApi::OnFuturesV1HistoricalOpenInterestMessagesResponse, Delegate);
	HttpRequest->ProcessRequest();
	return HttpRequest;
}

void OpenAPIFuturesApi::OnFuturesV1HistoricalOpenInterestMessagesResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FFuturesV1HistoricalOpenInterestMessagesDelegate Delegate) const
{
	FuturesV1HistoricalOpenInterestMessagesResponse Response;
	HandleResponse(HttpResponse, bSucceeded, Response);
	Delegate.ExecuteIfBound(Response);
}

FHttpRequestPtr OpenAPIFuturesApi::FuturesV1HistoricalOpenInterestMessagesHour(const FuturesV1HistoricalOpenInterestMessagesHourRequest& Request, const FFuturesV1HistoricalOpenInterestMessagesHourDelegate& Delegate /*= FFuturesV1HistoricalOpenInterestMessagesHourDelegate()*/) const
{
	if (!IsValid())
		return nullptr;

	FHttpRequestRef HttpRequest = CreateHttpRequest(Request);
	HttpRequest->SetURL(*(Url + Request.ComputePath()));

	for(const auto& It : AdditionalHeaderParams)
	{
		HttpRequest->SetHeader(It.Key, It.Value);
	}

	Request.SetupHttpRequest(HttpRequest);

	HttpRequest->OnProcessRequestComplete().BindRaw(this, &OpenAPIFuturesApi::OnFuturesV1HistoricalOpenInterestMessagesHourResponse, Delegate);
	HttpRequest->ProcessRequest();
	return HttpRequest;
}

void OpenAPIFuturesApi::OnFuturesV1HistoricalOpenInterestMessagesHourResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FFuturesV1HistoricalOpenInterestMessagesHourDelegate Delegate) const
{
	FuturesV1HistoricalOpenInterestMessagesHourResponse Response;
	HandleResponse(HttpResponse, bSucceeded, Response);
	Delegate.ExecuteIfBound(Response);
}

FHttpRequestPtr OpenAPIFuturesApi::FuturesV1HistoricalOpenInterestMinutes(const FuturesV1HistoricalOpenInterestMinutesRequest& Request, const FFuturesV1HistoricalOpenInterestMinutesDelegate& Delegate /*= FFuturesV1HistoricalOpenInterestMinutesDelegate()*/) const
{
	if (!IsValid())
		return nullptr;

	FHttpRequestRef HttpRequest = CreateHttpRequest(Request);
	HttpRequest->SetURL(*(Url + Request.ComputePath()));

	for(const auto& It : AdditionalHeaderParams)
	{
		HttpRequest->SetHeader(It.Key, It.Value);
	}

	Request.SetupHttpRequest(HttpRequest);

	HttpRequest->OnProcessRequestComplete().BindRaw(this, &OpenAPIFuturesApi::OnFuturesV1HistoricalOpenInterestMinutesResponse, Delegate);
	HttpRequest->ProcessRequest();
	return HttpRequest;
}

void OpenAPIFuturesApi::OnFuturesV1HistoricalOpenInterestMinutesResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FFuturesV1HistoricalOpenInterestMinutesDelegate Delegate) const
{
	FuturesV1HistoricalOpenInterestMinutesResponse Response;
	HandleResponse(HttpResponse, bSucceeded, Response);
	Delegate.ExecuteIfBound(Response);
}

FHttpRequestPtr OpenAPIFuturesApi::FuturesV1HistoricalTrades(const FuturesV1HistoricalTradesRequest& Request, const FFuturesV1HistoricalTradesDelegate& Delegate /*= FFuturesV1HistoricalTradesDelegate()*/) const
{
	if (!IsValid())
		return nullptr;

	FHttpRequestRef HttpRequest = CreateHttpRequest(Request);
	HttpRequest->SetURL(*(Url + Request.ComputePath()));

	for(const auto& It : AdditionalHeaderParams)
	{
		HttpRequest->SetHeader(It.Key, It.Value);
	}

	Request.SetupHttpRequest(HttpRequest);

	HttpRequest->OnProcessRequestComplete().BindRaw(this, &OpenAPIFuturesApi::OnFuturesV1HistoricalTradesResponse, Delegate);
	HttpRequest->ProcessRequest();
	return HttpRequest;
}

void OpenAPIFuturesApi::OnFuturesV1HistoricalTradesResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FFuturesV1HistoricalTradesDelegate Delegate) const
{
	FuturesV1HistoricalTradesResponse Response;
	HandleResponse(HttpResponse, bSucceeded, Response);
	Delegate.ExecuteIfBound(Response);
}

FHttpRequestPtr OpenAPIFuturesApi::FuturesV1HistoricalTradesHour(const FuturesV1HistoricalTradesHourRequest& Request, const FFuturesV1HistoricalTradesHourDelegate& Delegate /*= FFuturesV1HistoricalTradesHourDelegate()*/) const
{
	if (!IsValid())
		return nullptr;

	FHttpRequestRef HttpRequest = CreateHttpRequest(Request);
	HttpRequest->SetURL(*(Url + Request.ComputePath()));

	for(const auto& It : AdditionalHeaderParams)
	{
		HttpRequest->SetHeader(It.Key, It.Value);
	}

	Request.SetupHttpRequest(HttpRequest);

	HttpRequest->OnProcessRequestComplete().BindRaw(this, &OpenAPIFuturesApi::OnFuturesV1HistoricalTradesHourResponse, Delegate);
	HttpRequest->ProcessRequest();
	return HttpRequest;
}

void OpenAPIFuturesApi::OnFuturesV1HistoricalTradesHourResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FFuturesV1HistoricalTradesHourDelegate Delegate) const
{
	FuturesV1HistoricalTradesHourResponse Response;
	HandleResponse(HttpResponse, bSucceeded, Response);
	Delegate.ExecuteIfBound(Response);
}

FHttpRequestPtr OpenAPIFuturesApi::FuturesV1LatestFundingRateTick(const FuturesV1LatestFundingRateTickRequest& Request, const FFuturesV1LatestFundingRateTickDelegate& Delegate /*= FFuturesV1LatestFundingRateTickDelegate()*/) const
{
	if (!IsValid())
		return nullptr;

	FHttpRequestRef HttpRequest = CreateHttpRequest(Request);
	HttpRequest->SetURL(*(Url + Request.ComputePath()));

	for(const auto& It : AdditionalHeaderParams)
	{
		HttpRequest->SetHeader(It.Key, It.Value);
	}

	Request.SetupHttpRequest(HttpRequest);

	HttpRequest->OnProcessRequestComplete().BindRaw(this, &OpenAPIFuturesApi::OnFuturesV1LatestFundingRateTickResponse, Delegate);
	HttpRequest->ProcessRequest();
	return HttpRequest;
}

void OpenAPIFuturesApi::OnFuturesV1LatestFundingRateTickResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FFuturesV1LatestFundingRateTickDelegate Delegate) const
{
	FuturesV1LatestFundingRateTickResponse Response;
	HandleResponse(HttpResponse, bSucceeded, Response);
	Delegate.ExecuteIfBound(Response);
}

FHttpRequestPtr OpenAPIFuturesApi::FuturesV1LatestInstrumentMetadata(const FuturesV1LatestInstrumentMetadataRequest& Request, const FFuturesV1LatestInstrumentMetadataDelegate& Delegate /*= FFuturesV1LatestInstrumentMetadataDelegate()*/) const
{
	if (!IsValid())
		return nullptr;

	FHttpRequestRef HttpRequest = CreateHttpRequest(Request);
	HttpRequest->SetURL(*(Url + Request.ComputePath()));

	for(const auto& It : AdditionalHeaderParams)
	{
		HttpRequest->SetHeader(It.Key, It.Value);
	}

	Request.SetupHttpRequest(HttpRequest);

	HttpRequest->OnProcessRequestComplete().BindRaw(this, &OpenAPIFuturesApi::OnFuturesV1LatestInstrumentMetadataResponse, Delegate);
	HttpRequest->ProcessRequest();
	return HttpRequest;
}

void OpenAPIFuturesApi::OnFuturesV1LatestInstrumentMetadataResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FFuturesV1LatestInstrumentMetadataDelegate Delegate) const
{
	FuturesV1LatestInstrumentMetadataResponse Response;
	HandleResponse(HttpResponse, bSucceeded, Response);
	Delegate.ExecuteIfBound(Response);
}

FHttpRequestPtr OpenAPIFuturesApi::FuturesV1LatestOpenInterestTick(const FuturesV1LatestOpenInterestTickRequest& Request, const FFuturesV1LatestOpenInterestTickDelegate& Delegate /*= FFuturesV1LatestOpenInterestTickDelegate()*/) const
{
	if (!IsValid())
		return nullptr;

	FHttpRequestRef HttpRequest = CreateHttpRequest(Request);
	HttpRequest->SetURL(*(Url + Request.ComputePath()));

	for(const auto& It : AdditionalHeaderParams)
	{
		HttpRequest->SetHeader(It.Key, It.Value);
	}

	Request.SetupHttpRequest(HttpRequest);

	HttpRequest->OnProcessRequestComplete().BindRaw(this, &OpenAPIFuturesApi::OnFuturesV1LatestOpenInterestTickResponse, Delegate);
	HttpRequest->ProcessRequest();
	return HttpRequest;
}

void OpenAPIFuturesApi::OnFuturesV1LatestOpenInterestTickResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FFuturesV1LatestOpenInterestTickDelegate Delegate) const
{
	FuturesV1LatestOpenInterestTickResponse Response;
	HandleResponse(HttpResponse, bSucceeded, Response);
	Delegate.ExecuteIfBound(Response);
}

FHttpRequestPtr OpenAPIFuturesApi::FuturesV1LatestTick(const FuturesV1LatestTickRequest& Request, const FFuturesV1LatestTickDelegate& Delegate /*= FFuturesV1LatestTickDelegate()*/) const
{
	if (!IsValid())
		return nullptr;

	FHttpRequestRef HttpRequest = CreateHttpRequest(Request);
	HttpRequest->SetURL(*(Url + Request.ComputePath()));

	for(const auto& It : AdditionalHeaderParams)
	{
		HttpRequest->SetHeader(It.Key, It.Value);
	}

	Request.SetupHttpRequest(HttpRequest);

	HttpRequest->OnProcessRequestComplete().BindRaw(this, &OpenAPIFuturesApi::OnFuturesV1LatestTickResponse, Delegate);
	HttpRequest->ProcessRequest();
	return HttpRequest;
}

void OpenAPIFuturesApi::OnFuturesV1LatestTickResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FFuturesV1LatestTickDelegate Delegate) const
{
	FuturesV1LatestTickResponse Response;
	HandleResponse(HttpResponse, bSucceeded, Response);
	Delegate.ExecuteIfBound(Response);
}

FHttpRequestPtr OpenAPIFuturesApi::FuturesV1Markets(const FuturesV1MarketsRequest& Request, const FFuturesV1MarketsDelegate& Delegate /*= FFuturesV1MarketsDelegate()*/) const
{
	if (!IsValid())
		return nullptr;

	FHttpRequestRef HttpRequest = CreateHttpRequest(Request);
	HttpRequest->SetURL(*(Url + Request.ComputePath()));

	for(const auto& It : AdditionalHeaderParams)
	{
		HttpRequest->SetHeader(It.Key, It.Value);
	}

	Request.SetupHttpRequest(HttpRequest);

	HttpRequest->OnProcessRequestComplete().BindRaw(this, &OpenAPIFuturesApi::OnFuturesV1MarketsResponse, Delegate);
	HttpRequest->ProcessRequest();
	return HttpRequest;
}

void OpenAPIFuturesApi::OnFuturesV1MarketsResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FFuturesV1MarketsDelegate Delegate) const
{
	FuturesV1MarketsResponse Response;
	HandleResponse(HttpResponse, bSucceeded, Response);
	Delegate.ExecuteIfBound(Response);
}

FHttpRequestPtr OpenAPIFuturesApi::FuturesV1MarketsInstruments(const FuturesV1MarketsInstrumentsRequest& Request, const FFuturesV1MarketsInstrumentsDelegate& Delegate /*= FFuturesV1MarketsInstrumentsDelegate()*/) const
{
	if (!IsValid())
		return nullptr;

	FHttpRequestRef HttpRequest = CreateHttpRequest(Request);
	HttpRequest->SetURL(*(Url + Request.ComputePath()));

	for(const auto& It : AdditionalHeaderParams)
	{
		HttpRequest->SetHeader(It.Key, It.Value);
	}

	Request.SetupHttpRequest(HttpRequest);

	HttpRequest->OnProcessRequestComplete().BindRaw(this, &OpenAPIFuturesApi::OnFuturesV1MarketsInstrumentsResponse, Delegate);
	HttpRequest->ProcessRequest();
	return HttpRequest;
}

void OpenAPIFuturesApi::OnFuturesV1MarketsInstrumentsResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FFuturesV1MarketsInstrumentsDelegate Delegate) const
{
	FuturesV1MarketsInstrumentsResponse Response;
	HandleResponse(HttpResponse, bSucceeded, Response);
	Delegate.ExecuteIfBound(Response);
}

FHttpRequestPtr OpenAPIFuturesApi::FuturesV1MarketsInstrumentsUnmapped(const FuturesV1MarketsInstrumentsUnmappedRequest& Request, const FFuturesV1MarketsInstrumentsUnmappedDelegate& Delegate /*= FFuturesV1MarketsInstrumentsUnmappedDelegate()*/) const
{
	if (!IsValid())
		return nullptr;

	FHttpRequestRef HttpRequest = CreateHttpRequest(Request);
	HttpRequest->SetURL(*(Url + Request.ComputePath()));

	for(const auto& It : AdditionalHeaderParams)
	{
		HttpRequest->SetHeader(It.Key, It.Value);
	}

	Request.SetupHttpRequest(HttpRequest);

	HttpRequest->OnProcessRequestComplete().BindRaw(this, &OpenAPIFuturesApi::OnFuturesV1MarketsInstrumentsUnmappedResponse, Delegate);
	HttpRequest->ProcessRequest();
	return HttpRequest;
}

void OpenAPIFuturesApi::OnFuturesV1MarketsInstrumentsUnmappedResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FFuturesV1MarketsInstrumentsUnmappedDelegate Delegate) const
{
	FuturesV1MarketsInstrumentsUnmappedResponse Response;
	HandleResponse(HttpResponse, bSucceeded, Response);
	Delegate.ExecuteIfBound(Response);
}

FHttpRequestPtr OpenAPIFuturesApi::IndexV1HistoricalDays(const IndexV1HistoricalDaysRequest& Request, const FIndexV1HistoricalDaysDelegate& Delegate /*= FIndexV1HistoricalDaysDelegate()*/) const
{
	if (!IsValid())
		return nullptr;

	FHttpRequestRef HttpRequest = CreateHttpRequest(Request);
	HttpRequest->SetURL(*(Url + Request.ComputePath()));

	for(const auto& It : AdditionalHeaderParams)
	{
		HttpRequest->SetHeader(It.Key, It.Value);
	}

	Request.SetupHttpRequest(HttpRequest);

	HttpRequest->OnProcessRequestComplete().BindRaw(this, &OpenAPIFuturesApi::OnIndexV1HistoricalDaysResponse, Delegate);
	HttpRequest->ProcessRequest();
	return HttpRequest;
}

void OpenAPIFuturesApi::OnIndexV1HistoricalDaysResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FIndexV1HistoricalDaysDelegate Delegate) const
{
	IndexV1HistoricalDaysResponse Response;
	HandleResponse(HttpResponse, bSucceeded, Response);
	Delegate.ExecuteIfBound(Response);
}

FHttpRequestPtr OpenAPIFuturesApi::IndexV1HistoricalHours(const IndexV1HistoricalHoursRequest& Request, const FIndexV1HistoricalHoursDelegate& Delegate /*= FIndexV1HistoricalHoursDelegate()*/) const
{
	if (!IsValid())
		return nullptr;

	FHttpRequestRef HttpRequest = CreateHttpRequest(Request);
	HttpRequest->SetURL(*(Url + Request.ComputePath()));

	for(const auto& It : AdditionalHeaderParams)
	{
		HttpRequest->SetHeader(It.Key, It.Value);
	}

	Request.SetupHttpRequest(HttpRequest);

	HttpRequest->OnProcessRequestComplete().BindRaw(this, &OpenAPIFuturesApi::OnIndexV1HistoricalHoursResponse, Delegate);
	HttpRequest->ProcessRequest();
	return HttpRequest;
}

void OpenAPIFuturesApi::OnIndexV1HistoricalHoursResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FIndexV1HistoricalHoursDelegate Delegate) const
{
	IndexV1HistoricalHoursResponse Response;
	HandleResponse(HttpResponse, bSucceeded, Response);
	Delegate.ExecuteIfBound(Response);
}

FHttpRequestPtr OpenAPIFuturesApi::IndexV1HistoricalMessages(const IndexV1HistoricalMessagesRequest& Request, const FIndexV1HistoricalMessagesDelegate& Delegate /*= FIndexV1HistoricalMessagesDelegate()*/) const
{
	if (!IsValid())
		return nullptr;

	FHttpRequestRef HttpRequest = CreateHttpRequest(Request);
	HttpRequest->SetURL(*(Url + Request.ComputePath()));

	for(const auto& It : AdditionalHeaderParams)
	{
		HttpRequest->SetHeader(It.Key, It.Value);
	}

	Request.SetupHttpRequest(HttpRequest);

	HttpRequest->OnProcessRequestComplete().BindRaw(this, &OpenAPIFuturesApi::OnIndexV1HistoricalMessagesResponse, Delegate);
	HttpRequest->ProcessRequest();
	return HttpRequest;
}

void OpenAPIFuturesApi::OnIndexV1HistoricalMessagesResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FIndexV1HistoricalMessagesDelegate Delegate) const
{
	IndexV1HistoricalMessagesResponse Response;
	HandleResponse(HttpResponse, bSucceeded, Response);
	Delegate.ExecuteIfBound(Response);
}

FHttpRequestPtr OpenAPIFuturesApi::IndexV1HistoricalMessagesHour(const IndexV1HistoricalMessagesHourRequest& Request, const FIndexV1HistoricalMessagesHourDelegate& Delegate /*= FIndexV1HistoricalMessagesHourDelegate()*/) const
{
	if (!IsValid())
		return nullptr;

	FHttpRequestRef HttpRequest = CreateHttpRequest(Request);
	HttpRequest->SetURL(*(Url + Request.ComputePath()));

	for(const auto& It : AdditionalHeaderParams)
	{
		HttpRequest->SetHeader(It.Key, It.Value);
	}

	Request.SetupHttpRequest(HttpRequest);

	HttpRequest->OnProcessRequestComplete().BindRaw(this, &OpenAPIFuturesApi::OnIndexV1HistoricalMessagesHourResponse, Delegate);
	HttpRequest->ProcessRequest();
	return HttpRequest;
}

void OpenAPIFuturesApi::OnIndexV1HistoricalMessagesHourResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FIndexV1HistoricalMessagesHourDelegate Delegate) const
{
	IndexV1HistoricalMessagesHourResponse Response;
	HandleResponse(HttpResponse, bSucceeded, Response);
	Delegate.ExecuteIfBound(Response);
}

FHttpRequestPtr OpenAPIFuturesApi::IndexV1HistoricalMinutes(const IndexV1HistoricalMinutesRequest& Request, const FIndexV1HistoricalMinutesDelegate& Delegate /*= FIndexV1HistoricalMinutesDelegate()*/) const
{
	if (!IsValid())
		return nullptr;

	FHttpRequestRef HttpRequest = CreateHttpRequest(Request);
	HttpRequest->SetURL(*(Url + Request.ComputePath()));

	for(const auto& It : AdditionalHeaderParams)
	{
		HttpRequest->SetHeader(It.Key, It.Value);
	}

	Request.SetupHttpRequest(HttpRequest);

	HttpRequest->OnProcessRequestComplete().BindRaw(this, &OpenAPIFuturesApi::OnIndexV1HistoricalMinutesResponse, Delegate);
	HttpRequest->ProcessRequest();
	return HttpRequest;
}

void OpenAPIFuturesApi::OnIndexV1HistoricalMinutesResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FIndexV1HistoricalMinutesDelegate Delegate) const
{
	IndexV1HistoricalMinutesResponse Response;
	HandleResponse(HttpResponse, bSucceeded, Response);
	Delegate.ExecuteIfBound(Response);
}

FHttpRequestPtr OpenAPIFuturesApi::IndexV1LatestInstrumentMetadata(const IndexV1LatestInstrumentMetadataRequest& Request, const FIndexV1LatestInstrumentMetadataDelegate& Delegate /*= FIndexV1LatestInstrumentMetadataDelegate()*/) const
{
	if (!IsValid())
		return nullptr;

	FHttpRequestRef HttpRequest = CreateHttpRequest(Request);
	HttpRequest->SetURL(*(Url + Request.ComputePath()));

	for(const auto& It : AdditionalHeaderParams)
	{
		HttpRequest->SetHeader(It.Key, It.Value);
	}

	Request.SetupHttpRequest(HttpRequest);

	HttpRequest->OnProcessRequestComplete().BindRaw(this, &OpenAPIFuturesApi::OnIndexV1LatestInstrumentMetadataResponse, Delegate);
	HttpRequest->ProcessRequest();
	return HttpRequest;
}

void OpenAPIFuturesApi::OnIndexV1LatestInstrumentMetadataResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FIndexV1LatestInstrumentMetadataDelegate Delegate) const
{
	IndexV1LatestInstrumentMetadataResponse Response;
	HandleResponse(HttpResponse, bSucceeded, Response);
	Delegate.ExecuteIfBound(Response);
}

FHttpRequestPtr OpenAPIFuturesApi::IndexV1LatestTick(const IndexV1LatestTickRequest& Request, const FIndexV1LatestTickDelegate& Delegate /*= FIndexV1LatestTickDelegate()*/) const
{
	if (!IsValid())
		return nullptr;

	FHttpRequestRef HttpRequest = CreateHttpRequest(Request);
	HttpRequest->SetURL(*(Url + Request.ComputePath()));

	for(const auto& It : AdditionalHeaderParams)
	{
		HttpRequest->SetHeader(It.Key, It.Value);
	}

	Request.SetupHttpRequest(HttpRequest);

	HttpRequest->OnProcessRequestComplete().BindRaw(this, &OpenAPIFuturesApi::OnIndexV1LatestTickResponse, Delegate);
	HttpRequest->ProcessRequest();
	return HttpRequest;
}

void OpenAPIFuturesApi::OnIndexV1LatestTickResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FIndexV1LatestTickDelegate Delegate) const
{
	IndexV1LatestTickResponse Response;
	HandleResponse(HttpResponse, bSucceeded, Response);
	Delegate.ExecuteIfBound(Response);
}

FHttpRequestPtr OpenAPIFuturesApi::IndexV1Markets(const IndexV1MarketsRequest& Request, const FIndexV1MarketsDelegate& Delegate /*= FIndexV1MarketsDelegate()*/) const
{
	if (!IsValid())
		return nullptr;

	FHttpRequestRef HttpRequest = CreateHttpRequest(Request);
	HttpRequest->SetURL(*(Url + Request.ComputePath()));

	for(const auto& It : AdditionalHeaderParams)
	{
		HttpRequest->SetHeader(It.Key, It.Value);
	}

	Request.SetupHttpRequest(HttpRequest);

	HttpRequest->OnProcessRequestComplete().BindRaw(this, &OpenAPIFuturesApi::OnIndexV1MarketsResponse, Delegate);
	HttpRequest->ProcessRequest();
	return HttpRequest;
}

void OpenAPIFuturesApi::OnIndexV1MarketsResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FIndexV1MarketsDelegate Delegate) const
{
	IndexV1MarketsResponse Response;
	HandleResponse(HttpResponse, bSucceeded, Response);
	Delegate.ExecuteIfBound(Response);
}

FHttpRequestPtr OpenAPIFuturesApi::IndexV1MarketsInstruments(const IndexV1MarketsInstrumentsRequest& Request, const FIndexV1MarketsInstrumentsDelegate& Delegate /*= FIndexV1MarketsInstrumentsDelegate()*/) const
{
	if (!IsValid())
		return nullptr;

	FHttpRequestRef HttpRequest = CreateHttpRequest(Request);
	HttpRequest->SetURL(*(Url + Request.ComputePath()));

	for(const auto& It : AdditionalHeaderParams)
	{
		HttpRequest->SetHeader(It.Key, It.Value);
	}

	Request.SetupHttpRequest(HttpRequest);

	HttpRequest->OnProcessRequestComplete().BindRaw(this, &OpenAPIFuturesApi::OnIndexV1MarketsInstrumentsResponse, Delegate);
	HttpRequest->ProcessRequest();
	return HttpRequest;
}

void OpenAPIFuturesApi::OnIndexV1MarketsInstrumentsResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FIndexV1MarketsInstrumentsDelegate Delegate) const
{
	IndexV1MarketsInstrumentsResponse Response;
	HandleResponse(HttpResponse, bSucceeded, Response);
	Delegate.ExecuteIfBound(Response);
}

FHttpRequestPtr OpenAPIFuturesApi::IndexV1MarketsInstrumentsUnmapped(const IndexV1MarketsInstrumentsUnmappedRequest& Request, const FIndexV1MarketsInstrumentsUnmappedDelegate& Delegate /*= FIndexV1MarketsInstrumentsUnmappedDelegate()*/) const
{
	if (!IsValid())
		return nullptr;

	FHttpRequestRef HttpRequest = CreateHttpRequest(Request);
	HttpRequest->SetURL(*(Url + Request.ComputePath()));

	for(const auto& It : AdditionalHeaderParams)
	{
		HttpRequest->SetHeader(It.Key, It.Value);
	}

	Request.SetupHttpRequest(HttpRequest);

	HttpRequest->OnProcessRequestComplete().BindRaw(this, &OpenAPIFuturesApi::OnIndexV1MarketsInstrumentsUnmappedResponse, Delegate);
	HttpRequest->ProcessRequest();
	return HttpRequest;
}

void OpenAPIFuturesApi::OnIndexV1MarketsInstrumentsUnmappedResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FIndexV1MarketsInstrumentsUnmappedDelegate Delegate) const
{
	IndexV1MarketsInstrumentsUnmappedResponse Response;
	HandleResponse(HttpResponse, bSucceeded, Response);
	Delegate.ExecuteIfBound(Response);
}

}
